<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="#### 排序  ##### 排序的基本概念 有废话啊，边学边学英语，所以都写上去了，可以简单看看 &amp;gt; Sorting is a very classic problem of reordering items(that can be compared,e.g.integers,floating-point numbers,string,etc) of an array(or a list) in">
<meta property="og:type" content="article">
<meta property="og:title" content="KOKI">
<meta property="og:url" content="http://yoursite.com/2019/11/14/shujujiegou/排序拷贝/index.html">
<meta property="og:site_name" content="KOKI">
<meta property="og:description" content="#### 排序  ##### 排序的基本概念 有废话啊，边学边学英语，所以都写上去了，可以简单看看 &amp;gt; Sorting is a very classic problem of reordering items(that can be compared,e.g.integers,floating-point numbers,string,etc) of an array(or a list) in">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-11-18T07:17:55.628Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KOKI">
<meta name="twitter:description" content="#### 排序  ##### 排序的基本概念 有废话啊，边学边学英语，所以都写上去了，可以简单看看 &amp;gt; Sorting is a very classic problem of reordering items(that can be compared,e.g.integers,floating-point numbers,string,etc) of an array(or a list) in">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/14/shujujiegou/排序拷贝/">





  <title> | KOKI</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a5ecac7771fad0fda5191a255b9e3f5c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KOKI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/14/shujujiegou/排序拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-14T00:28:22+08:00">
                2019-11-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-11-18T15:17:55+08:00">
                2019-11-18
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/11/14/shujujiegou/排序拷贝/" class="leancloud_visitors" data-flag-title>
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  40
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        #### 排序

##### 排序的基本概念
有废话啊，边学边学英语，所以都写上去了，可以简单看看
> Sorting is a very classic problem of reordering items(that can be compared,e.g.integers,floating-point numbers,string,etc) of an array(or a list) in a certain order(increasing, non-decreasing, decreasing,non-increasing,lexicographical,etc.) 排序是一个经典的问题，它以一定的顺序对一个数组(或一个列表)中的项进行重新排序(可以进行比较，例如整数，浮点数，字符串等)
(增加，非递减，增加，词典等)。

There are many different sorting algorithms,each has its own advantages and limitations. 有许多不同的排序算法，么个都有其自身的有点和局限性

Sorting is commonly used as the introductory problem in various Computer Science classes to showcase a range of algorithmic ideas. 排序通常被用作各种计算机科学课程中的介绍性问题，以展示一系列算法思想。

Without loss of generality, we assume that we will sort only integers, not necessarily distinct, in non-decreasing order in this visualization, Try clicking Bubble Sort for a sample animation of sorting the list of 5 jumbled integers(with duplicate) above. 在不是概性的情况下,我们假设在这个可视化中，我们将只按非递减顺序对整数进行排序, 但不一定是明显的，尝试点击Bubble Sort以查看上面排序5个混乱整数(带有重复项)列表的示例动画。

Click 'Next' (on the top right)/press 'Page down' to advance this e-Lecture slide,use the drop down list/press 'Space' to jump to a specific slide,or Click 'X' (on the bottom right)/press 'ESC' to go to Exploration mode. 点击下一步，在右上角，按下翻页来推进这个电子讲座幻灯片，使用下拉列表/按'空格'跳转到特定幻灯片，或者点击'x'(底部 右键)/按 ESC进入探索模式。

Motivation - interesting CS Ideas 动机-有趣的计算机科学想法
Sorting problems has a variety of interesting algorithmic solution that embody many Computer Science ideas:
排序问题有许多有趣的算法解决方案，体现了很多计算机科学的想法：

    1.Comparison versus non-comparison based strategies, 比较与非比较策略
    2.Iterative versus Recursive implementation, 迭代与递归实现
    3.Divide-and-Conquer paradigm (this or that), 分而治之范式
    4.Best/Worst/Average-case Time Complexity analysis, 最佳/最差/平均时间复杂度分析
    5.Randomized Algorithms, etc. 随机算法等

Motivation - Application 动机 - 应用
when a (integar) array A is sorted,many problems involving A become easy (or easier):
当(整数)数组A排序时, 涉及A的许多问题变得简单(或更容易):
    1. Searching for a specific value v in array A. 在数组A中搜索特定值v
    2. Finding the min/max or the k-th smallest/largest value in (static) array A.查找(静态)数组A中的最小/最大/第k个最小/最大值
    3. Testing for uniqueness and deleting duplicates in array A. 测试唯一性并删除数组A中的重复项
    4. Counting how many time a specific value v appear in array A 计算特定值v在数组A中出现多少次
    5. Set intersection/union between array A and another sorted array B. 设置数组A和另一个排序数组B之间的交集/联合
    6. Finding a target pair x ∈ A and y ∈ A such that x+y equals to a target z,ect. 寻找一个目标对 x∈A 和 y∈A, 使得x+y等于目标z等。

    Discussion：In real-life classes, the instructor may elaborate more on these applications. 讨论：在现实生活中，指导员可以详细阐述这些应用

Actions 动作
There are two actions that you can do in this visualization. 你可以在此可视化中执行两项操作。

2.1 Define Your Own Input 定义你自己的输入

The first action is about defining your own input, an array/a list that is: 
第一步是关于定义你自己的输入，一个数组/一个列表是：
    1. Totally random 完全随机的
    2. Random but sorted (in ascending/decreasing order) 随机排序(按升序/降序排列)
    3. Random but nearly sorted (in ascending/descending order), or 随机但几乎排序(按升序/降序排列)或
    4. Defined solely by yourself. 完全有你自己定义

In Exploration mode, you can experiment with various sorting algorithms provided in this visualization to figure out their best and worst case inputs. 在探索模式下，您可以尝试使用此可视化中提供的各种排序算法来找出最佳和最差情况输入。

2.2 Execute the Selected Sorting Algorithm 执行已选择的排序算法
The second action is the most important one: Execute the active sorting algorithm by clicking 'Sort' menu and then clicking 'Go'. 第二个操作是最重要的操作：通过单击"Sort"菜单然后单击"Go"执行主动排序算法

Remember that you can switch active algorithm by clicking the respective abbreviation on the top side of this visualization page. 请记住，您可以通过单击此可视化页面顶部的相应缩写来切换活动算法

Some sorting algorithms have certain additional options.You may toggle the options as you wish before clicking 'Go'.For example, in Bubble Sort(and Merge Sort), there is an option to also compute the inversion index of the input array(this is an advanced topic). 一些排序算法有一些额外的选项，在点击"开始"之前，您可以根据需要切换选项。例如，在冒泡排序(和归并排序)中，还可以选择计算输入数组的一个反向指数(这是一个高级主题).

3.Visualisation 可视化
View the visualisation/animation of the chosen sorting algorithm here. 在此处查看所选排序算法的可视化/动画

Without loss of generality,we only show integers in this visualization and our objective is to sort them from the initial state into ascendig order state.


4.Common Sorting Algorithms

At the top,you will see the list of commonly taught sorting algorithms in Computer Science classes.To activate each algorithm, select the abbreviation of respective algorithm name before clicking "Sorting -> Go" 

To facilitate more diversity,we randomize the active algorithm upon each page load.

The first six algorithms are comparsion-based sorting algorithms while the last two are not,We will discuss this idea midway through this e-Lecture.前六个算法是基于比较的排序算法，而后两个则不是，我们将在这节电子课程的中途讨论这一思想.

The middle three algorithms are recursive sorting algorithms while the rest are usually implement iteratively.
中间的三种算法是递归排序算法，其余的通常是迭代实现的。

4.1 Abbreviations 缩写
To save screen space,we abbreviate algorithm names into three character each: 为了节省屏幕空间，我们将算法名称缩写成三个字符：

    1.Comparison-based Sorting Alogrithms: 基于比较的排序算法
        1.BUB - Bubble Sort 冒泡排序
        2.SEL - Selection Sort 选择排序
        3.INS - Insertion Sort 插入排序
        4.MER - Merge Sort(recursive implementation) 归并排序 递归实现
        5.QUI - Quick Sort(recursive implementation) 快速排序 递归实现
        6.R-Q- Random Quick Sort(recursive implementation) 随机快速排序 递归实现
    2.Not comparison-based Sorting Algorithms: 不基于比较的排序算法
        1.COU - Counting Sort 计算排序
        2.RAD - Radix Sort 基数排序

We will discuss three comparison-based sorting algorithms in the next few slides: 在接下来的幻灯片，我们将讨论三种基于比较的排序算法

    1.Bubble Sort 冒泡排序
    2.Selection Sort 选择排序
    3.Insertion Sort 插入排序

They are called comparison-based as they compare pairs of elements of the array and decide whether to swap them or not. 它们被称为基于比较的，因为他们比较数组的元素对并决定是否交换它们.

These three sorting algorithms are the easiest to implement but also not the most efficient, as they run in O(N^2). 这三种排序算法最容易实现，但不是最有效的，因为它们的算法复杂度是O(N^2).

##### 插入排序，算法基本思想，算法代码及基本的时间复杂度分析
>插入排序顾名思义，就是在排序过程中，把数组的每个元素按照大小关系，插入到前面有序区的对应位置。
 Insertion sort is similar to how most people arrange a hand of poker cards. 插入排序类似于大多人安排扑克牌的方式
1st card: 10♠    10♠
2nd card：5♠     5♠ 10♠
3rd card：K♠     5♠ 10♠ K♠

1. Start with one card in your hand
2. Pick the next card and insert it into its proper sorted order.
3. Repeat previous step for all cards.

Without further ado,let's try Inserion Sort on the small example array[40,13,20,8].

mark first element as sorted 将第一个元素标记为已排序
for each unsorted element X 遍历每个没有排序过的元素
    'extract' the element X 提取元素X
    for j=lastSortedIndex down to 0   j 从最后一个被排序的位置开始到0进行遍历
        if current element j > X  如果当前排序过的元素j > 提取过的元素
            move sorted element to the right by 1 将排序过的元素向右移一格
        break loop and insert X here. 否则插入提取的元素


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void insertionSort(int a[], int N)&#123;</span><br><span class="line">    for (int i = 1; i &lt; N; ++i)&#123; // O(N)</span><br><span class="line">        int X = a[i]; // X is the item to be insert</span><br><span class="line">        int j = i - 1;</span><br><span class="line">        for(;j &gt;= 0&amp;&amp;a[j]&gt;X;--j) // can be fast or slow</span><br><span class="line">            a[j+1] = a[j]; // make a place for X</span><br><span class="line">        a[j+1] = X; // index j+1 is the insertion point</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

The outer loop executes N-1 items, that's quite clear.

But the number of times the inner-loop is executed depend on the input:
    1. In best-case scenario,the array is already sorted and(a[j] > X) is always false So no shifting of data is necessary and the inner loop union runs in O(1)
    2. In worst-case scenario, the array is reverse sorted and (a[j] > X) is always true Insertion always occur at the front of the array and the inner loop runs in O(N).

Thus,the best-case time is O(N * 1) = O(N) and the worst-case time is O(N*N) = O(N^2).

##### 希尔排序，算法基本思想，算法代码及基本的时间复杂度分析
> Donald Shell
  怎样可以对插入排序算法做出优化呢？
  - 在大多数元素已经有序的情况下，插入排序的工作量较小（因为不用频繁的进行比较和交换）
  - 在元素数量较少的情况下，插入排序的工作量较小
    
    我们怎么能让大部分元素有序，或者让元素数量减少呢？
    不妨对原始数组进行一些预处理，使得原始数组的大部分元素变得有序，分组排序，以此对数组进行一定的粗略调整


##### 选择排序，算法基本思想，算法代码及基本的时间复杂度分析
> Selection Sort 选择排序
    Given an array of N items and L = 0.Selection Sort will: 给定N个项目和L=0的数组，选择排序将：
        1.Find the position X of the smallest item in the range of [L…N-1]，在[L…N-1]范围内找出最小项目X的位置
        2.Swap X-th item with the L-th item 用第L项交换第X项
        3.Increase the lower-bound L by i and repeat Step 1 until L = N - 2. 将下限L增加1并重复步骤1直到L = N-2
    Without further ado, let's try Selection Sort on the same small example array[29, 10, 14, 37, 13]. 别犹豫，让我们在上面的同一个小例子数组上尝试selection Sort.


    Without loss of generality, we can also implement Selection Sort in reverse: 在不失普遍性的情况下，我们也可以实现反向的选择排序
    Find the position of the largest item Y and swap it with the last item.找到最大项目Y的位置并将与其最后一个项目交换。

> Selection Sort 选择排序
repeat (numOfElements - 1) times 重复(元素个数 - 1)次
    set the first unsorted element as the minum 把第一个没有排序过的元素设置为最小值
    for each of the unsorted elements 遍历每个没有排序过的元素
        if element < currentMinimum 如果元素 < 现在的最小值
            set element as new minimum 将此元素设置成为新的最小值
    swap minimum with first unsorted position 将最小值和第一个没有排序过的位置交换

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void selectionSort(int a[], int N) &#123;</span><br><span class="line">    for (int L=0; L&lt;N-2; ++L) &#123; // O(N)</span><br><span class="line">        int X = min_element(a+L, a+N) - a; // O(N)</span><br><span class="line">        swap(a[X], a[L]); // O(1), X may be equal to L(no actual swap)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

Total:O(N^2)

##### 快速排序，算法基本思想，算法代码及基本的时间复杂度分析
这个排序好难，我看了三份资料最后一份资料看懂了

第一份资料：这个没太看懂
> Quick Sort
    Quick Sort is another Divide and Conquer sorting alogrithm (the other one discussed in this visualization page is Merge Sort).快速排序是另一个分而治之的排序算法(另一个在这个可视化的页面中讨论的是归并排序)

We will see that this deterministic,non randomized version of Quick Sort can have bad time complexity of O(N^2) on adversary input before continuing with the randomized and usable version later.我们将看到，这种确定性的，非随机化的快速排序的版本可能在对手输入中具有O(N^2)的很差的时间复杂度，之后再继续随机化的可用版本。

Divid step: Choose an item p(know as the pivot) 划分步骤: 选择一个项p(为枢轴点)
Then partition the items of a[i..j] into three parts: a[i..m-1],a[m],amd a[m+1..j] 然后将a[i..j]的项目分为三个部分:a[i..m-1], a[m], a[m+1..j]
a[i..m-1](possibly empty) contains items that are greater than or equal to P. a[i..m-1](可能为空)包含小于p的项目
a[m] is the pivot p,i.e. index m is the correct position for p in the sorted order of array a. a[m]是枢轴点p,例如：指数m是已排序数组a的排序顺序中p的正确位置。
a[m+1..j](possibly empty) contains items that are greater than or equal to p. a[m+1..j](可能为空)包含大于或等于p的项目。然后，递归地对这两部分进行排序。
Then,recursively sort the two parts. 然后递归地这两部分进行排序

Conquer step: Don't be surprised...We do nothing:O! 解决步骤：不要惊讶……我们什么都不做！

If you compare this with Merge Sort,you will see that Quick Sort D&C steps are totally opposite with Merge Sort. 如果您对将其与归并排序进行比较，您会发现快速排序的D&C步骤与归并排序完全相反。


第二份资料，指针交换排序我看不懂了就

快速排序是从冒泡排序演变而来的算法，但是比冒泡排序要高效的对，所以叫做快速排序
快速排序之所以快速，是因为它使用了分治法。同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的
不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一遍，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。这种思路就叫做分治法。

在分治法的思想下，原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可拆分为止。

这样一共需要多少轮？平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是O(nlogn)
基准元素的选择，以及元素的移动都是快速排序的核心。

如何选择基准元素？

基准元素的选择

> 基准元素，英文pivot，用于在分治过程中以此为中心，把其他元素移动到基准元素的左右两边，那么基准元素如何选择呢？
- 最简单的方式是选择数列的第一个元素
    这种选择在大多数情况下是没有问题的。但是假如有一个原本逆序的数列，期望排列成顺序数列，那么会出现什么情况呢？
                  8 7 6 5 4 3 2 1 
        第一轮：**8** 7 6 5 4 3 2 1
        |——>    1 7 6 5 4 3 2 **8**

        第二轮： **1** 7 6 5 4 3 2
        |——>    **1** 7 6 5 4 3 2

        第三轮： **7** 6 5 4 3 2
        |——>     2 6 5 4 3 **7**
        ……

        整个数列并没有被分成一半一半，每一轮仅仅确定了基准元素的位置。这种情况下数列第一个元素要么是最小值，要么是最大值，根本无法发挥分治法的优势。在这种极端情况下，快速排序需要进行N轮，时间复杂度退化成了O(N^2)

        我们该如何避免这种情况发生呢？其实很简单，我们可以不选择数列的第一个元素，而是随机选择一个元素作为基准元素。

        8 7 6 5 **4** 3 2 1

        这样一来，即使在数列完全逆序的情况下，也可以有效地数列分成两部分。

        当然，及时是随机选择基准元素，每一次也有极小的几率选到数列的最大值或最小值，同样会影响到分治的效果。

        所以，快速排序的平均时间复杂度O(nlogn),最坏情况下的时间复杂度是O(n^2).


元素的移动

    选定了基准元素以后，我们要做的就是把其他元素当中小于基准元素的都移动到基准元素的一边，大于基准元素的都移动到基准元素的另一边。
    具体如何实现？有两种方法：
    1、挖坑法
    2、指针交换法

    “挖坑法”
    给定的原始数列如下，要求从小到大排序:
        4 7 6 5 3 2 8 1
    首先，我们选定基准元素Pivot，并记住这个位置index，这个位置相当于一个“坑”。并且设置两个指针left和right，指向数列的最左和最右两个元素:
             index
    Pivot=4    4    7    6    5    3    2    8    1
             left                                right
             接下来，从right指针开始，把指针所指向的元素和基准元素做比较。如果比pivot大，则right指针向左移动；如果比pivot小，则把right所指向的元素填入坑中。

             在当前数列中，1 < 4 ,所以把1填入基准元素所在位置，也就是坑的位置。这时候，元素1本来的位置变成了新的坑，同时left向右移动一位。

                                                index
    Pivot=4    1    7    6    5    3    2    8    1
                  left                          right
             此时，left左边的区域代表着小于基准元素的区域。

             接下来，我们切换了left指针进行比较。如果left指向的元素小于pivot，则left指针向右移动，如果元素大于pivot，则把left指向的元素填入坑中。

             在当前数列中，7>4, 所以把7填入index的位置，这时候7原本的位置称为了新的坑，同事right向左移动一位。
                  index                           
    Pivot=4    1    7   6    5    3    2    8    7
                  left                     right   
             此时，right右边橙色的区域代表着大于基准元素的区域

             接着按照刚才的思路排序
             8 > 4 ，元素位置不变，right左移
                  index                           
    Pivot=4    1    7   6    5    3    2    8    7
                  left                right 
             2 < 4 , 用2来填坑，left右移，切换到left  
                                     index      
    Pivot=4    1    2   6    5    3    2    8    7
                       left           right 
            6 > 4 ，用6来填坑，right左移，切换到right
                      index                   
    Pivot=4    1    2   6    5    3    6    8    7
                       left     right       
            3 < 4，用3来填坑，left右移，切换到left
                                index      
    Pivot=4    1    2   3    5    3    6    8    7
                            left right       
            5 > 4，用5来填坑，right右移，这时候left和right重合在同一个位置
                            index        
    Pivot=4    1    2   3    5    5    6    8    7
                            right 
                            left      
                
            这时候，把之前的pivot元素，也就是4放到index的位置，此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。

            递归，其实这个还没完，最后的6  8 7 是不对的，

            除了挖坑法以外，要实现元素的移动也可以利用指针交换法

指针交换法

    给定原始数列如下，要求从小到大排序：
    4 7 6 5 3 2 8 1

    开局和挖坑法相似，我们首先选定基准元素Pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素：

        Pivot = 4    4   7   6   5   3    2    8    1
                   left                           right
    接下来是第一次循环，从right指针开始，把指针所指向的元素和基准元素做比较。如果大于等于pivot，则指针向左移动，如果小于pivot，则right指针停止移动，切换到了left指针

第三份资料：浙大的老师 哇终于，看这份资料我理解了，快速动画图示说明理解，看http://www.feemic.cn/mooc/icourse163/1002654021?type=hot#myTab 10.1.3 子集划分

算法概述：

    分而治之：伪码描述
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Quicksort(ElementType A[], int N)&#123;</span><br><span class="line">    if (N &lt; 2) return; // 递归跳出的条件 只有一个元素，递归就不用继续了</span><br><span class="line">    pivot = 从A[]中选一个主元; </span><br><span class="line">    将S= &#123;A[] \ pivot&#125; 分成2个独立子集:</span><br><span class="line">        A1 = &#123; a ∈ S | a&lt;= pivot&#125; 和</span><br><span class="line">        A2 = &#123; a ∈ S | a&gt;= pivot&#125;;</span><br><span class="line">    A[] = Quicksort(A1,N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2,N2); // 递归</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    // ?主元怎么选
    // ?子集怎么分
    // 什么是快速排序算法的最好情况？
        每次正好中分 -> T(N) = O(NlogN)

选主元
- 令pivot = A[0]?
        1 2 3 4 5 6 …… N-1 N
          2 3 4 5 6 …… N-1 N
            3 4 5 6 …… N-1 N

    T(N) = O(N) + T(N-1)
         = O(N) + O(N-1) + T(N-2)
         = O(N) + O(N-1) + …… + O(1)
         = O(N^2)

- 随机取pivot?rand()函数很废时间
- 取头、中、尾的中位数
    例如 8、12、3的中位数就是8
    测试一下pivot不同的取法对运行速度有多大影响
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ElementType Median3(ElementType A[], int Left, int Right)&#123; // 取三数中位数</span><br><span class="line">    int Center = (Left + Right) / 2;</span><br><span class="line">    if(A[Left] &gt; A[Center])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Center]);</span><br><span class="line">    if(A[Left] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Right]);</span><br><span class="line">    if(A[Center] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Center], &amp;A[Right]);</span><br><span class="line"></span><br><span class="line">// A[Left] &lt;= A[Center] &lt;= A[Right]</span><br><span class="line">Swap(&amp;A[Center], &amp;A[Right - 1]) ;// 将pivot藏到右边</span><br><span class="line">// 只需要考虑A[Left+1]……A[Right-2]</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

子集划分

    8   1   4   9   0   3   5   2   7   6

    如果相等交换 O(NlogN)
    不交换的时间复杂度O(N^2)

根据时间复杂度来分析，还是遇到相等元素还是交换吧

小规模数据的处理
    快速排序的问题：
        - 用递归……【会占用额外的系统堆栈的空间】
        - 对小规模的数据(例如N不到100)可能还不如插入顺序快
    解决方案：
        - 当递归的数据规模充分小，则停止递归，直接调用简单排序(例如插入排序)    
        - 大规模数据用递归
        - 在程序中定义一个Cutoff的阈值，比较不同的Cutoff对效率的影响

算法实现
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序</span><br><span class="line">ElementType Median3(ElementType A[], int Left, int Right)&#123;</span><br><span class="line">    int Center = (Left + Right) /2;</span><br><span class="line">    if(A[ left ] &gt; A[ Center ]) Swap(&amp;A[ Left ], &amp;A[ Center ]);</span><br><span class="line">    if(A[ left ] &gt; A[ Right ]) Swap(&amp;A[ Left ], &amp;A[ Right ]);</span><br><span class="line">    if(A[ Center ] &gt; A[ Right ]) Swap(&amp;A[ Center ], &amp;A[ Right ]);</span><br><span class="line">    // 此时A[ Left ] &lt; A[ Center ] &lt; A[ Right ]</span><br><span class="line">    Swap(&amp;A[ Center ], &amp;A[ Right-1 ]); // 将基准pivot藏到右边</span><br><span class="line">    // 只需要考虑A[Left + 1]...A[Right -2]</span><br><span class="line">    return A[Right - 1]; // 返回基准Pivot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Qsort(ElementType A[], int Left, int Right)&#123;</span><br><span class="line">    // 核心递归函数</span><br><span class="line">    int Pivot, Cutoff, Low, High;</span><br><span class="line">    if( Cutoff &lt;= Right - Left)&#123; // 阈值，如果序列元素充分多，做快速排序</span><br><span class="line">        Pivot = Median3(A, Left, Right); // 选主元 选基准</span><br><span class="line">        Low = Left; High = Right - 1; // 划分子集</span><br><span class="line">        while (1)&#123; // 将序列中比基准小的移动到基准的左边，大的移到右边</span><br><span class="line">            while (A[ ++Low ] &lt; Pivot) &#123; &#125;</span><br><span class="line">            while (A[ --Right ] &gt; Pivot) &#123; &#125;</span><br><span class="line">            if(Low &lt; High) Swap(&amp;A[Low], &amp;A[High]);</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 然后把pivot放到正确的位置,将基准换到正确的位置</span><br><span class="line">        Swap(&amp;A[Low], &amp;A[Right-1]); // 把藏到Right-1 上的主元换到A[i]上去</span><br><span class="line">        // 递归排序自集 主元在i的位置上</span><br><span class="line">        Qsort(A, Left, Low-1); // 递归解决左半子集</span><br><span class="line">        Qsort(A, Low+1, Right); // 递归解决右半子集</span><br><span class="line">    &#125; else &#123; // 否则做插入排序 数据太少用简单排序</span><br><span class="line">        Insertion_Sort(A+Lfet, Right-left+1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用一个壳套住 </span><br><span class="line">void QuickSort(ElementType A[], int N)</span><br><span class="line">&#123; // 统一接口</span><br><span class="line">    Qsort(A, 0, N-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

##### 合并排序，算法基本思想，算法代码及基本的时间复杂度分析
Merge Sort
> Given an array of N items, Merge Sort will: 给定一个N个项目的数组，归并排序将：
    1.Merge each pair od individual element (which is by default, sorted)into sorted arrays od 2 elements. 将每对单个元素(默认情况下，已排序)归并为2个元素的有序数组
    2.Merge each pair of sorted arrays of 2 elements into sorted arrays of 4 elements,Repeat the process…, 将2个元素的每对有序数组归并成4个元素的有序数组,重复这个过程……
    3.Final Step:Merge 2 sorted arrays of N/2 elements (for simplicity of this discussion, we assume that N is even) to obtain a fully sorted array of N elements. 最后一步：归并2个N/2元素的排序数组(为了简化讨论，我们假设N是偶数)以获得完全排序的N个元素数组。

This is just the general idea and we need a few more details before we can discuss the true form of Merge Sort. 这只是一般的想法，在我们可以讨论归并排序的真正形式之前，我们需要更多的细节。

10.1 Important Subroutine,O(N) Merge 重要的子程序，O(N)归并

We will dissect this Merge Sort algorithm by first discussing its most important subroutine: The O(N) merge.我们首先讨论归并排序算法的最重要的子程序：O(N)归并，然后解析这个归并排序算法

Given two sorted array.A and B,of size N1 and N2, we can efficiently merge them into one large combined sorted array of size N = N1 + N2, in O(N) time. 给定两个大小为N1和N2的排序数组A和B，我们可以在O(N)时间内将它们有效地归并成一个大小为N = N1 + N2的组合排序数组

This is achieved by simply comparing the front of the two arrays and take the smaller of the two at all times.However, this simple but fast O(N) merge sub-routine will need additional array to do this merging correctly.See the next slide. 这是通过简单地比较两个阵列的前面并始终取两个中较小的一个来实现的，但是这个简单但快速的O(N)合并子例程将需要额外的数组来正确地进行合并。

10-2 Merge Suborutine C++ Implementation 归并子程序C++实现方法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void merge(int a[], int low, int mid, int high)&#123;</span><br><span class="line">    // subarray1 = a[low..mid], subarray2 = a[mid+1, high], both sorted</span><br><span class="line">    int N = high - low + 1;</span><br><span class="line">    int b[N];// discuss: why do we need a temporary array b  讨论：为什么我们需要一个临时数组b</span><br><span class="line">    int left = low, right = mid + 1, bIdx = 0;</span><br><span class="line">    while (left &lt;= mid &amp;&amp; right &lt;= high) // the mergeing</span><br><span class="line">        b[bIdx++] = (a[left] &lt;= a[right]) ? a[left++] : a[right++];</span><br><span class="line">    while (left &lt;= mid) b[bIdx++] = a[left++]; // leftover, if any</span><br><span class="line">    while (right &lt;= high) b[bIdx++] = a[right++]; // leftover, if any</span><br><span class="line">    for(int k=0; k&lt;N; k++) a[low+k] = b[k]; // copy back 在拷贝回去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

Try Merge Sort on the example array[1,5,19,20,2,11,15,17] that have its first half already sorted [1,5,19,20] and its second half also already sorted [2,11,15,17]. Concentrate on the last merge of the Merge Sort algorithm.在示例数组[1,5,19,20,2,11,15,17]上尝试Merge Sort，其前半部分已经排序[1,5,19,20],其下半部分也已经排序[2,11,15,17]。专注于合并排序算法的最后一次合并。

10-3 Divide and Conquer Paradigm 分而治之的范式
Before we continue,let’s talk about Divide and Conquer(abbreviated as D&C), a powerful problem solving paradigm. 在我们继续之前，让我们先谈谈分而治之(Divide and Conquer, 缩写为D&C), 这是一个强大的解决问题的范例。

Divide and Conquer algorithm solves (certain kind of) problem - like our sorting problem - in the following steps: 分而治之算法通过以下步骤解决(某种类型的)问题-比如我们的排序问题：
    1. Divide step: Divide the large, original problem into smaller sub-problems and recursively solve the samller sub-problems, 划分步骤： 将大的原始问题划分成较小的子问题并递归地解决较小的子问题,
    2. Conquer step: Combine the results of the smaller sub-problems to produce the result of the larger,original problem. 解决步骤：结合较小的子问题的结果来产生较大的原始问题的结果。
 

10-4 Merge Sort as a D&C Algorithm 归并排序是分而治之的算法

Merge Sort is a Divide and Conquer sorting algorithm. 归并排序是分而治之的排序算法

The divide step is simple: Divide the current array into two halves (perfectly equal if N is even or one side is slightly greater by one element if N is odd) and then recursively sort the two halves. 划分很简单：将当前数组分成两半(如果N是偶数，则将其完全平等，或者如果N是奇数，则一边稍大于一个元素), 然后递归地对这两半进行排序.

The conquer step is the one that does the most work: Merge the two (sorted) halves to form a sorted array,using the merge sub-routine discussed earlier. 解决步骤是最有效的工作：使用前面讨论的，归并子例合并两个(排序)半部分以形成一个有序数组.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void mergeSort(int a[], int low, int high) &#123;</span><br><span class="line">    // the array to be sorted is a[low..high]</span><br><span class="line">    if(low &lt; high) &#123; // based case; low &gt;= high(0 or 1 item)</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        mergeSort(a, low, mid); // divide into two halves</span><br><span class="line">        mergeSort(a, mid+1, high); // then recursively sort them</span><br><span class="line">        merge(a, low, mid, high); // conquer: the merge subroutine</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

10-6 Demonstration 示范

Please try Merge Sort on the example array [7,2,6,3,8,4,5] to see more details. 请在示例数组[7,2,6,3,8,4,5]上尝试Merge Sort以查看更多详细信息.

Contrary to what many other CS printed textbooks usually show (as textbooks are static), the actual execution of Merge Sort does not split to two subarrays level by level, but it will recursively sort the left subarray first before dealing with the right subarray. 与许多其他CS打印的教科书通常显示的一样(因为教科书是静态的),合并排序的实际执行不会一层一层地分成两个子数组，但是它会在处理正确的子数组之前递归调地排序左边的子数组。

That's it, on example array[7,2,6,3,8,4,5], it will recurse to [7,2,6,3], then [7,2],then [7](a single element, sorted by default), backtrack,recurse to [2](sorted), backtrack, then finally merge[7,2] into [2,7],before it continue processing [6,3] and so on. 就是这样，在示例数组{7,2,6,3,8,4,5}上，它将缓存到{7,2,6,3}，然后是{7,2}，然后是{7}(单个元素，默认排序)，回溯，递归到{2}(排序)，回溯，然后在继续处理{6,3}等等之前，最终将{7,2}合并{2,7}中.


10-7 Merge Sort: Analysis Part 1 归并排序:第一部分 分析
In Merge Sort, the bulk of work is doen in the conquer/merge step as the divide step does not really do anything (treated as O(1)). 在归并排序中，大部分工作是在解决/归并的步骤中完成的，因为分解步骤并没有真正执行任何操作(视为O(1))

When we call merge(a, low, mid, high), we process k = (high - low + 1) items.当我们归并a(a, low, mid, high)时，我们在处理k=(high - low +1)项.
There will be at most k-1 comparsons. 最多会有k-1个比较

There are k moves from original array a to temporary array b and other k moves back.In total, number of operations inside merge sub-routine is < 3K-1 = O(k).从原始数组a到临时数组b有k个移动，而另一个k移回。总的来说，归并子例程内操作次数<3k-1 2 3="o(k)." the important question is how many times this merge sub-routine called? 重要的问题是这个归并子程序被调用了多少次？ 10-8 sort: analysis part 归并排序:第二部分 分析 ![归并排序算法分析]( images merge_sort.png) 10-9 sort：analysis 归并排序:第三部分 level 1: 2^0="1" calls to merge() with n 2^1 items each, o(2^0 * 2^1)="O(N)" 2: 2^2 o(2^1 2^2)="O(N)" 3: 2^3 o(2^2 2^3)="O(N)" … level(logn): 2^(logn-1)(or 2) 2^logn(or 1) item o(n) there are logn levels and in each level, we perform work,thus overall time complexity o(nlogn).we will later see that an optimal(comparsion-based) sorting algorithm,i.e cannont do better than this.这是一种最佳(基于比较)的排序算法，即我们无法做的比这更好. 10-10 pros cons 优缺点 most good of sort its o(nlogn) performance gurantee, regardless original ordering input.that's it,there no adversary test case can make runs longer for any array elements. 无论输入的原始顺序如何，归并排序中最重要的部分是其o(nlogn)性能保证。就这样，没有任何敌手测试用例可以使归并排序对于任何n个元素数组运行比o(nlogn)更长的时间。 therefore very suitable extremely large number inputs as grows much slower o(n^2) algorithms have discussed earlier.因此，归并排序非常适合排序非常大量的输入，因为o(nlogn)比前面讨论的o(n^2)排序算法增长的慢的多。 also a stable algorithm.discussion: why? 归并排序也是一个稳定的排序算法，讨论：为什么 however,several not-so-good parts sort.first, it actually not easy implement from scratch (but don't to).second,it requires additional storage during merging operation,thus really memory efficient in-place.btw, if you interested what been done address these (classic) parts, read this. 然而，归并排序有几个不太好的部分。首先，从零开始实施起来并不容易(但我们不必这么做)。其次它在归并操作期间需要额外的o(n)的存储，因此不是真正的存储效率，顺便说一句，如果你有兴趣看看为了解决这些经典归并排序不那么好的部分做了什么，可以阅读一下https: en.wikipedia.org wiki merge_sort#variants ##### 基数排序，算法基本思想，算法代码及基本的时间复杂度分析> 基数排序，非比较排序，是桶排序的一种，多关键字排序。可查看基数排序的动画演示：https://visualgo.net/zh/sorting
Radix Sort
    Assumption: If the items to be sorted are integers with large range but of few digits,we can combine Counting Sort idea with Radix Sort to achieve the linear time complexity.假设：如果要排序的项目是大范围但小数位的整数，我们可以将计数排序Counting Sort思想与Radix Sort结合起来，以实现线性时间复杂度

    In Radix Sort, we treat each item to be sorted as a string of w digits(we pad integars that have less than w digits with leading zeros if necessary).在基数排序中，我们将每个项目排序为一个w数字串(如果需要，我们填充小于w数字的前几个零的整数).

    For the least significant(rightmost) digit to the most significant digit(leftmost), we pass through the N items and put them according to the active digit into 10 Queues(one for each digit[0..9]),which is like a modified Counting Sort as this one preserves stability. Then we re-concentrate the groups again for subaequent iteration.对于最低有效位(最右边)到最高有效位(最左边)，我们通过N个项目并将它们按照活动数字放到10个队列中(每个数字[0..9]),就好像一个修改的计数排序，因为这保留了稳定性。然后我们再次重新连接组，以便进行后续迭代。

    Try Radix Sort on the example array above for clearer explantation. 请尝试上面示例数组Radix Sort来了解更清晰的解释。

    Notice that we only perform O(w*(N+k)) iterations. In the example,w=4 and k=10. 请注意，我们只执行了O(w*(N+k))次迭代。在这个例子中，w=4， k10

    create 10 buckets (queues) for each digit (0 to 9) 分别给每个位数(0到9)创建10个桶
    for each digit placing 遍历每个数位
        for each element in list 遍历数列中的每个元素
            move element into respective bucket 将元素移至相应的桶中
        for each bucket, starting from smallest digit 在每个桶中从最小的数位开始
            while bucket is non-empty 当桶不是空的
                restore elemnt to list 将元素恢复至数列中



    例子引入：
        假设我们有N=10个整数，每个整数的值在0到999之间(于是有M=1000个不同的值)。还有可能在线性时间内排序么？

        输入序列： 64，8， 216， 512， 27， 729， 0， 1， 343， 125
        用"次位优先"(Least Significant Digit) 这里的次位就是个位

        基数 10 ，我们就先建立10个桶

        Bucket  0   1   2    3    4    5    6     7    8    9
        Pass 1  0   1  512  343   64  125  216   27    8    729   个位次序排序
        Pass 2  0  512 125        343      64                     十位次序排序
                1  216  27
                8      729

        Pass 3  0  125  216  343       512       729              百位次序排序
                1
                8
            27
            64

        整个次位优先的算法时间复杂度是多少？T = O(P(N+B))

        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">// 基数排序-次位优先</span><br><span class="line"></span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"></span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line"></span><br><span class="line">int GetDigit (int X, int D)</span><br><span class="line">&#123;</span><br><span class="line">    /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line"></span><br><span class="line">    for( i=1; i&lt;=D; i++)&#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LSDRadixSort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    /* 基数排序 - 次位优先 */</span><br><span class="line">    int D, Di, i;</span><br><span class="line">    Bucket B;</span><br><span class="line">    PtrToNode, tmp, p, List = Null;</span><br><span class="line"></span><br><span class="line">    for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">        B[i].head = B[i].tail = NULL;</span><br><span class="line">    for (i=0; i&lt;N; i++)&#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">        tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">        tmp-&gt; key = A[i];</span><br><span class="line">        tmp-&gt; next = List;</span><br><span class="line">        List = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 下面开始排序 */</span><br><span class="line">    for(D=1; D&lt;=MaxDigit; D++)&#123; /*对数据的每一位循环处理*/</span><br><span class="line">        /* 下面是分配过程 */</span><br><span class="line">        p = List;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            Di = GetDigit(p-&gt;key, D); /* 获得当前元素的位数字*/</span><br><span class="line">            /* 从List中摘除*/</span><br><span class="line">            tmp = p; p = p-&gt;next;</span><br><span class="line">            /* 插入B[Di]号桶尾*/</span><br><span class="line">            tmp-&gt;next = NULL;</span><br><span class="line">            if(B[Di].head == NULL)</span><br><span class="line">                B[Di].head = B[Di].tail = tmp;</span><br><span class="line">            else &#123;</span><br><span class="line">                B[Di].tail-&gt;next = tmp;</span><br><span class="line">                B[Di].tail = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 下面是收集的过程*/</span><br><span class="line">        List = NULL;</span><br><span class="line">        for(Di=Radix-1; Di&gt;=0; Di--) &#123; /* 将每个桶的元素顺序收集入List*/</span><br><span class="line">            if(B[Di].head) &#123; /* 如果桶不为空 */</span><br><span class="line">                /* 整桶插入List表头 */</span><br><span class="line">                B[Di].tail-&gt;next = List;</span><br><span class="line">                List = B[Di].head;</span><br><span class="line">                B[Di].head = B[Di].tail = BULL; /* 清空桶 */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 将List倒入A[]并释放空间*/</span><br><span class="line">    for(i=0; i&lt;N; i++)&#123;</span><br><span class="line">        tmp = List;</span><br><span class="line">        List = List -&gt; next;</span><br><span class="line">        A[i] = tmp-&gt;key;</span><br><span class="line">        free(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* 基数排序 - 主位优先 */</span><br><span class="line"></span><br><span class="line">/* 假设元素最多有MaxDigit个关键字， 基数全是同样的Radix */</span><br><span class="line"></span><br><span class="line">#define MaxDigit 4；</span><br><span class="line">#define Radix 10;</span><br><span class="line"></span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line"></span><br><span class="line">int GetDigit (int X,int D)&#123;</span><br><span class="line">    /* 默认次位D=1， 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line"></span><br><span class="line">    for(i=1; i&lt;=D; i++)&#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MSD(ElementType A[], int L, int R, int D)&#123;</span><br><span class="line">    /* 核心递归函数：对A[L]...A[R]的第D位数进行排序 */</span><br><span class="line">    int Di, i, j;</span><br><span class="line">    Bucket B;</span><br><span class="line">    PtrToNode tmp, p, List = NULL;</span><br><span class="line">    if(D==0) return; /* 递归终止条件 */</span><br><span class="line"></span><br><span class="line">    for()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</3k-1>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/22/shujujiegou/算法/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/bekjae.jpg" alt="KOKI HOO">
            
              <p class="site-author-name" itemprop="name">KOKI HOO</p>
              <p class="site-description motion-element" itemprop="description">PEACE&LOVE</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KOKI HOO</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">56k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jD3hLxRDgCSdorrir1RFkW3R-gzGzoHsz", "9AOQX6uUKthSSONK5UO95RGd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
