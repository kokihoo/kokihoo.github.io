<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="NEW LANGUAGE,">










<meta name="description" content="对于计算机来说，二进制在物理器件上来说是最容易实现的（高压电表示1 ， 低压电表示0 ），于是冯 诺依曼结构的计算机都使用了二进制 量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息 变量和类型在程序设计中，变量时一种存储数据的载体，计算机中的变量时实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多类型，除了">
<meta name="keywords" content="NEW LANGUAGE">
<meta property="og:type" content="article">
<meta property="og:title" content="python">
<meta property="og:url" content="http://yoursite.com/2019/08/16/python/index.html">
<meta property="og:site_name" content="KOKI">
<meta property="og:description" content="对于计算机来说，二进制在物理器件上来说是最容易实现的（高压电表示1 ， 低压电表示0 ），于是冯 诺依曼结构的计算机都使用了二进制 量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息 变量和类型在程序设计中，变量时一种存储数据的载体，计算机中的变量时实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多类型，除了">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/Cmn.png">
<meta property="og:updated_time" content="2019-09-25T02:26:46.921Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python">
<meta name="twitter:description" content="对于计算机来说，二进制在物理器件上来说是最容易实现的（高压电表示1 ， 低压电表示0 ），于是冯 诺依曼结构的计算机都使用了二进制 量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息 变量和类型在程序设计中，变量时一种存储数据的载体，计算机中的变量时实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多类型，除了">
<meta name="twitter:image" content="http://yoursite.com/images/Cmn.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/16/python/">





  <title>python | KOKI</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a5ecac7771fad0fda5191a255b9e3f5c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KOKI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/16/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">python</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T15:35:10+08:00">
                2019-08-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-25T10:26:46+08:00">
                2019-09-25
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/16/python/" class="leancloud_visitors" data-flag-title="python">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  64
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对于计算机来说，二进制在物理器件上来说是最容易实现的（高压电表示1 ， 低压电表示0 ），于是冯 诺依曼结构的计算机都使用了二进制</p>
<p>量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息</p>
<h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><p>在程序设计中，变量时一种存储数据的载体，计算机中的变量时实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多类型，除了数值外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型，Python中的数据类型很多，而且也允许我们自定义新的数据类型,以下为几种常见的数据类型。</p>
<ul>
<li>整型： Python中可以处理任意大小的整数(Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此Python3.x中整数就只有int这一种了)，而且支持二进制、八进制、十进制、和十六进制的表示法</li>
<li>浮点型： 浮点数也就是小数，之所以称为浮点数，也是因为科学计数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法(123.456)之外还支持科学计数法(如1.2346e2)</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如’hello’和“hello”,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式(用三个单引号或三个双引号开头，是三个单引号三个双引号结尾)</li>
<li>布尔型：布尔值只有True,False两种值，在Python中，可以直接用True、False表示布尔值(请注意大小写)，也可以通过布尔运算计算出来（例如3&lt;5 会产生布尔值True，而 2==1 会产生布尔值False）。</li>
<li>复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部i换成了j</li>
</ul>
<p>数字：int和float，Python要支持其他类型的数字，例如Decimal或者Fraction。Python也内置对复数的支持，使用后缀j和J就可以表示虚数的部分（例：3+5j）<br>字符串：</p>
<ul>
<li>可以使用单引号(‘……’)，双引号(“……”)</li>
<li>反斜杠\可以用来转义，如果不希望前置\的字符转义成特殊字符，可以使用原始字符串方式，在引号前添加r即可</li>
<li>字符串字面值可以跨行连续输入，一种方式是用三重引号：”””……”””或’’’……’’’.字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个\即可。</li>
<li>字符串可以用+进行连接（粘到一起），也可以用*进行重复</li>
<li>相邻的两个或多个字符串字面值(引号引起来的字符)将会自动连接到一起，把很长的字符串拆开分别输入的时候尤其有用：只能对两个字面值这样操作，变量或者表达式不行，如果想连接变量，或者连接变量和字面值，可以用+号</li>
<li>字符串是可以被索引(下标访问)的，第一个字符索引是0，单个字符并没有特殊的类型，只是一个长度为一的字符串：</li>
<li>索引也可以是负数，这种会从右边开始数，-0和0是一样的，所以负数索引从-1开始</li>
<li>除了索引，字符春还支持切片，索引可以得到单个字符，而切片可以获取子字符串</li>
</ul>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>对于每个变量我们需要给它取一个名字，在Python中，变量命名需要遵循以下这些必须遵守的硬性规则：</p>
<p>硬性规则：</p>
<ul>
<li>变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头</li>
<li>大小写敏感（大写的A和小写的a是两个不同的变量）</li>
<li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突</li>
</ul>
<p>PEP 8 要求;</p>
<ul>
<li>用小写字母拼写，多个单词用下划线连接</li>
<li>受保护的实例属性用单个下划线开头</li>
<li>私有的实例属性用两个下划线开头</li>
</ul>
<p>作为一个专业的程序员，给变量事实上是所有的标识符命名时做到见名知意也是非常重要的。</p>
<h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><p>使用input()函数获取键盘输入<br>使用int()进行类型转换<br>用占位符格式化输出的字符串<br>用type()检查变量的类型<br>在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是我们后面要讲的创建对象的构造方法）</p>
<ul>
<li>int(): 将一个数值或字符串转换成整数，可以指定进制</li>
<li>float(): 讲一个字符串转换成浮点数</li>
<li>str(): 将指定的对象转换成字符串形式，可以指定编码</li>
<li>chr(): 将整数转换成改编码对应的字符串(一个字符)</li>
<li>ord(): 将字符串（一个字符）转换成对应的编码(整数)</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[] [:]</td>
<td>下标 切片</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
</tr>
<tr>
<td>~ + -</td>
<td>按位取反,正负号</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘 除 模 整除</td>
</tr>
<tr>
<td>+ -</td>
<td>加 减</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>右移 左移</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>^</td>
<td></td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>小于等于 小于 大于 大于等于</td>
</tr>
<tr>
<td>== !=</td>
<td>等于， 不等于</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>in not in</td>
<td>成分运算符</td>
</tr>
<tr>
<td>not or and</td>
<td>逻辑运算符</td>
</tr>
<tr>
<td>= += -= <em>= /= %= //= *</em>= &amp;= `</td>
<td>= ^= &gt;&gt;= &lt;&lt;= `</td>
</tr>
</tbody></table>
<p>== 说实话表格的最后一个我没看懂 = = </p>
<blockquote>
<p>说明：在实际开发中，如果搞不懂运算符的优先级，可以使用括号来确保运算的执行顺序</p>
</blockquote>
<p>和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于一个执行的整体。</p>
<h4 id="构造程序逻辑"><a href="#构造程序逻辑" class="headerlink" title="构造程序逻辑"></a>构造程序逻辑</h4><p>分支和循环结构会帮助我们将程序中逻辑建立起来，将来我们的程序无论简单复杂，都是由顺序结构、分支结构、循环结构构成的</p>
<h4 id="函数和模块的使用"><a href="#函数和模块的使用" class="headerlink" title="函数和模块的使用"></a>函数和模块的使用</h4><p>写出高质量的代码首先要解决的就是重复代码的问题。</p>
<p>X1+X2+X3+X4 = 8<br>这个问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。</p>
<p><img src="/images/Cmn.png" alt="求"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入M和N的计算C(M,N)</span><br><span class="line"></span><br><span class="line">m = int(input(&apos;m = &apos;))</span><br><span class="line">n = int(input(&apos;m = &apos;))</span><br><span class="line">fm = 1</span><br><span class="line">for num in range(1, m+1):</span><br><span class="line">    fm* = num //求m的阶乘</span><br><span class="line"></span><br><span class="line">fn = 1</span><br><span class="line">for num in range(1, n+1):</span><br><span class="line">    fn *= num // 求n的阶乘</span><br><span class="line"></span><br><span class="line">fmn = 1</span><br><span class="line">for num in range(1, m-n+1):</span><br><span class="line">    fmn *= num // 求m-n的阶乘</span><br><span class="line"></span><br><span class="line">print(fm//fn/fmn)</span><br></pre></td></tr></table></figure>

<p>定义函数<br>在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上的函数的因变量</p>
<p>重构之后的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def factorial(num):</span><br><span class="line">    求阶乘</span><br><span class="line">    ：param num：非负整数</span><br><span class="line">    ：return：num 的阶乘</span><br><span class="line"></span><br><span class="line">    result = 1</span><br><span class="line">    for n range(1, num+1):</span><br><span class="line">        result *= n</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">    m = int(input(&apos;m= &apos;))</span><br><span class="line">    n = int(input(&apos;n= &apos;))</span><br><span class="line"></span><br><span class="line">    # 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数</span><br><span class="line"></span><br><span class="line">    print(factrial(m)//factrial(n)//factrial(m-n))</span><br></pre></td></tr></table></figure>

<p>说明：python的math模块中其实已经有一个factorial函数，事实上要计算阶乘可以直接会用这个现成的函数而不用自已定义。</p>
<p>函数的参数</p>
<p>函数是绝大多数编程语言中都支持的一个代码的构建块，但是python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是python对函数参数的处理，在python中，函数的参数可以有默认值，也支持可变参数，所以Python并不需要像其他语言一直支持函数的重载，因为我们在定义一个函数的时候可以让它有不同的使用方式</p>
<p><strong>重载</strong>: 就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数或者方法之间，相互称之为重载函数或方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from random import radiant</span><br><span class="line"></span><br><span class="line">def roll_dice(n = 2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    摇筛子</span><br><span class="line"></span><br><span class="line">    :param n :筛子的个数</span><br><span class="line">    :return: n颗筛子点数之和</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    total = 0</span><br><span class="line">    for _ in range(n):</span><br><span class="line">        total += randiant(1, 6)</span><br><span class="line">    return total</span><br><span class="line"></span><br><span class="line">def add(a=0, b=0, c=0):</span><br><span class="line">    return a+b+c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果没有指定参数那么使用默认值摇两颗筛子 n=2</span><br><span class="line">print(roll_dice())</span><br><span class="line"></span><br><span class="line">#摇三颗筛子</span><br><span class="line">print(roll_dice(3))</span><br><span class="line">print(add())</span><br><span class="line">print(add(1))</span><br><span class="line">print(add(1,2))</span><br><span class="line">print(add(1,2,3))</span><br><span class="line"></span><br><span class="line">#传递参数时可以不按照设定的顺序进行传递</span><br><span class="line">print(add(c=50,a=100,b=200))</span><br></pre></td></tr></table></figure>

<p>我们在给上面两个函数的参数都设定了默认值，这也就意味着如果在调用的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。</p>
<p>其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定的，我们作为函数的设计对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下：</p>
<h1 id="在参数名前面的-表示args是一个可变参数"><a href="#在参数名前面的-表示args是一个可变参数" class="headerlink" title="在参数名前面的*表示args是一个可变参数"></a>在参数名前面的*表示args是一个可变参数</h1><h1 id="即在调用add函数时可以传入0个或多个参数"><a href="#即在调用add函数时可以传入0个或多个参数" class="headerlink" title="即在调用add函数时可以传入0个或多个参数"></a>即在调用add函数时可以传入0个或多个参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def add(*args):</span><br><span class="line">    total = 0</span><br><span class="line">    for val in args:</span><br><span class="line">        total += val</span><br><span class="line">    return total</span><br><span class="line"></span><br><span class="line">print(add())</span><br><span class="line">print(add(1))</span><br><span class="line">print(add(1, 2))</span><br><span class="line">print(add(1, 2, 3))</span><br><span class="line">print(add(1, 3, 5, 7, 9))</span><br></pre></td></tr></table></figure>

<p>用模块管理函数</p>
<p>对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么就意味两个函数同名函数实际上只有一个是存在的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&apos;hello, world!&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&apos;goodbye, world!&apos;)</span><br></pre></td></tr></table></figure>

<p>当然上面的情况很容易就能避免，但是如果项目是由多人呢协作进行团队开发的时候，团队中可能有多个程序都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案很简单，Python中每个文件就代表了衣蛾模块module，我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。</p>
<p>module1.py</p>
<p>def foo():<br>    print(‘hello world!’)</p>
<p>module2.py</p>
<p>def foo():<br>    print(‘goodbye, world’)</p>
<p>test.py<br>    from module1 import foo<br>    # 输出hello, world！<br>    foo()<br><br>    from module2 import foo<br>    #输出”goodbye world!”<br>    foo()</p>
<p>也可以按照如下所示的方式来区分到底要使用哪一个foo函数</p>
<p>test.py<br>import module1 as m1<br>import module2 as m2</p>
<p>m1.foo()<br>m2.foo()</p>
<p>但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。</p>
<p>test.py</p>
<p>from module1 import foo<br>from module2 import foo</p>
<h1 id="输出goodbye，world！"><a href="#输出goodbye，world！" class="headerlink" title="输出goodbye，world！"></a>输出goodbye，world！</h1><p>foo()</p>
<p>test.py</p>
<p>from module2 import foo<br>from module1 import foo</p>
<h1 id="输出hello-world"><a href="#输出hello-world" class="headerlink" title="输出hello world"></a>输出hello world</h1><p>foo()</p>
<p>需要说明的是如果我们导入的模块除了定义函数之外还可以有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“_main_”</p>
<p>module3.py</p>
<p>def foo():<br>    pass</p>
<p>def bar():<br>    pass</p>
<h1 id="name-是Python中一个隐含的变量它代表了模块的名字"><a href="#name-是Python中一个隐含的变量它代表了模块的名字" class="headerlink" title="_name_是Python中一个隐含的变量它代表了模块的名字"></a>_name_是Python中一个隐含的变量它代表了模块的名字</h1><h1 id="只有被Python解释器执行的模块的名字才是main"><a href="#只有被Python解释器执行的模块的名字才是main" class="headerlink" title="只有被Python解释器执行的模块的名字才是main"></a>只有被Python解释器执行的模块的名字才是<em>main</em></h1><p>if <em>_name == ‘_main</em>‘:<br>    print(‘call foo()’)<br>    foo()<br>    print(‘call bar()’)<br>    bar()</p>
<p>test.py</p>
<pre><code>import module3

# 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是_main_</code></pre><p>当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们要定义和使用函数的一个非常重要的原因</p>
<h5 id="Python中有关变量作用域的问题"><a href="#Python中有关变量作用域的问题" class="headerlink" title="Python中有关变量作用域的问题"></a>Python中有关变量作用域的问题</h5><p>def foo():<br>    b = ‘Hello’</p>
<pre><code>def bar(): #Python中可以在函数内部再定义函数
    c = True
    print(a)
    print(b)
    print(c)

bar()
# print(c) NameError:name c is not defined</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    a = 100<br>    # print(b) #NameError: name ‘b’ is not defined<br>    foo()</p>
<p>上面的代码能够顺利的执行并且打印出100和‘Hello’，但我们注意到了在bar的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量(global variable),属于全局作用域，因为它没有定义在任何一个函数中，在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它。但是对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的，bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的，事实上，Python查找一个变量会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码已经看到了，所谓的内置作用域就是Python内置的那些隐含标识符min 、len等都属于内置作用域</p>
<p>下面的代码，希望通过函数调用修改全局变量a的值，但是实际上下面的代码是做不到的。<br>def foo():<br>    a = 200<br>    print(a)  # 200</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    a = 100<br>    foo()<br>    print(a) # 100</p>
<p>在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因为foo函数不在搜索全局作用域的中a，如果我们希望在foo函数中修改全局作用域中的a，代码如下所示：<br>    def foo():<br>        global a<br>        a = 200<br>        print(a)  # 200</p>
<pre><code>if __name__ == &apos;__main__&apos;:
    a = 100
    foo()
    print(a) # 200</code></pre><p>我们在使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域。</p>
<p>在实际开发中，我们应该应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能会导致对象占用内存长时间无法被垃圾回收。事实上减少对全局变量的使用，也是减低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其函数调用结束后依然可以访问，这时候就需要使用闭包。</p>
<p>我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。</p>
<p>def mian():<br>    # Todo: Add your code here<br>    # 局部作用域<br>    pass</p>
<p>if <strong>name</strong> = ‘<strong>main</strong>‘<br>    #全局作用域<br>    main()</p>
<h4 id="字符串和常用数据结构"><a href="#字符串和常用数据结构" class="headerlink" title="字符串和常用数据结构"></a>字符串和常用数据结构</h4><h5 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h5><p>今天的计算机更多的时间需要处理的数据可能都是以文本的方式存在的，如果我们希望通过Python程序操作这些文本信息，就必须要先了解字符串类型以及与它相关的知识。</p>
<p>所谓字符串，就是由零个或多个字符组成的有限序列，一般记为s = a1a2a3……an(0&lt;=n&lt;=∞)</p>
<p>我们可以通过下面的代码来了解字符串的使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    str1 = &apos;hello world!&apos;</span><br><span class="line">    # 通过len函数计算字符串的长度</span><br><span class="line">    print(len(str1))  # 13</span><br><span class="line">    # 获得字符串首字母大写的拷贝</span><br><span class="line">    print(str1.capitalize()) # Hello, world!</span><br><span class="line">    # 获得字符串变大写后的拷贝</span><br><span class="line">    print(str1.upper())  # HELLO, WORLD!</span><br><span class="line">    # 从字符串中查找子串所在位置</span><br><span class="line">    print(str1.find(&apos;or)) # 8</span><br><span class="line">    print(str1.find(&apos;shit&apos;)) # -1</span><br><span class="line">    # 与find类似但找不到子串时会引发异常</span><br><span class="line">    # print(str1.index(&apos;or&apos;))</span><br><span class="line">    # print(str1.index(&apos;shit&apos;))</span><br><span class="line">    # 检查字符串是否以指定的字符串开头</span><br><span class="line">    print(str1.startwith(&apos;He&apos;))  # False</span><br><span class="line">    print(str1.startwith(&apos;hel&apos;)) # True</span><br><span class="line">    # 检查字符串是否以指定的字符串结尾</span><br><span class="line">    print(str1.endswith(&apos;!&apos;)) # True</span><br><span class="line">    # 将字符串以指定的宽度居中并在两侧填充指定的字符</span><br><span class="line">    print(str1.center(50, &apos;*&apos;))</span><br><span class="line">    # 将字符串以指定的宽度靠右并在左侧填充指定的字符</span><br><span class="line">    print(str1.rjust(50, &apos;*&apos;))</span><br><span class="line">    str2 = &apos;abc123456&apos;</span><br><span class="line">    # 从字符串中取出指定位置的字符(下标计算)</span><br><span class="line">    print(str2[2])  # c</span><br><span class="line">    # 字符串切片(从指定的开始索引到指定的结束索引)</span><br><span class="line">    print(str2[2:5]) # c12</span><br><span class="line">    print(str2[2:])  # c123456</span><br><span class="line">    print(str2[2::2]) # c246</span><br><span class="line">    print(str2[::2]) # ac246</span><br><span class="line">    print(str2[::-1]) # 654321cba</span><br><span class="line">    print(str2[-3:-1]) # 45</span><br><span class="line">    # 检查字符串是否由数字构成</span><br><span class="line">    print(str2.isdigit()) # False</span><br><span class="line">    # 检查字符串是否以字母构成</span><br><span class="line">    print(str2.isalpha) # False</span><br><span class="line">    # 检查字符串是否是以数字和字母构成</span><br><span class="line">    print(str2.isalnum()) # True</span><br><span class="line">    str3 = &apos;  jackfrued@126.com&apos;</span><br><span class="line">    print(str3)</span><br><span class="line">    # 获得字符串修剪左右两侧空格的拷贝</span><br><span class="line">    print(str3.strip())</span><br><span class="line"></span><br><span class="line">    if __name__ == &apos;__main__&apos;:</span><br><span class="line">        main()</span><br><span class="line"></span><br><span class="line">    除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数的时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。</span><br><span class="line"></span><br><span class="line">##### 使用列表</span><br><span class="line">    下面的列表演示了如何定义列表，使用下标访问列表元素以及添加和删除元素的操作</span><br><span class="line">    def main()</span><br><span class="line">        list1 = [1,3,5,7,100]</span><br><span class="line">        print(list1)</span><br><span class="line">        list2 = [&apos;hello&apos;] * 5</span><br><span class="line">        print(list2)</span><br><span class="line">        # 计算列表长度元素个数</span><br><span class="line">        print(len(list1))</span><br><span class="line">        # 下标(索引)运算</span><br><span class="line">        print(list1[0])</span><br><span class="line">        print(list1[4])</span><br><span class="line">        # print(list1[5]) # IndexError: list index out of range</span><br><span class="line">        print(list1[-1])</span><br><span class="line">        print(list1[-3])</span><br><span class="line">        list1[2] = 300</span><br><span class="line">        print(list1)</span><br><span class="line">        # 添加元素</span><br><span class="line">        list1.append(200)</span><br><span class="line">        list1.insert(1, 400)</span><br><span class="line">        list1 += [1000, 2000]</span><br><span class="line">        print(list1)</span><br><span class="line">        print(len(list1))</span><br><span class="line">        # 删除元素</span><br><span class="line">        list1.remove(3)</span><br><span class="line">        if 1234 in list1:</span><br><span class="line">            list1.remove(1234)</span><br><span class="line">        del list1[0]</span><br><span class="line">        print(list1)</span><br><span class="line">        # 清空列表元素</span><br><span class="line">        list1.clear()</span><br><span class="line">        print(list1)</span><br><span class="line"></span><br><span class="line">        if __name__ == &apos;__main__&apos;</span><br><span class="line">            main()</span><br></pre></td></tr></table></figure>

<p>和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示：<br>def main():<br>    fruits = [‘grape’, ‘apple’, ‘strawberry’, ‘waxberry’]<br>    fruits += [‘pitaya’, ‘pear’, ‘mango’]<br>    # 循环遍历列表元素<br>    for fruit in fruits:<br>        print(fruit.title(), end=’ ‘)<br>    print()<br>    # 列表切片<br>    fruits2 = fruits[1:4]<br>    print(fruits2)<br>    # fruits3 = fruits # 没有复制列表只是创建了新的引用<br>    # 可以通过完整切片操作来复制列表<br>    fruits3 = fruits[:]<br>    print(fruits3)<br>    fruits4 = fruits[-3:-1]<br>    print(fruits4)<br>    # 可以通过反向切片操作来获得倒转后的列表的拷贝<br>    fruits5 = fruits[::-1]<br>    print(fruits5)</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p>
<p>下面的代码实现了对列表的排序操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    list1 = [&apos;orange&apos;, &apos;apple&apos;, &apos;zoo&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;]</span><br><span class="line">    list2 = sorted(list1)</span><br><span class="line">    # sorted函数返回列表排序后的拷贝不会修改传入的列表</span><br><span class="line">    # 函数的设计就应该像sorted函数一样尽可能不产生副作用</span><br><span class="line">    list3 = sorted(list1, reverse=True)</span><br><span class="line">    # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序</span><br><span class="line">    list4 = sorted(list1, key=len)</span><br><span class="line">    print(list1) # [&apos;orange&apos;, &apos;apple&apos;, &apos;zoo&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;]</span><br><span class="line">    print(list2) # [&apos;apple&apos;, &apos;blueberry&apos;, &apos;internationalization&apos;, &apos;orange&apos;, &apos;zoo&apos;]</span><br><span class="line">    print(list3) # [&apos;zoo&apos;, &apos;orange&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;, &apos;apple&apos;]</span><br><span class="line">    print(list4) # [&apos;zoo&apos;, &apos;apple&apos;, &apos;orange&apos;, &apos;blueberry&apos;, &apos;internationalization&apos;]</span><br><span class="line">    # 给列表对象发出排序消息直接在列表对象上进行排序</span><br><span class="line">    list1.sort(reverse=True)</span><br><span class="line">    print(list1) # [&apos;zoo&apos;, &apos;orange&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;, &apos;apple&apos;]</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__mian__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>还可以使用列表的生成式语法来创建列表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    f = [x for x in range(1, 10)] </span><br><span class="line">    print(f) # [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">    f = [x + y for x in &apos;ABCD&apos; for y in &apos;1234567&apos;]</span><br><span class="line">    print(f) </span><br><span class="line">    # [&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;A4&apos;, &apos;A5&apos;, &apos;A6&apos;, &apos;A7&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;B4&apos;, &apos;B5&apos;, &apos;B6&apos;, &apos;B7&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;, &apos;C4&apos;, &apos;C5&apos;, &apos;C6&apos;, &apos;C7&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;, &apos;D4&apos;, &apos;D5&apos;, &apos;D6&apos;, &apos;D7&apos;]</span><br><span class="line">    # 用列表的生成表达式语法创建列表容器</span><br><span class="line">    # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间</span><br><span class="line">    f = [x ** 2 for x in range(1, 1000)]</span><br><span class="line">    print(sys.getsizeof(f)) # 查看对象占用内存的字节数</span><br><span class="line">    # 9024</span><br><span class="line">    print(f)</span><br><span class="line">    # [1,4,9,16,25……,998001]</span><br><span class="line">    # 请注意下面的代码创建的不是一个列表而是一个生成器对象</span><br><span class="line">    # 通过生成器可以获取到数据但它不占用额外的空间存储数据</span><br><span class="line">    # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)</span><br><span class="line">    f = (x ** 2 for x in range(1, 1000))</span><br><span class="line">    print(sys.getsizeof(f)) # 相比生成式生成器不占存储数据的空间</span><br><span class="line">    # 120</span><br><span class="line">    print(f)</span><br><span class="line">    # 1</span><br><span class="line">    # 4</span><br><span class="line">    # ...</span><br><span class="line">    # 998001</span><br><span class="line">    for val in f:</span><br><span class="line">        print(val)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现衣蛾生成斐波那契数列的生成器。所谓的斐波那契数列可以通过下面的递归的方法来进行定义：<br>F0 = 0；<br>F1 = 1；<br>Fn = Fn-1 + Fn-2(n &gt;= 2)</p>
<h5 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h5><p>Python的元组与列表类似，不同之处在于元组的元素不能修改，在前面的d代码中我们已经不止一次使用过元组了，顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    # 定义元组</span><br><span class="line">    t = (&apos;张三&apos;, &apos;24&apos;, True, &apos;上海&apos;)</span><br><span class="line">    print(t)</span><br><span class="line">    # 获取元组中的元素</span><br><span class="line">    print(t[0])</span><br><span class="line">    print(t[3])</span><br><span class="line">    # 遍历元组中的值</span><br><span class="line">    for member in t:</span><br><span class="line">        print(member)</span><br><span class="line">    # 重新给元组赋值</span><br><span class="line">    # t[0] = &apos;王大锤&apos; # typeError</span><br><span class="line">    # 变量t重新引用了新的元组原来的元组将被辣鸡回收</span><br><span class="line">    t = (&apos;王大锤&apos;, 20, True, &apos;云南昆明&apos;)</span><br><span class="line">    print(t)</span><br><span class="line">    # 将元组转换成列表</span><br><span class="line">    person = list(t)</span><br><span class="line">    print(person)</span><br><span class="line">    # 列表是可以修改它的元素</span><br><span class="line">    person[0] = &apos;李四&apos;</span><br><span class="line">    person[1] = &apos;25&apos;</span><br><span class="line">    print(person)</span><br><span class="line"></span><br><span class="line">    # 将列表转换成元组</span><br><span class="line">    fruits_list = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;]</span><br><span class="line">    fruits_tuple = tuple(fruits_list)</span><br><span class="line">    print(fruits_tuple)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？<br>1、元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境中可能会更喜欢使用的是那些不变对象(一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护，另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销，一个不变对象可以方便的被共享访问)。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。<br>2、元组在创建时间和占用空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间</p>
<h5 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h5><p>Python中的集合跟数学上的集合是一致的，<strong>不允许有重复元素</strong>，而且可以进行交集、并集、差集等运算</p>
<p>##<br>Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以两个下划线作为开头，</p>
<p>Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对他们的访问，事实上你知道更换名字的规则仍然可以访问到他们，所以更多的时候它是一种暗示或隐喻</p>
<h1 id="面向对象的支柱"><a href="#面向对象的支柱" class="headerlink" title="面向对象的支柱"></a>面向对象的支柱</h1><p>面向对象有三大支柱：封装 继承 多态。<br>封装：隐藏一切可以隐藏的实现细节，只向外界暴露提供简单的变成接口。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的视图）。而不需要知道方法内部实现细节</p>
<p>@property装饰器<br>之前我们讨论过python中的属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将<br>属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter访问器，和setter修改器方法进行对应的操作。如果要做到这点，就可以考虑使用<br>@property包装getter和setter方法，使得对属性的访问即安全又方便。</p>
<p>class Person(object):<br>    def <strong>init</strong>(self, name, age):<br>        self._name = name<br>        self._age = age</p>
<pre><code># 访问器 - getter方法
@property
def name(self):
    return self._name

# 访问器 - getter方法
@property
def age(self):
    return self._age

# 修改器 - setter方法
@age.setter
def age(self, age):
    self._age = age

def play(self):
    if self._age &lt;= 16:
        print(&apos;%s正在玩飞行棋&apos; % self._name)
    else:
        print(&apos;%s正在斗地主&apos; % self._name)</code></pre><p>def main():<br>    person = Person(‘王法’, 12)<br>    person.play()<br>    person.age() = 22<br>    person.paly()<br>    # person.name = ‘sss’ Error: can’t set attribute</p>
<p>if <strong>name</strong> == ‘<strong>mian</strong>‘:<br>    main()</p>
<h5 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="slots 魔法"></a><strong>slots</strong> 魔法</h5><p>Python是一门动态语言，动态语言允许我们在程序运行时给对象绑定新的属性和方法，当然也可以对已经绑定的属性和方法进行解绑定，但是如果我们需要限定自定义类型<br>的对象只能绑定某些属性，可以通过类中定义<strong>slots</strong>变量来进行限定。需要注意的是<strong>slots</strong>的限定只对当前类的对象生效，对子类并不起任何作用。<br>class Person(object)<br>    # 限定Person对象只能绑定<em>name,<em>age和 _gender属性<br>    __slots</em></em> = (‘<em>name’, ‘<em>age’, ‘_gender’)<br><br>    def __init</em></em>(self, name, age):<br>        self._name = name<br>        self._age = age<br><br>    @property<br>    def name(self):<br>        return self._name<br><br>    @property<br>    def age(self):<br>        return self._age<br><br>    @age.setter<br>    def age(self, age):<br>        self._age = age<br><br>    def play(self):<br>        if self._age &lt;= 16:<br>            print(‘%s正在玩飞行棋’ % self._name)<br>        else:<br>            print(‘%s正在斗地主’ % self._name)</p>
<p>def main():<br>    person = Person(‘王大锤’, 22)<br>    person.play()<br>    person._gender = ‘男’</p>
<h5 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h5><p>之前我们在类中定音的方法都是对象方法，也就是说这些方法都是发送给对象的消息，实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义<br>一个三角形类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边未必能构造出三角形对象，因此我们可以先写一个方法<br>来验证三条边是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来， 因为不知道三条边能不能构成三角形，所以这个方法是属于三角形类而不属于三角形对象的。我们可以使用静态方法来解决这类问题。</p>
<p>和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象，类本身也是一个对象，有的地方也称之为类的元数据对象，通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象</p>
<h5 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h5><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系</p>
<ul>
<li>is-a关系也叫继承或泛化，比如学生和人的关系。手机和电子产品的关系都属于继承关系</li>
<li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系，关联关系如果是整体和部分的关联，那么我们称为聚合关系，如果整体进一步负责了部分的生命周期，整体和部分是不可分割的，同时同在也同时消亡，那么这种就是最强的关联关系，我们称之为合成关系</li>
<li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中的参数使用到了汽车，那么司机和汽车的关系就是依赖关系</li>
</ul>
<p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段<br>复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常生活中都会使用到的技术手段</p>
<p>继承和多态<br>可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写，提供继承信息的我们称之为父类，也叫超类或基类，得到继承信息的我们称为子类，也叫派生类或衍生类，子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称为里氏替换原则</p>
<p>‘’’<br>继承<br>‘’’</p>
<p>class Person(object):<br>    “”” 人 “””<br>    def <strong>init</strong>(self, name, age)；<br>        self._name = name<br>        self._age = age</p>
<pre><code>@property
def name(self):
    return self._name

@property
def age(self):
    return self._age

@age.setter
def age(self, age):
    self._age = age

def play(self):
    print(&apos;%s正在愉快的玩耍&apos; % self._name)

def watch_av(self):
    if self._age &gt;= 18:
        print(&apos;%s正在看枪战&apos; % self._name)
    else:
        print(&apos;%s只能观看熊出没&apos; % self._name)</code></pre><p>class Student(Person):<br>    “”””学生”””<br>    def <strong>init</strong>(self, name, age, grade):<br>        super().<strong>init</strong>(name, age)<br>        self._grade = grade</p>
<pre><code>@property
def grade(self):
    return self._grade

@grade.setter
def grade(self, grade):
    self._grade = grade

def study(self, course):
    print(&apos;%s的%s正在学习%s。&apos; %(self._grade, self._name, course))</code></pre><p>class Teacher(Person):<br>    “”””老师”””</p>
<pre><code>def __init__(self, name, age, title):
    super().__init__(name, age)
    self._title = title

@property
def title(self):
    return self._title

@title.setter
def title(self, title):
    self._title = title

def teach(self, course):
    print(&apos;%s%s正在讲%s&apos; % (self._name, self._title, course))</code></pre><p>def mian():<br>    stu = Student(‘王大锤’, 15, ‘初三’)<br>    stu.study(‘数学’)<br>    stu.watch_av()<br>    t = Teacher(‘李四’, 24, ‘教授’)<br>    t.teach(‘Python程序设计’)<br>    t.watch_av()</p>
<p>if name == ‘<strong>main</strong>‘:<br>    main()    </p>
<p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写override。通过方法重写我们可以让父类的同一个行为在不同的子类中有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态poly-morphism</p>
<p>from abc import ABCMeta, abstractmethod</p>
<p>class Pet(object, metaclass=ABCMeta):<br>    “””宠物”””<br>    def <strong>init</strong>(self, nickname):<br>        self._nickname = nickname</p>
<pre><code>@abstractmethod
def make_voice(self):
    &quot;&quot;&quot;&quot;发出声音&quot;&quot;&quot;
    pass</code></pre><p>calss Dog(Pet):<br>    “””狗”””</p>
<pre><code>def make_voice(self):
    print(&apos;%s: 汪汪汪……&apos; % self._nickname)</code></pre><p>class Cat(Pet):<br>    “””猫”””</p>
<pre><code>def make_voice(self):
    print(&apos;%s: 喵……喵&apos; % self._nickname)</code></pre><p>def main():<br>    pets = [Dog(‘旺福’), Cat(‘凯蒂’), Dog(‘大黄’)]<br>    for pet in pets:<br>        pet.make_voice()</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p>
<p>在上面的代码上，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它，Python从语法层面并没有像Java和C#那样<br>提供对抽象类的支持，但是我们通过abc模块额ABCMeta元类和abstractmethod包装器来达到抽象类的效果如果一个类中存在抽象方法那么这个类就不能被实例化（创建对象），上面的代码中<br>Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事）</p>
<p>图形用户界面的游戏开发<br>基于tkinter模块的GUI</p>
<p>GUI是图形用户界面的缩写，图形化的用户界面面对使用过计算机的人来说并不陌生，Python默认的GUI开发模块时tkinter（在Python 3以前的版本中名为Tkinter），提供了跨平台的GUI控件</p>
<p>基本上使用tkinter开发GUI应用需要以下5个步骤:<br>    1、导入tkinter模块中我们需要的东西<br>    2、创建一个顶层窗口对象并用它来承载整个GUI应用<br>    3、在顶层窗口对象上添加GUI组件<br>    4、通过代码将这些GUI组件的功能组织起来<br>    5、进入主事件循环 main loop</p>
<p>需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标，键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环<br>一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer开发者提供空间的大小和摆放位置、<br>Packer自动将控件填充到合适的位置和Grid基于网格坐标来摆放控件</p>
<p>使用Pygame进行游戏开发<br>Pygame是一个开源的Python模块，专门用于多媒体应用如电子游戏的开发，其中包含对图像、声音、视频、事件、碰撞等的支持，Pygame建立在SDL的基础上，SDL是一套跨平台的多媒体开发库，用C<br>语言实现，被广泛应用于游戏、模拟器、播放器等的开发，而Pygame让游戏开发者不在被底层语言束缚，可以更多的关注游戏的功能和逻辑。</p>
<p>体会如何使用面向对象程序设计，学会用这种编程思想去解决现实中的问题</p>
<p>在窗口中绘图</p>
<p>可以通过pygame中draw模块的函数在窗口上绘图，可以绘制的图形包括：线条 矩形 多边形 圆 椭圆 圆弧 等，需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点(0, 0)<br>,向右是x轴的正向，向下是y轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是像素。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将将图片放大若干倍<br>就可以看到这些点，pygame中表示颜色用的是色光三原色表示法，即通过一个元组或列表来指定颜色的RGB值，每个值都在0~255之间，因为是每个原色都用一个8位bit的值来表示<br>三种颜色相当于一共由24位构成，这也就是常说的24位颜色表示法</p>
<p>加载图像</p>
<p>如果需要直接加载图像到窗口上，可以使用pygame中image模块的函数来加载图像，再通过之前获得的窗口对象的blit方法渲染图像，代码如下所示：</p>
<p>实现动画效果</p>
<p>就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果，如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在<br>循环中修改小球的位置在刷新整个窗口即可</p>
<p>碰撞检测</p>
<p>通常一个游戏中会有很多对象出现，而这些对象之间的碰撞在所难免，比如炮弹击中了飞机，箱子撞击了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame<br>的sprite动画精灵，模块就提供了对碰撞检测的支持，这里我们暂不介绍sprite模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查<br>球心距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球</p>
<p>事件处理</p>
<p>可以在事件循环中对鼠标事件进行处理，通过事件对象的type属性可以判定事件类型，再通过pos属性就可以获得鼠标点击的位置，如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似</p>
<p>刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程知识后，用一个后台线程来处理这些是更好的选择，希望获得更好的用户体验，可以在游戏红加入背景音乐<br>以及在球与球碰撞时播放音效，利用pygame的mixer和music模块，我们可以很容易做到这一点，3D游戏，pygame就显得力不从心了，对3D游戏开发如果有兴趣的读者可以看看Panda3D</p>
<p>pygame官方网站：<a href="https://www.pygame.org/news" target="_blank" rel="noopener">https://www.pygame.org/news</a><br>Panda3D官方网站：<a href="https://www.panda3d.org/" target="_blank" rel="noopener">https://www.panda3d.org/</a></p>
<h6 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h6><p>实际开发中尝尝会遇到对数据进行持久化操作的场景，而实现数据持久化最直接简单的方式就是将数据保存在文件中。说到文件这个词，要先讨论下文件系统</p>
<p>在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名，操作模式，编码信息等来获得操作文件的对象，接下来就可以对文件进行<br>读写操作了，这里说的操作模式是指要打开什么的文件，字符文件还是二进制文件以及做什么样的操作，读、写还是追加，具体如下：</p>
<p>操作模式 | 具体含义<br>        | </p>
<p>‘r’| 读取(默认)<br>‘w’| 写入(会先截断之前的内容)<br>‘x’| 写入，如果文件已经存在会产生异常<br>‘a’| 追加， 将内容写入到已有文件的末尾<br>‘b’| 二进制模式<br>‘t’| 文本模式(默认)<br>‘+’| 更新(既可以读又可以写)</p>
<p>读写文本文件</p>
<pre><code>读取文本文件时，需要在使用open函数时指定好带路径的文件名，可以使用相对路径或绝对路径，并将文件模式设置为&apos;r&apos;，如果不指定默认也是&apos;r&apos;,然后通过encoding</code></pre><p>参数指定编码如果不指定，默认值是Node，那么在读取文件时使用的是操作系统默认的编码，如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的<br>那么可能因为无法解码字符而导致读取失败</p>
<p>如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况异常状况导致程序崩溃，为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生<br>状况的代码进行适当的处理</p>
<p>在Python中，我们可以将那些在运行时可能会出现的状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。<br>文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError,而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try<br>后面跟了三个except分别处理这三种不同的异常。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块代码不论程序正常还是异常都会执行<br>到甚至是调用了sys模块的exit函数退出python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常，因此我们通常把finally块称为总是执行代码块，它最适合用来<br>做释放外部资源的操作，如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境是自动释放文件资源。</p>
<p>除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用realines方法将文件按行读取到一个列表容器中</p>
<p>要将文本信息写入文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为’w’即可，注意如果需要对文本内容进行追加式写入，应该将模式设置为’a’。如果要写入的文件不存在<br>会自动创建文件而不是引发异常。</p>
<p>读写二进制文件<br>    知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能</p>
<p>读写JSON文件<br>    如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是JavaScript Object Notation的缩写，它本来是JavaScript语言中<br>创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的，目前JSON基本上已经<br>取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的参考JSON官方网站：<a href="http://json.org/，可参考每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个" target="_blank" rel="noopener">http://json.org/，可参考每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个</a><br>JSON的简单例子</p>
<p>{<br>    “name”: “骆昊”,<br>    “age”: 38,<br>    “qq”: 957658,<br>    “friends”: [“王大锤”, “白元芳”],<br>    “cars”: [<br>        {“brand”: “BYD”, “max_speed”: 180},<br>        {“brand”: “Audi”, “max_speed”: 280},<br>        {“brand”: “Benz”, “max_speed”: 320}<br>    ]<br>}</p>
<p>JSON和Python中的字典其实是一样的，JSON的数据类型和Python的数据类型是很容易找到对应关系。</p>
<p>JSON | Python<br>object | dict<br>array | list, tuple<br>string | str<br>number(int/real)  int/float<br>true/false | True/False<br>null | None</p>
<p>json模块主要有四个比较重要的函数：<br>dump - 将Python对象按照JSON格式序列化到文件中<br>dumps - 将Python对象处理成JSON格式的字符串<br>load - 将文件中的JSON数据反序列化成对象<br>loads -将字符串的内容反序列化成Python对象</p>
<p>这里出现了两个概念，一个叫序列化，一个叫反序列化，“序列化”serialization在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式<br>这样在需要的时候能够恢复到原本的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一<br>系列字节中提取数据结构的操作，就是反序列化（deserialization）</p>
<p>目前绝大多数网络数据服务，或者网络api都是基于HTTP协议提供JSON格式的数据，<br>HTTP协议入门：<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a><br>了解国内的网络数据服务： 聚合数据： <a href="https://www.juhe.cn/" target="_blank" rel="noopener">https://www.juhe.cn/</a>  阿凡达数据：<a href="https://www.avatardata.cn/" target="_blank" rel="noopener">https://www.avatardata.cn/</a>  <a href="http://apis.io/" target="_blank" rel="noopener">http://apis.io/</a></p>
<p>如何使用requests模块，封装的足够好的第三方网络访问模块，访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题<br>天行数据：<a href="https://www.tianapi.com/" target="_blank" rel="noopener">https://www.tianapi.com/</a> 提供国内新闻数据接口，其中的APIKey需要自己到网站申请</p>
<p>Python中的异常处理总结：<br><a href="https://segmentfault.com/a/1190000007736783" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007736783</a></p>
<p>在Python中要实现序列化和反序列化除了使用json模块，还可以使用pickle和shelve模块，但是这两个模块时使用特有的序列化协议来序列化数据，序列化后的数据只能被Python识别，关于这两个模块<br>可以自己看网络上的资料</p>
<h5 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h5><pre><code>正则表达式相关知识

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的复杂规则的字符串的需要，正则表达式就是用于描述规则的工具，换句话说正则表达式是一种工具
它定义了字符串的匹配模式，如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉。如果你在windows操作系统中
使用过文件查找并且在指定文件名时使用过通配符（*和？），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述
你的需求，当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是代价的，就如同学习一门编程语言一样，比如你可以编写正则表达式
，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号&apos;-&apos;，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这就是国内的座机号码，最初计算机是为了做
数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要
今天几乎所有编程语言都提供了对正则表达式操作的支持。Python通过标准库中的re模块来支持正则表达式操作

我们从某个地方可能是一个文本，也可能是网络是一则新闻，获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位数字，注意并不是随机的11位数字，因

正则入门：https://deerchao.cn/tutorials/regex/regex.htm

Python对正则表达式的支持
Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数

函数 | 说明
compile(pattern, flags=0) | 编译正则表达式返回正则表达式对象
match(pattern, string, flags=0) | 用正则表达式匹配字符串 成功返回匹配对象 否则返回None
search(pattern, string, flags = 0) | 搜索字符串中第一次出现正则表达式的模式，成功返回匹配对象 否则返回None
split(pattern, string, maxsplit = 0, flags= 0) | 用正则表达式指定的模式分隔符拆分字符串 返回列表
sub(pattern, repl, string, count=0, flags=0) | 用指定的字符串替换原字符串中与正则表达式匹配的模式，可以用count指定替换的次数
fullmatch(pattern, string, flags=0) | match函数的完全匹配从字符串开头到结尾版本
findall(pattern, string, flags=0) | 查找字符串所有与正则表达式匹配的模式 返回字符串的列表
finditer(pattern, string, flags=0) | 查找字符串所有与正则表达式匹配的模式 返回一个迭代器
purge() | 清除隐式编译的正则表达式的缓存
re.I /re.IGNORECASE | 忽略大小写匹配标记
re.M /re.MULTILINE | 多行匹配标记

说明：上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么通过compile
函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</code></pre><p>提示：上面在书写正则表达式时使用了原始字符串的写法，在字符串前面加上r，所谓原始字符串就是字符串中的每个字符就是它原始意义，说的更直接一点就是字符串中没有所谓的转义字符。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\，例如表示数字的\d要书写成\d，这样不仅写起来方便，阅读的时候也会很吃力</p>
<p>说明：re模块的正则表达式相关函数红都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写，是否进行多行匹配，是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M</p>
<p>如果要从事爬虫类应用的开发，那么正则表达式是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，在实际开发爬虫应用的时候，有很多人会选择BeautifulSoup和Lxml来进行匹配和信息的提取，前者简单方便但是性能差，后者既好用性能也好，但是安装稍显麻烦</p>
<h5 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h5><p>今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持多任务的操作系统，这使得我们可以同时运行多个程序，也可以将程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验，因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的并发编程，应该是程序员必备技能之一。</p>
<p>概念<br>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配空间，每个进程都有自己的地址空间，数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为他们合理的分配资源，进程可以通过fork或spaw的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制IPC Interprocess Communication来实现数据共享，具体的方式包括管道，信号。套接字、共享内存区等</p>
<p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，他们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易，当然在单核CPU系统下，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具如macOS中的活动监视器，Windows中的任务管理器里看。</p>
<p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的cpu执行时间，导致其他程序无法获得足够的CPU执行时间，另一方面站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对初学者更加的困难</p>
<p>Python既支持多进程又支持多线程，因此使用Pyhton实现并发编程主要有三种方式：多线程、多进程、多进程+多线程</p>
<p>Python中的多进程<br>Unix和Linux操作系统上提供了fork()系统来调用创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID，fork()函数非常特殊它会返回两次，父进程中可以通过<br>fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0,。Python的OS模块体统了fork()函数，由于windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process<br>类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池Pool，用于进程间通信的队列Queue的管道Pipe等</p>
<p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，<br>如何实现两个进程间通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个</p>
<p>当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知<br>要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共性的队列，底层是通过管道和信号量semaphore机制来实现的</p>
<p>可以直接使用Threading模块的Thread类来创建线程，但是我们之前讲过一个重要的概念继承，我们可以从已有的类创建新类，因此也通过成Thread类的方式来创建自定义的线程类<br>然后在创建线程对象并启动线程</p>
<p>因为多个进程可以共享进程内的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可，但是当多个线程共享同一个变量<br>(我们通常称之为资源)的时候，很有可能产生不可控的结果从而导致程序失控甚至崩溃。如果一个资源被多个线程竞争使用，我们通常称之为临界资源<br>对临界资源的访问需要加上保护，否则资源会处于“混乱”的状态，下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的<br>情况下我们很有可能会得到错误的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">因为多个进程可以共享进程内的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可，但是当多个线程共享同一个变量</span><br><span class="line">(我们通常称之为资源)的时候，很有可能产生不可控的结果从而导致程序失控甚至崩溃。如果一个资源被多个线程竞争使用，我们通常称之为临界资源</span><br><span class="line">对临界资源的访问需要加上保护，否则资源会处于“混乱”的状态，下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的</span><br><span class="line">情况下我们很有可能会得到错误的结果</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from time import sleep</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">class Account(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._balance = 0</span><br><span class="line"></span><br><span class="line">    def deposit(self, money):</span><br><span class="line">        # 计算存款后的余额</span><br><span class="line">        new_balance = self._balance + money</span><br><span class="line">        # 模拟受理存款业务需要0.01秒的时间</span><br><span class="line">        sleep(0.01)</span><br><span class="line">        # 修改账户余额</span><br><span class="line">        self._balance = new_balance</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def balance(self):</span><br><span class="line">        return self._balance</span><br><span class="line"></span><br><span class="line">class AddMoneyThread(Thread):</span><br><span class="line">    def __init__(self, account, money):</span><br><span class="line">        super().__init__() </span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    # 创建100个存款的线程向同一个账户中存钱</span><br><span class="line">    for _ in range(100):</span><br><span class="line">        t = AddMoneyThread(account, 1)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    # 等所有存款的线程都执行完毕</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(&apos;账户余额为：￥%d元&apos; % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果远远小于100，之所以出现这种情况是因为我们没有对银行账户这个临界资源加以保护，多个线程同时<br>向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果<br>。在这种情况下，锁就可以排上用场了，我们可以通过锁来保护临界资源，只有获得锁的线程才能访问临界资源，而其他没有得到锁的线程只能被阻塞起来，知道获得锁的线程释放了锁，<br>其他线程才有机会获得锁，进而访问被保护的临界资源，</p>
<p>下面的代码演示了如何使用锁，来保护对银行账户的操作，从而获得正确的结果</p>
<p>多进程还是多线程<br>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢，假设正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先<br>花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5个小时，这种方式称为单任务模型。如果你打算切换到所任务模型，可以先1分钟语文，在切换到数学作业，<br>做1分钟，在切换到英语，以此类推，只要切换速度快，这种方式就和单核CPU执行所任务是一样的。以旁观者来看，你就是正在同时写5科作业</p>
<p>但是切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的 语文书本，钢笔（这叫保存现场），然后打开数学课本，找出圆规直尺，这叫（准备新环境，），这才能开始做数学作业。<br>操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态， 内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等）<br>，才能开始执行，这个切换过程虽然很快，但是也需要耗费时间，如果有几千个任务同时进行，操作系统可能主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响<br>，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会是的系统性能急剧下降，最终导致所有任务都做不好</p>
<p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型，计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等<br>，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。。计算密集型任务由于要消耗CPU资源，这类任务用Python<br>这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前有提到Python中有嵌入C/C++代码的机制</p>
<p>除了计算密集型任务，其他的涉及到网络，存储介质I/O的任务，这类任务的特点是CPU消耗很少，任务的大部分时间都是在等待I/O操作完成，因为I/O的速度远远低于CPU和内存的速度，对于<br>I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率运转，有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用</p>
<h5 id="单线程和异步I-O"><a href="#单线程和异步I-O" class="headerlink" title="单线程和异步I/O"></a>单线程和异步I/O</h5><p>现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O.如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程来执行多任务，这种全新的模型称为事件驱动模型。Ngnix就是至此异步I/O<br>d的web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程，数量与CPU核心数相同，充分利用多核CPU，用Node.js开发的服务器端程序也使用了这种工作模式，<br>可获得极高的性能</p>
<p>应用案例，见Python的应用案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import tkinter</span><br><span class="line">import tkinter.messagebox</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    class DownloadTaskHandler(Thread):</span><br><span class="line"></span><br><span class="line">        def run(self):</span><br><span class="line">            time.sleep(10)</span><br><span class="line">            tkinter.messagebox.showinfo(&apos;提示&apos;, &apos;下载完成&apos;)</span><br><span class="line">            # 启用下载按钮</span><br><span class="line">            button1.config(state=tkinter.NORMAL)</span><br><span class="line"></span><br><span class="line">    def download():</span><br><span class="line">        # 禁用下载按钮</span><br><span class="line">        button1.config(state=tkinter.DISABLED)</span><br><span class="line">        # 通过daemon参数将线程设置为守护进程(主程序退出就不再保留执行)</span><br><span class="line">        # 在线程中处理耗时间的下载任务</span><br><span class="line">        DownloadTaskHandler(daemon=True).start()</span><br><span class="line"></span><br><span class="line">    def show_about():</span><br><span class="line">        tkinter.messagebox.showinfo(&apos;关于&apos;, &apos;作者：闸门&apos;)</span><br><span class="line">    </span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.title(&apos;单线程&apos;)</span><br><span class="line">    top.geometry(&apos;200x150&apos;)</span><br><span class="line">    top.wm_attributes(&apos;-topmost&apos;, 1)</span><br><span class="line"></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    button1 = tkinter.Button(panel, text=&apos;下载&apos;, command=download)</span><br><span class="line">    button1.pack(side=&apos;left&apos;)</span><br><span class="line">    button2= tkinter.Button(panel, text=&apos;关于&apos;, command=show_about)</span><br><span class="line">    button2.pack(side=&apos;right&apos;)</span><br><span class="line">    panel.pack(side=&apos;bottom&apos;)</span><br><span class="line"></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">使用多进程对复杂任务进行分而治之</span><br><span class="line">我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from time import time</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    total = 0</span><br><span class="line">    number_list = [x for x in range(1, 100000001)]</span><br><span class="line">    start = time()</span><br><span class="line">    for number in number_list:</span><br><span class="line">        total += number</span><br><span class="line">    print(total)</span><br><span class="line">    end = time()</span><br><span class="line">    print(&apos;Execution time:%.3fs&apos; % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NEW-LANGUAGE/" rel="tag"># NEW LANGUAGE</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/15/961/" rel="next" title="NINESIXONE">
                <i class="fa fa-chevron-left"></i> NINESIXONE
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/23/Tableau/" rel="prev" title="Tableau">
                Tableau <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/bekjae.jpg" alt="KOKI HOO">
            
              <p class="site-author-name" itemprop="name">KOKI HOO</p>
              <p class="site-description motion-element" itemprop="description">PEACE&LOVE</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量和类型"><span class="nav-number">1.</span> <span class="nav-text">变量和类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量命名"><span class="nav-number">1.0.1.</span> <span class="nav-text">变量命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量的使用"><span class="nav-number">1.0.2.</span> <span class="nav-text">变量的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造程序逻辑"><span class="nav-number">1.0.3.</span> <span class="nav-text">构造程序逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数和模块的使用"><span class="nav-number">1.0.4.</span> <span class="nav-text">函数和模块的使用</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#在参数名前面的-表示args是一个可变参数"><span class="nav-number"></span> <span class="nav-text">在参数名前面的*表示args是一个可变参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#即在调用add函数时可以传入0个或多个参数"><span class="nav-number"></span> <span class="nav-text">即在调用add函数时可以传入0个或多个参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#输出goodbye，world！"><span class="nav-number"></span> <span class="nav-text">输出goodbye，world！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#输出hello-world"><span class="nav-number"></span> <span class="nav-text">输出hello world</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#name-是Python中一个隐含的变量它代表了模块的名字"><span class="nav-number"></span> <span class="nav-text">_name_是Python中一个隐含的变量它代表了模块的名字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#只有被Python解释器执行的模块的名字才是main"><span class="nav-number"></span> <span class="nav-text">只有被Python解释器执行的模块的名字才是main</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Python中有关变量作用域的问题"><span class="nav-number">0.0.0.1.</span> <span class="nav-text">Python中有关变量作用域的问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串和常用数据结构"><span class="nav-number">0.0.1.</span> <span class="nav-text">字符串和常用数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用字符串"><span class="nav-number">0.0.1.1.</span> <span class="nav-text">使用字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用元组"><span class="nav-number">0.0.1.2.</span> <span class="nav-text">使用元组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用集合"><span class="nav-number">0.0.1.3.</span> <span class="nav-text">使用集合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象的支柱"><span class="nav-number"></span> <span class="nav-text">面向对象的支柱</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#slots-魔法"><span class="nav-number">0.0.0.1.</span> <span class="nav-text">slots 魔法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态方法和类方法"><span class="nav-number">0.0.0.2.</span> <span class="nav-text">静态方法和类方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类之间的关系"><span class="nav-number">0.0.0.3.</span> <span class="nav-text">类之间的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#文件和异常"><span class="nav-number">0.0.0.3.1.</span> <span class="nav-text">文件和异常</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用正则表达式"><span class="nav-number">0.0.0.4.</span> <span class="nav-text">使用正则表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程和线程"><span class="nav-number">0.0.0.5.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单线程和异步I-O"><span class="nav-number">0.0.0.6.</span> <span class="nav-text">单线程和异步I/O</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KOKI HOO</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">57.5k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jD3hLxRDgCSdorrir1RFkW3R-gzGzoHsz", "9AOQX6uUKthSSONK5UO95RGd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
