<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="NOTE,">










<meta name="description" content="第一部分 数据结构与算法The ADT defines the logical form of the data type.The data structure implements  the physical form of the data type. 一、栈(Stack)、队列(Queue)和向量(Vector) 内容：单链表，双向链表，环形链表，带哨兵节点的链表；栈的基本概念和性质，栈AD">
<meta name="keywords" content="NOTE">
<meta property="og:type" content="article">
<meta property="og:title" content="NINESIXONE">
<meta property="og:url" content="http://yoursite.com/2019/08/15/961/index.html">
<meta property="og:site_name" content="KOKI">
<meta property="og:description" content="第一部分 数据结构与算法The ADT defines the logical form of the data type.The data structure implements  the physical form of the data type. 一、栈(Stack)、队列(Queue)和向量(Vector) 内容：单链表，双向链表，环形链表，带哨兵节点的链表；栈的基本概念和性质，栈AD">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/%E5%9B%BE%E7%9A%84%E5%BC%95%E4%BE%8B.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%9C%B0%E9%93%81%E7%BA%BF%E8%B7%AF.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%97%A0%E5%90%91%E5%9B%BE.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%82%BB%E6%8E%A5%E8%A1%A8.png">
<meta property="og:image" content="http://yoursite.com/images/Merge_Sort.png">
<meta property="og:updated_time" content="2019-11-01T05:15:29.993Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NINESIXONE">
<meta name="twitter:description" content="第一部分 数据结构与算法The ADT defines the logical form of the data type.The data structure implements  the physical form of the data type. 一、栈(Stack)、队列(Queue)和向量(Vector) 内容：单链表，双向链表，环形链表，带哨兵节点的链表；栈的基本概念和性质，栈AD">
<meta name="twitter:image" content="http://yoursite.com/images/%E5%9B%BE%E7%9A%84%E5%BC%95%E4%BE%8B.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/15/961/">





  <title>NINESIXONE | KOKI</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a5ecac7771fad0fda5191a255b9e3f5c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KOKI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/961/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">NINESIXONE</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T17:51:53+08:00">
                2019-08-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-11-01T13:15:29+08:00">
                2019-11-01
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/15/961/" class="leancloud_visitors" data-flag-title="NINESIXONE">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  20k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  85
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="第一部分-数据结构与算法"><a href="#第一部分-数据结构与算法" class="headerlink" title="第一部分 数据结构与算法"></a>第一部分 数据结构与算法</h3><p>The ADT defines the logical form of the data type.The data structure implements  the physical form of the data type.</p>
<h4 id="一、栈-Stack-、队列-Queue-和向量-Vector"><a href="#一、栈-Stack-、队列-Queue-和向量-Vector" class="headerlink" title="一、栈(Stack)、队列(Queue)和向量(Vector)"></a>一、栈(Stack)、队列(Queue)和向量(Vector)</h4><blockquote>
<p>内容：单链表，双向链表，环形链表，带哨兵节点的链表；栈的基本概念和性质，栈ADT及其顺序，链表实现；栈的应用；栈与递归；队列的基本概念和性质，队列ADT及其顺序、链表实现；队列的应用；向量基本概念和性质；向量ADT及其数组、链接实现；</p>
</blockquote>
<h5 id="单链表-Linked-Lists"><a href="#单链表-Linked-Lists" class="headerlink" title="单链表 Linked Lists"></a>单链表 Linked Lists</h5><p>Arrays are one way to implement Stacks, queues, etc.<br>Linked Lists are another – extremely flexible and general idea! 链表是另外一个非常灵活又常用的方法</p>
<p>Linked list = “Node” objects connected in a “chain” by links (object references) // 结点对象通过”链”连接起来</p>
<p>List Node Objects 链表结点对象<br>class ListNode {<br>    ListNode (Object theElement){ // default constructor<br>        this(theElement, null)<br>    }</p>
<pre><code>ListNode (Object theElement, ListNode n){ // constructor
    element = theElement;
    next = n;
}

ListNode next; // the next Node in the list
Object element; // the data</code></pre><p>}</p>
<pre><code>element    next
Rome        -&gt; null means &quot;ends of list&quot;</code></pre><p>Two special entry points</p>
<pre><code>if we maintain these two special entry points, it is easy to delete or insert entires at the &quot;head&quot; and insert entries at the &quot;tail&quot; 维护这两个特殊的入口点，将很容易在&quot;头&quot;结点处删除或插入实体，在&quot;尾&quot;处插入条目。</code></pre><h5 id="双向链表-Doubly-Linked-List"><a href="#双向链表-Doubly-Linked-List" class="headerlink" title="双向链表 Doubly Linked List"></a>双向链表 Doubly Linked List</h5><h5 id="循环-环形-链表-Circular-Linked-List"><a href="#循环-环形-链表-Circular-Linked-List" class="headerlink" title="循环(环形)链表 Circular Linked List"></a>循环(环形)链表 Circular Linked List</h5><h5 id="带哨兵结点的链表"><a href="#带哨兵结点的链表" class="headerlink" title="带哨兵结点的链表"></a>带哨兵结点的链表</h5><h5 id="栈的基本概念和性质-栈ADT及其顺序、链表实现"><a href="#栈的基本概念和性质-栈ADT及其顺序、链表实现" class="headerlink" title="栈的基本概念和性质,栈ADT及其顺序、链表实现"></a>栈的基本概念和性质,栈ADT及其顺序、链表实现</h5><h6 id="栈的基本概念和性质"><a href="#栈的基本概念和性质" class="headerlink" title="栈的基本概念和性质"></a>栈的基本概念和性质</h6><blockquote>
<p>堆栈: 具有一定操作约束的线性表，只在一端(栈顶，top)做插入，删除<br>    插入数据：入栈（Push）<br>    删除数据：出栈（Pop）<br>    后入先出：Last In First Out（LIFO）</p>
</blockquote>
<h6 id="栈ADT"><a href="#栈ADT" class="headerlink" title="栈ADT"></a>栈ADT</h6><pre><code>类型名称：Stack 栈
数据对象集：一个有0个或多个元素的有穷线性表
操作集：长度为MaxSize的堆栈S∈Stack，堆栈元素item∈ElementType
1、Stack CreateStack(int MaxSize): 生成空堆栈，其最大长度为MaxSize
2、int IsFull(Stack S, ElementType item): 判断堆栈S是否已满
3、void Push(Stack S, ElementType item): 将元素item压入堆栈
4、int IsEmpty(Stack S): 判断堆栈S是否为空；
5、ElementType Pop(Stack S): 删除并返回栈顶元素</code></pre><h6 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h6><blockquote>
<p>  栈的顺序存储结构通常是由一个<strong>一维数组</strong>和一个记录<strong>栈顶</strong>元素位置的变量组成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">typedef int Position</span><br><span class="line">struct SNode &#123;</span><br><span class="line">    ElementType *Data; // 存储元素的数组</span><br><span class="line">    Position Top; // 栈顶指针</span><br><span class="line">    int MaxSize; // 堆栈的最大容量</span><br><span class="line">&#125;</span><br><span class="line">typedef struct SNode *Stack;</span><br><span class="line"></span><br><span class="line">// 生成空堆栈</span><br><span class="line">Stack CreateStack(int MaxSize) &#123;</span><br><span class="line">    Stack S = (Stack)malloc(sizeof(struct SNode));</span><br><span class="line">    S-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));</span><br><span class="line">    S-&gt;Top = -1;</span><br><span class="line">    S-&gt; MaxSize = MaxSize;</span><br><span class="line">    return S</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断堆栈S是否已满</span><br><span class="line">bool IsFull(Stack S)&#123;</span><br><span class="line">    return (S-&gt;Top == S-&gt;MaxSize - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入栈</span><br><span class="line">bool Push(Stack S, ElmentType X)&#123;</span><br><span class="line">    if (IsFull(S))&#123;</span><br><span class="line">        printf(&apos;堆栈已满&apos;);</span><br><span class="line">        return False;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        S-&gt;Data[++(S-&gt;Top)] = X;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断堆栈为空</span><br><span class="line">bool IsEmpty(Stack S)&#123;</span><br><span class="line">    return (S-&gt;Top == -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">ElementType Pop(Stack S)&#123;</span><br><span class="line">    if(IsEmpty(S))&#123;</span><br><span class="line">        printf(&apos;堆栈空&apos;);</span><br><span class="line">        return ERROR; // ERROR是ElementType的特殊值，标志错误</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return S-&gt;Data((S-&gt;Top)--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="栈的链式存储实现"><a href="#栈的链式存储实现" class="headerlink" title="栈的链式存储实现"></a>栈的链式存储实现</h6><blockquote>
<p>栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。栈顶指针Top应该在链表的哪一头？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">typedef struct  SNode *PtrToSNode;</span><br><span class="line">struct SNode &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToSNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToSNode Stack;</span><br><span class="line"></span><br><span class="line">// 1、堆栈初始化</span><br><span class="line">// 2、判断堆栈S是否为空</span><br><span class="line"></span><br><span class="line">Stack CreateStack()&#123;</span><br><span class="line">    // 构建一个堆栈的头结点，返回指针</span><br><span class="line">    Stack S;</span><br><span class="line">    S = (Stack) malloc(sizeof(struct SNode));</span><br><span class="line">    S-&gt;Next = NULL;</span><br><span class="line">    retrun S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(Stack S)&#123;</span><br><span class="line">    // 判断堆栈S是否为空，若为空函数则返回true，否则返回false</span><br><span class="line">    return (S-&gt;Next == NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Push(Stack S, ElemenType X)&#123;</span><br><span class="line">    // 将元素item压入堆栈S</span><br><span class="line">    PtrToSNode TmpCell;</span><br><span class="line">    &lt;!-- TmpCell = (struct SNode *)malloc(sizeof(struct SNode)); --&gt;</span><br><span class="line">    TmpCell = (PtrToSNode)malloc(sizeof(struct SNode));</span><br><span class="line">    TmpCell-&gt; Data = X;</span><br><span class="line">    TmpCell-&gt; Next = S-&gt;next;</span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType Pop(Stack S)&#123;</span><br><span class="line">    // 删除并返回堆栈S的栈顶元素</span><br><span class="line">    &lt;!-- struct SNode *FirstCell; --&gt;</span><br><span class="line">    PtrToSNode FirstCell;</span><br><span class="line">    ElmentType TopElem;</span><br><span class="line">    if(IsEmpty(S))&#123;</span><br><span class="line">        printf(&apos;堆栈空&apos;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        TopElem = FirstCell-&gt;Element;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">        free(FirstCell);</span><br><span class="line">        return TopElem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="栈的应用；Stack-Application"><a href="#栈的应用；Stack-Application" class="headerlink" title="栈的应用；Stack Application"></a>栈的应用；Stack Application</h5><pre><code>【表达式求值】</code></pre><h5 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h5><h5 id="队列的基本概念和性质-队列ADT及其顺序、链表实现"><a href="#队列的基本概念和性质-队列ADT及其顺序、链表实现" class="headerlink" title="队列的基本概念和性质,队列ADT及其顺序、链表实现"></a>队列的基本概念和性质,队列ADT及其顺序、链表实现</h5><h6 id="队列的基本概念和性质"><a href="#队列的基本概念和性质" class="headerlink" title="队列的基本概念和性质"></a>队列的基本概念和性质</h6><blockquote>
<p>队列Queue: 具有一定操作约束的线性表<br>    插入和删除操作：只能在一端插入，而在另一端删除</p>
</blockquote>
<pre><code>数据插入：入队列(AddQ)
数据删除：出队列(DeleteQ)
先来先服务
先进先出： FIFO</code></pre><h6 id="队列ADT"><a href="#队列ADT" class="headerlink" title="队列ADT"></a>队列ADT</h6><blockquote>
</blockquote>
<pre><code>类型名称： 队列(Queue)
数据对象集：一个有0个或多个元素的有穷线性表
操作集：长度为MaxSize的队列Q∈Queue,队列元素item ∈ EelmentType
1、Queue CreateQueue(int MaxSize)：生成长度为MaxSize的空队列
2、int IsFull(Queue Q, int MaxSize): 判断队列Q是否已满
3、void AddQ(Queuq Q, ElementType item): 将数据元素item插入队列Q中
4、int IsEmptyQ(Queue Q): 判断队列Q是否为空
5、ElementType DeleteQ(Queue Q): 将对头数据元素从队列中删除并返回</code></pre><h6 id="队列顺序、链表实现"><a href="#队列顺序、链表实现" class="headerlink" title="队列顺序、链表实现"></a>队列顺序、链表实现</h6><blockquote>
<p>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素的变量rear组成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">typedef int Position</span><br><span class="line">struct QNode &#123;</span><br><span class="line">    ElementType *Data; // 存储元素的数组</span><br><span class="line">    Position Front,Rear; // 队列的头，尾指针</span><br><span class="line">    int MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line"></span><br><span class="line">Queue CreateQueue(int MaxSize)&#123;</span><br><span class="line">    Queue Q = (Queue) malloc (sizeof(struct QNode));</span><br><span class="line">    Q-&gt;Data = (ElementType *) malloc (MaxSize * sizeof(ElementType));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = 0;</span><br><span class="line">    Q-&gt;MaxSize = MaxSize;</span><br><span class="line">    return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsFull(Queue Q)&#123;</span><br><span class="line">    return ((Q-&gt;Rear+1)%Q-&gt;MaxSize == Q-&gt;Front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool AddQ(Queue Q, ElementType X)&#123;</span><br><span class="line">    if(IsFull()) &#123;</span><br><span class="line">        printf(&quot;队列满&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Q-&gt;Rear = (Q-&gt;Rear + 1)%Q -&gt; MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = X;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(Queue Q)&#123;</span><br><span class="line">    return (Q-&gt;Front == Q-&gt;Rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType DeleteQ(Queue Q)&#123;</span><br><span class="line">    if(IsEmpty(Q))&#123;</span><br><span class="line">        printf(&apos;队列空&apos;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tmp = Q-&gt;Data(Q-&gt;Front)</span><br><span class="line">        Q-&gt;Front = (Q-&gt;Front +1 )%Q-&gt;MaxSiz;</span><br><span class="line">        &lt;!-- return Q-&gt;Data(Q-&gt;Front) // 这里不对 --&gt;</span><br><span class="line">        return tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队列的链式存储结构也可以用一个单链表实现，插入和删除操作分别再链表的两头进行。队列指针front和rear应该分别指向链表的哪一头？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    // 队列中的结点</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode Position;</span><br><span class="line"></span><br><span class="line">struct QNode &#123;</span><br><span class="line">    Position Front, Rear;// 队列的头，尾指针</span><br><span class="line">    int MaxSize; // 队列最大容量</span><br><span class="line">&#125;</span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(Queue Q)&#123;</span><br><span class="line">    return (Q-&gt;Front == NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType DeleteQ(Queue Q)&#123;</span><br><span class="line">    Position FrontCell;</span><br><span class="line">    ElementType FrontElem;</span><br><span class="line"></span><br><span class="line">    if(IsEmpty(Q))&#123;</span><br><span class="line">        printf(&quot;队列为空&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        FrontCell = Q-&gt;Front;</span><br><span class="line">        if(Q-&gt;Front == Q-&gt;Rear) // 若队列只有一个元素</span><br><span class="line">            Q-&gt;Front = Q-&gt;Rear = NULL; // 删除后队列置为空</span><br><span class="line">        else</span><br><span class="line">            Q-&gt;Front = Q-&gt;Front-&gt;Next;</span><br><span class="line">        FrontElem = FrontCell-&gt;Data;</span><br><span class="line">        free(FrontCell); // 释放被删除结点的空间</span><br><span class="line">        return FrontElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h6><h5 id="向量的基本概念和性质-向量ADT及其数组、链表实现"><a href="#向量的基本概念和性质-向量ADT及其数组、链表实现" class="headerlink" title="向量的基本概念和性质,向量ADT及其数组、链表实现"></a>向量的基本概念和性质,向量ADT及其数组、链表实现</h5><h4 id="二、树"><a href="#二、树" class="headerlink" title="二、树"></a>二、树</h4><blockquote>
<p>内容： 树的基本概念和术语；树的前序，中序，后序，层次序遍历；二叉树及其性质；普通树与二叉树的转换；树的存储结构，标准形式；完全树(complete tree)的数组形式存储；树的应用，Huffman树的定义与应用。</p>
</blockquote>
<h5 id="树的基本概念和术语"><a href="#树的基本概念和术语" class="headerlink" title="树的基本概念和术语"></a>树的基本概念和术语</h5><blockquote>
<p>树(Tree): n(n&gt;=0)个结点构成的有限集合。n=0时，称为空树，对于任一颗非空树(n&gt;0),它具备以下性质：</p>
</blockquote>
<pre><code>树中有一个称为“根Root”的特殊结点，用r表示
其余结点可分为m(m&gt;0)个互不相交的有限集T1，T2...Tm, 其中每个集合本身又是一颗树，称为原来的子树

子树是不相交的
除了根结点外，每个结点有且仅有一个父结点
一颗N个结点的树有N-1条边

**树的一些基本术语**
1、结点的度Degree：结点的子树个数
2、树的度：树的所有结点中最大的度数
3、叶结点Leaf：度为0的结点
4、父结点Parent：有子树的结点是其子树根结点的父结点
5、子结点（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点，子结点也称孩子结点
6、兄弟节点Sibling：具有同一父结点的各节点彼此是兄弟节点
7、路径与路径长度：从结点n1到nk的路径为一个结点序列n1，n2……nk，ni是ni+1的父结点，路径所包含边的个数为路径的长度
8、祖先结点Ancestor：沿树根到某一结点路径上所有结点都是这个结点的祖先结点
9、子孙结点Descendant：某一结点的子树中的所有结点是这个节点的子孙
10、结点的层次Level：规定跟结点在1层，其他任一结点的层数是其父结点的层数加1
11、树的深度Depth：树中所有结点中的最大层次是这棵树的深度</code></pre><h5 id="树的前序、中序、后序、层次遍历"><a href="#树的前序、中序、后序、层次遍历" class="headerlink" title="树的前序、中序、后序、层次遍历"></a>树的前序、中序、后序、层次遍历</h5><pre><code>(1) 先序遍历
    遍历过程为：
        1、访问根结点
        2、先序遍历左子树
        3、先序遍历右子树
    ![先序遍历](/images/先序遍历.png)
    A(BDFE)(CGHI)
    先序遍历=&gt; A B D F E C G H I

    void PreOrderTraversal(BinTree BT){
        if(BT){
            printf(&apos;%d&apos;, BT-&gt;Data);
            PreOrderTraversal(BT-&gt;Left);
            PreOrderTraversal(BT-&gt;Right);
        }
    }

    第一次碰到的时候弹出:
    void PreOrderTraversal(BinTree BT){
        BinTree T BT;
        Stack S = CreatStack(MaxSize) ;// 创建并初始化堆栈S
        while( T || !IsEmpty(S)){
            while(t){ // 一直向左并将沿途结点压入堆栈
                Push(S, T);
                T = Pop(S); // 结点弹出堆栈
                printf(&quot;%5d&quot;, T-&gt;Data);
                T = T-&gt;Left;

                if(!IsEmpty(S)){
                    T = T-&gt;Right; // 转向右子树
                }

            }
        }
    }


(2) 中序遍历
    遍历过程为：
        1、中序遍历其左子树;
        2、访问根结点
        3、中序遍历其右子树
    ![中序遍历](/images/中序遍历.png)
    (DBEF) A (GHCI)
    中序遍历=&gt; DBEFAGHCI

    void InOrderTraversal(BinTree BT){
        if(BT){
            InOrderTraversal(BT-&gt;Left);
            printf(&apos;%d&apos;, BT-&gt;Data);
            InOrderTraversal(BT-&gt;Right);
        }
    }

    中序遍历非递归遍历算法：
        非递归算法实现的基本思路：使用堆栈
        - 遇到一个结点，就把它压栈，并去遍历它的左子树；
        - 当左子树遍历结束后，从栈顶弹出这个结点并访问它
        - 然后按其右指针再去中序遍历该结点的右子树
    第二次碰到的时候弹出

    void InOrderTraversal(BinTree BT) {
        BinTree T = BT;
        Stack S = CreatStack(MaxSize); // 创建并初始化堆栈S
        while( T || !IsEmpty(S)) { // 树不空或者堆栈不空
            while(T) {
                Push(S, T);
                T = T -&gt; Left;
            }
            if(!IsEmpty(S)){
                T = Pop(S); // 结点弹出堆栈
                printf(&quot;%5d&quot;, T-&gt;Data); // 访问打印结点
                T = T-&gt;Right; // 转向右子树
            }
        }
    }


(3) 后序遍历
    遍历过程为：
        1、后序遍历左子树
        2、后序遍历右子树
        3、访问根结点
    ![后序遍历](/images/后序遍历.png)
    (DEFB)(HGIC)A
    后序遍历=&gt; D E F B H G I C A
    void PostOrderTraversal(BinTree BT){
        if(BT){
            PostOrderTraversal(BT-&gt;Left);
            PostOrderTraversal(BT-&gt;Right);
            printf(&quot;%d&quot;, BT-&gt;Data);
        }
    }


(4) 层序遍历
    二叉树遍历的核心问题：二维结构的线性化
        - 从结点访问其左右儿子结点
        - 访问左儿子后，右儿子结点怎么办？
            需要一个存储结构保存暂不访问的结点
            存储结构：堆栈、队列
    队列实现： 遍历从根结点开始，首先将根结点入队，然后开始执行循环，结点出队，访问该结点，其左右儿子入队。
    ![层序遍历](/images/层序遍历.png)

     A B C D F G I E H
     层序遍历： A B C D F G I E H

    层序基本过程： 先跟结点入队，然后：
    1、从队列中取出一个元素；
    2、访问该元素所指结点
    3、若该元素所指结点的左右孩子结点非空，则将其左右孩子的指针顺粗入队

    void LevelOrderTraversal(BinTree BT){
        Queue Q;
        BinTree T;
        if(!BT) return; // 若是空树返回
        Q = CreateQueue(MaxSize); // 创建并初始化队列Q
        AddQ(Q, BT);
        while(!IsEmptyQ(Q)){
            T = DeleteQ(Q);
            printf(&apos;%d\n&apos;, T-&gt;Data); // 访问取出队列的结点
            if(T-&gt;left) AddQ(Q, T-&gt;Left);
            if(T-&gt;right) AddQ(Q, T -&gt; Right);
        }
    }</code></pre><h5 id="二叉树及其性质"><a href="#二叉树及其性质" class="headerlink" title="二叉树及其性质"></a>二叉树及其性质</h5><blockquote>
<p>二叉树的定义;<br>    二叉树T：一个有穷的结点集合<br>            这个集合可以为空<br>            若不为空，则它是由根结点和称为其左子树Tl和右子树Tr的两个不想交的二叉树组成</p>
</blockquote>
<pre><code>二叉树具体五种基本形态：

 空      O           O           O             O
                 Tl                 Tr     Tl     Tr

(a)     (b)         (c)          (d)           (e)


二叉树的子树有左右顺序之分
   A                    A
B                          B
(左子树)                (右子树)


特殊二叉树：
    * 斜二叉树 Skewed Binary Tree
    A
       B
          C 
             D
完美二叉树 Perfact Binary Tree 满二叉树 Full Binary Tree
                    A
            B                     C
        D     E              F        G
    H   I J   K          L   M    N    O

完全二叉树 Complete Binary Tree
    有n个结点的二叉树，对树中结点按从上到下，从左到右顺序进行编号，编号为i(1&lt;=i&lt;=n)结点与满二叉树中编号为i结点在二叉树中位置相同。

二叉树几个重要性质：
1、一个二叉树第i层的最大结点数为2^i-1, i&gt;=1
2、深度为k的二叉树有最大结点总数为：2^k - 1, k&gt;= 1
3、对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶子结点个数，那么满足关系n0 = n2 + 1
     A
  B     C
D   E  F
  J  K   H   

  n0 ：D J K H 4
  N1：C F 2
  N2：A B E 3

  No=N2 + 1 叶子结点个数为度为2的非叶子结点个数+1</code></pre><h5 id="普通树与二叉树的转换"><a href="#普通树与二叉树的转换" class="headerlink" title="普通树与二叉树的转换"></a>普通树与二叉树的转换</h5><pre><code>树转换为二叉树：
  1、加线：在兄弟之间加一条线
  2、抹线：对每个结点，除了其左孩子外，抹掉其与其余孩子之间的连线
  3、旋转：将树作适当的旋转即可

二叉树转换成树：
  1、逆旋转：把二叉树从左上到右下分为若干层，然后调整为水平方向
  2、加线：找到每一层结点在其上层的父结点，将每层的结点和其父结点相连
  3、抹线：删掉每一层结点之间的连接</code></pre><h5 id="树的存储结构，标准形式"><a href="#树的存储结构，标准形式" class="headerlink" title="树的存储结构，标准形式"></a>树的存储结构，标准形式</h5><blockquote>
<p>二叉树的存储结构<br>    1、顺序存储结构<br>    完全二叉树：按从上到下，从左到右顺序存储n个结点的完全二叉树的结点父子关系<br>                    A<br>         B                   O<br>      C    S              M     Q<br>    W   K</p>
</blockquote>
<pre><code>非根结点(序号i&gt;1)的父结点的序号是i/2
结点(序号为i)的左孩子结点的序号是2i，若2i&lt;= n，否则没有左孩子
结点(序号为i)的右孩子结点的序号是2i+1，若2i+1在&lt;= n,否则没有右孩子

结点   A    B   O   C   S    M    Q    W    K
序号   1    2   3   4   5    6    7    8    9

一般二叉树也可以采用这种结构，但会造成空间浪费


2、链表存储
typedef struct TreeNode *BinTree;
typedef BinTree Position; // 二叉树类型
struct TreeNode {
    ElementType data;
    BinTree Left;s
    BinTree Right;
}

Left Data Right

![二叉树链表存储](/images/二叉树链表存储.png)</code></pre><h5 id="完全树（complete-tree）的数组形式存储"><a href="#完全树（complete-tree）的数组形式存储" class="headerlink" title="完全树（complete tree）的数组形式存储"></a>完全树（complete tree）的数组形式存储</h5><pre><code>完全二叉树：按从上到下，从左到右顺序存储n个结点的完全二叉树的结点父子关系
                A
    B                   O
C    S              M     Q
W   K

非根结点(序号i&gt;1)的父结点的序号是i/2
结点(序号为i)的左孩子结点的序号是2i，若2i&lt;= n，否则没有左孩子
结点(序号为i)的右孩子结点的序号是2i+1，若2i+1在&lt;= n,否则没有右孩子

结点   A    B   O   C   S    M    Q    W    K
序号   1    2   3   4   5    6    7    8    9

一般二叉树也可以采用这种结构，但会造成空间浪费</code></pre><h5 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h5><blockquote>
<pre><code>一、遍历二叉树的应用：输出二叉树中的叶子结点
在二叉树的遍历算法中增加检测结点的&quot;左右子树是否都为空&quot;
void PreOrderPrintLeaves(BinTree BT){
    if(BT){
        if(!BT-&gt;Left &amp;&amp; !BT-&gt;Right)
            printf(&quot;%d&quot;, BT-&gt;Data);
        PreOrderPrintLeaves(BT-&gt;Left);
        PreOrderPrintLeaves(BT-&gt;Right);
    }
}</code></pre></blockquote>
<pre><code>二、求二叉树的高度]
            O

左子树(Hl)      右子树(HR)
Height = max(HL, HR) + 1;

// 这个算法好像是有问题 如果是伪码的话好像也差点意思
int PostOrderGetHeight(BinTree BT){
    int HL, HR, MaxH;
    if(BT) {
        HL = PostOrderGetHeight(BT-&gt;Left); // 求左子树的深度
        HR = PostOrderGetHeight(BT-&gt;Right); // 求右子树的深度
        MaxH = （HL &gt; HR) ? HL : HR; // 取左右子树较大的深度
        return (MaxH + 1); // 返回树的深度
    }
    else return 0; // 空树深度为0
}

三、二元运算表达式及其遍历
                 +

            +                         *
      a          *                  +        g
               b    c            *    f
                             d      e



    三种遍历可以得到三种不同的访问结果：
    先序遍历得到前缀表达式： + + a * b c * + * d e f g
    中序遍历得到中缀表达式：a + b * c + d * e + f * g
    后序遍历得到后缀表达式：a b c * + d e * f + g * +

四、由两种遍历序列确定二叉树
    问：已知三种遍历中的任意两种遍历序列能否唯一确定一颗二叉树呢？
    答案：必须要有中序遍历

    先序和中序遍历序列来确定一颗二叉树
    分析：
    - 根据先序遍历序列第一个结点确定根结点
    - 根据根结点在中序遍历序列中分割出左右两个子序列
    - 对左子树和右子树分别递归使用相同的方法继续分解

    先序序列：根结点 左子树 右子树
    中序序列：左子树 根结点 右子树

    类似的，后序和中序遍历序列也可以确定一颗二叉树</code></pre><h5 id="Huffman树的定义与应用"><a href="#Huffman树的定义与应用" class="headerlink" title="Huffman树的定义与应用"></a>Huffman树的定义与应用</h5><h6 id="Huffman树的定义"><a href="#Huffman树的定义" class="headerlink" title="Huffman树的定义"></a>Huffman树的定义</h6><blockquote>
<p><strong>带权路径长度</strong>WPL：设二叉树有n个叶子结点，每个叶子结点带有权值Wk。从根结点到每个叶子结点的长度为Lk，则每个叶子结点的带权路径长度之和就是：WPL = ∑(n, k=1)WkLk<br>  最优二叉树或哈夫曼树：<strong>WPL最小的二叉树</strong></p>
</blockquote>
<p>  判定树 查找效率 找出最优二叉树 最优判别树 提高查找效率<br>  比率*比较次数</p>
<p>  <strong>根据结点不同的查找效率构造更有效的搜索树–这就是哈夫曼树要解决的问题</strong></p>
<p>  哈夫曼树的构造<br>    1、每次把权值最小的两颗二叉树合并<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int Weight;</span><br><span class="line">    HuffmanTree Left, Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuffmanTree Huffman(MinHeap H)&#123;</span><br><span class="line">    // 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里</span><br><span class="line">    int i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H); // 将H-&gt;Elements[]按权值调整为最小堆</span><br><span class="line">    for(i=1; i&lt;H-&gt;Size; i++) &#123;</span><br><span class="line">        // 做H-&gt;Size -1次合并</span><br><span class="line">        T = malloc(sizeof(struct TreeNode)); // 建立新结点</span><br><span class="line">        T-&gt;Left = DeleteMin(H); // 从最小堆中删除一个结点，作为新T的左结点</span><br><span class="line">        T-&gt;Right = DeleteMin(H); // 从最小堆中删除一个结点，作为新T的右结点</span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class="line">        Insert(H, T); // 将T插入到最小堆</span><br><span class="line">    &#125;</span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>整体时间复杂度为O(NlogN)
如何选取两个最小的？ 利用堆！排序方法效率不如堆！


哈夫曼树的特点：
1、没有度为1的结点
2、n个叶子结点的哈夫曼树共有2n-1个结点
3、哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树

    n0：叶结点总数
    n1：只有一个儿子的结点总数
    n2：有2个儿子的结点总数

    n2 = n0 -1
？对同一组权值{w1, w2, …… wn},是否存在不同构的两颗哈夫曼树呢？
对一组权值，不同构的两棵哈夫曼树WPL相同</code></pre><h6 id="Huffman哈夫曼应用"><a href="#Huffman哈夫曼应用" class="headerlink" title="Huffman哈夫曼应用"></a>Huffman哈夫曼应用</h6><pre><code>哈夫曼编码：
给定一段字符串，如何对字符进行编码，可以使得该字符串的编码存储空间最小？
[例]假设有一段文本，包含58个字符，并由一下7个字符构成：a，e，i，s，t，空格（sp），换行（nl）；这7个字符出现的次数不同。如何对这7个字符进行编码，使得总编码空间最少？
【分析】：
(1) 用等长ASCII编码：58*8 = 464位
(2) 用等长3位编码：58*3 = 174位
(3) 不等长编码：出现频率高的字符用的编码短些，出现频率低的字符则编码可以长些
怎么进行不等长编码?
如何避免二义性?
前缀码prefix code：任何字符的编码都不是另一个字符编码的前缀
    - 可以无二义地解码
二叉树用于编码：
    用二叉树进行编码：
    1、左右分支：0、1
    2、字符只在叶结点上

四个字符的频率：a：4， u：1， x：2， z: 1

       0|1
    0|1     0|1
 |a   u| |x   z|

a: 00
u: 01
x: 10
z: 11
当所有字符在叶结点上时，不会出现一个字符的编码是另一个字符的前缀码

Cost(aaaxuaxz-&gt;0000001001001011) = 2*4 + 2*1 + 2*2 + 2*1 = 16

然后哈夫曼树构造一颗编码代价最小的二叉树
    0|1
a|     0|1
     x|  0|1
       u|   z|
a: 0
u: 110
x: 10
z: 111
Cost(aaaxuaxz-&gt;00010110010111) = 1*4 + 3*1 + 2*2 + 3*1 = 14

怎么构造一颗编码代价最小的二叉树？
哈夫曼编码：
Ci a  e  i  s  t  sp  nl
fi 10 15 12 3  4  13  1

构造哈夫曼树：
               0|58|1
        0|25|1            0|33|1
    12i      sp13      e15       0|18|1
                             0|8|1      0|10a|1
                           4t   0|4|1
                              1nl   3s
然后哈夫曼编码就出来了
a：111
e: 10
i: 00
s: 11011
t: 1100
sp: 01
nl: 11010</code></pre><h4 id="三、查找-search"><a href="#三、查找-search" class="headerlink" title="三、查找(search)"></a>三、查找(search)</h4><blockquote>
<p>内容： 查找的基本概念；对线性关系结构的查找；顺序查找；二分查找；Hash查找法；常见的Hash函数（直接定址法，随机数法），hash冲突的概念，解决冲突的方法(开散列方法/拉链法，闭散列方法/开址定址法)，二次聚集现象；BST树定义，性质，ADT及其实现，BST树查找，插入，删除算法；平衡树(AVL)的定义，性质，ADT及其实现，平衡树查找，插入算法，平衡因子的概念；优先队列与堆，堆的定义，堆的生成，调整算法；范围查询；</p>
</blockquote>
<h4 id="四、排序"><a href="#四、排序" class="headerlink" title="四、排序"></a>四、排序</h4><blockquote>
<p>内容：排序基本概念；插入排序，希尔排序，选择排序，快速排序，合并排序，基数排序等排序算法基本思想，算法代码及基本的时间复杂度分析</p>
</blockquote>
<h4 id="五、图"><a href="#五、图" class="headerlink" title="五、图"></a>五、图</h4><blockquote>
<p>内容：<br>        图的基本概念<br>        图的存储结构<br>            - 邻接矩阵<br>            - 邻接表<br>        图的遍历<br>            - 广度优先遍历<br>            - 深度优先遍历；<br>        最小生成树基本概念<br>            - Prim算法<br>            - Kruskal算法<br>        最短路径问题<br>            - 广度优先遍历算法<br>            - Dijkstra算法<br>            - Floyd算法；<br>        拓扑排序</p>
</blockquote>
<h5 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h5><p><img src="/images/%E5%9B%BE%E7%9A%84%E5%BC%95%E4%BE%8B.png" alt="图的引例"></p>
<blockquote>
<p>从陈家村到张家村，怎么走最快呢？怎么修公路使的村村通的花费最少呢？<br><img src="/images/%E5%9C%B0%E9%93%81%E7%BA%BF%E8%B7%AF.png" alt="地铁线路"></p>
</blockquote>
<pre><code>什么是“图”(Graph)
    - 表示“多对多”的关系
    - 包含
        - 一组顶点：通常用V(Vertex)表示顶点集合
        - 一组边：通常用E(Edge)表示边的集合
            - 边是顶点对：(v,w) ∈ E，其中v,w ∈ V    v —— w
            - 有向边&lt;v,w&gt;表示从v指向w的边(单行边)    v ——&gt; w
            - 不考虑重边和自回路   ![重边和自回路](/images/重边和自回路.png)

抽象数据类型定义 ADT
- 类型名称： 图 (Graph)
- 数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成
- 操作集：对于任意图G ∈ Graph，以及v ∈ V，e ∈ E
    - Graph Create(): 建立并返回空图
    - Graph InsertVertex(Graph G, Vertex v): 将v插入G
    - Graph InsertEdge(Graph G, Edge e): 将e插入G
    - void DFS(Graph G, Vertex v): 从顶点v出发深度优先遍历图G
    - void BFS(Graph G, Vertex v): 从顶点v出发广度优先遍历图G
    - void ShortestPath(Graph G, Vertex v, int Dist[]): 计算图G中顶点v到任意其他顶点的最短距离
    - void MST(Graph G): 计算图G的最小生成树
    ……
![无向图有向图](/images/无向图有向图.png)</code></pre><h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h5><blockquote>
<p>怎么在程序中表示一个图</p>
</blockquote>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><blockquote>
<p>邻接矩阵G[N][N]——N个顶点从0到N-1编号<br>    G[i][j] = {  1   若&lt;vi, vj&gt;是G中的边<br>                 0   否则               }<br><img src="/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="邻接矩阵"></p>
</blockquote>
<pre><code>邻接矩阵
    - 问题：对于无向图的存储，怎样可以省一半空间?</code></pre><p><img src="/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%97%A0%E5%90%91%E5%9B%BE.png" alt="邻接矩阵无向图"><br>    邻接矩阵 —— 有什么好处？<br>    - 直观、简单、好理解<br>    - 方便检查任意一对顶点间是否存在边<br>    - 方便找任一顶点的所有“邻接点”（有边直接相连的顶点）<br>    - 方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数为“入度”）<br>        · 无向图：对应行(或列)非0元素的个数<br>        · 有向图：对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度”<br>    邻接矩阵 —— 有什么不好？<br>    - 浪费空间 —— 存稀疏图（点很多而边很少）有大量无效元素<br>        · 对稠密图(特别是完全图)还是很合算的<br>    - 浪费时间 —— 统计稀疏图中一共有多少条边</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// 大纲没有要求，可以看看，有点对图有编码的感觉</span><br><span class="line">/* 图的邻接矩阵表示法 */</span><br><span class="line">#define MaxVertexNum 100  /* 最大顶点数设为100*/</span><br><span class="line">#define INFINITY 65535  /* ∞设为双字节无符号整数的最大值65535*/</span><br><span class="line">typedef int Vertex;  /* 用顶点下标表示顶点，为整型*/</span><br><span class="line">typedef int WeightType;  /* 边的权值设为整型 */ </span><br><span class="line">typedef char DataType;  /*  顶点存储的数据类型设为字符型 */</span><br><span class="line"></span><br><span class="line">/* 边的定义*/</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode &#123;</span><br><span class="line">    Vertex V1, V2; // 有向边&lt;V1, V2&gt;</span><br><span class="line">    WeightType Weight; // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">/*图结点的定义*/</span><br><span class="line">typedef struct GNode *PtoToGNode;</span><br><span class="line">struct GNode &#123;</span><br><span class="line">    int Nv; // 顶点数</span><br><span class="line">    int Ne; // 边数</span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum]; // 邻接矩阵</span><br><span class="line">    DataType Data[MaxVertexNum];  // 存顶点的数据</span><br><span class="line">    // 在很多情况下，顶点无数据，此时Data[]可以不用出现</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode MGraph; // 以邻接矩阵存储的图类型</span><br><span class="line"></span><br><span class="line">MGraph CreateGraph(int VertexNum)&#123;</span><br><span class="line">    // 初始化一个有VertexNum个顶点但没有边的图</span><br><span class="line">    Vertex V, W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = (MGraph)malloc(sizeof(struct GNode)); // 建立图</span><br><span class="line">    Graph -&gt; Nv = VertexNum;</span><br><span class="line">    Graph -&gt; Ne = 0;</span><br><span class="line">    // 初始化邻接矩阵</span><br><span class="line">    // 注意：这里默认顶点编号从0开始，到(Graph -&gt; Nv - 1)</span><br><span class="line">    for(V=0; V &lt; Graph-&gt;Nv, V++)</span><br><span class="line">        for(W=0; W &lt; Graph-&gt;Nv; W++)</span><br><span class="line">            Graph-&gt;G[V][W] = INFNITY;</span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertEdge(MGraph Graph, Edge E)&#123;</span><br><span class="line">    // 插入边&lt;V1, V2&gt;</span><br><span class="line">    Graph -&gt; G[E-&gt;V1][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">    // 若是无向图，还要插入边&lt;V2, V1&gt;</span><br><span class="line">    Graph -&gt; G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MGraph BuildGraph()&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    int Nv, i;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv); // 读入顶点个数</span><br><span class="line">    Graph = CreateGraph(Nv); // 初始化有Nv个顶点 但没有边的图</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne)); // 读入边数</span><br><span class="line">    if( Graph -&gt; Ne != 0)&#123; // 如果右边</span><br><span class="line">        E = (Edge) malloc (sizeof(struct ENode)); // 建立边结点</span><br><span class="line">        // 读入边，格式为“起点 终点 权重”，插入邻接矩阵</span><br><span class="line">        for(i=0; i&lt;Graph-&gt;Ne;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">            // 注意：如果权重不是整型，Weight的读入格式要改</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果顶点有数据的话，读入数据</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        scanf(&quot;%c&quot;, &amp;(Graph-&gt;Data[V]));</span><br><span class="line"></span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><blockquote>
<p>怎么在程序中表示一个图的另一种表示法 —— 邻接表<br>    邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素<br>    <strong>对于网络，结构中要增加权值的域</strong><br><img src="/images/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="邻接表"></p>
</blockquote>
<pre><code>邻接表一定要够稀疏才够合算

邻接表的好处？
-  方便还找任一顶点的所有“邻接点”
- 节约稀疏图的空间
    -   需要N个头只在指针 + 2E个结点（每个结点至少2个域）
- 方便计算任一顶点的“度”？
    - 对无向图：是的
    - 对有向图：只能计算“出度”;需要构造“逆邻接表”（存指向自己的边）来方便计算&quot;入度&quot;
- 方便检查任意一对顶点间是否存在边？
    NO</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// 大纲没有要求，可以看看，有点对图有编码的感觉</span><br><span class="line">// 图的邻接表表示法</span><br><span class="line">#define MaxVertexNum 100 //最大顶点数设为100</span><br><span class="line">typedef int Vertex; // 用顶点下标表示顶点，为整型</span><br><span class="line">typedef int WeightType; // 边的权值设为整型</span><br><span class="line">typedef char DataType; // 顶点存储的数据类型设为字符型</span><br><span class="line"></span><br><span class="line">// 边的定义</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode &#123;</span><br><span class="line">    Vertex V1, V2; // 有向边&lt;V1, V2&gt;</span><br><span class="line">    WeightType Weight; // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode Edge;</span><br><span class="line"></span><br><span class="line">// 邻接点的定义</span><br><span class="line">typedef struct AdjVNode *PtrToAdjVNode;</span><br><span class="line">struct AdjNode&#123;</span><br><span class="line">    Vertex AdjV; // 邻接点下标</span><br><span class="line">    WeightType Weight; // 边权重</span><br><span class="line">    PtrToAdjVNode Next; // 指向下一个邻接点的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 顶点表头结点的定义</span><br><span class="line">typedef struct Vnode&#123;</span><br><span class="line">    PtrToAdjVNode FirstEdge; // 边表有指针</span><br><span class="line">    DataType Data; // 存顶点的数据</span><br><span class="line">    // 注意：很多情况下，顶点无数据，此时Data可以不用出现</span><br><span class="line">&#125; AdjList[MaxVertexNum]; // AdjList是邻接表类型</span><br><span class="line"></span><br><span class="line">// 图结点的定义</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode &#123;</span><br><span class="line">    int Nv; // 顶点数</span><br><span class="line">    int Ne; // 边数</span><br><span class="line">    AdjList G; // 邻接表</span><br><span class="line">&#125;</span><br><span class="line">typedef PtrToGNode LGraph; // 以邻接表方式存储的图类型</span><br><span class="line"></span><br><span class="line">LGraph CreateGraph(int VertexNum)&#123;</span><br><span class="line">    // 初始化一个有VertexNum个顶点但没有边的图</span><br><span class="line">    Vertex V;</span><br><span class="line">    LGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = (LGraph)malloc(sizeof(struct GNode)); // 建立图</span><br><span class="line">    Graph-&gt;Nv = VertexnNum;</span><br><span class="line">    Graph-&gt;Ne = 0;</span><br><span class="line">    // 初始化邻接表头指针</span><br><span class="line">    // 注意：这里默认顶点编号从0</span><br><span class="line">        for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">            Graph-&gt;G[V].FristEdge = NULL;</span><br><span class="line"></span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InsertEdge(Lgraph Graph, Edge E)&#123;</span><br><span class="line">    PtrToAdjVNode NewNode;</span><br><span class="line"></span><br><span class="line">    // 插入边&lt;V1, V2&gt;</span><br><span class="line">    // 为V2建立新的邻接点</span><br><span class="line">    NewNode = (PtrToAdjNode)malloc(sizeof(struct AdjVNode));</span><br><span class="line">    NewNode -&gt; AdjV = E-&gt;V2;</span><br><span class="line">    NewNode -&gt; Weight = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">    // 将V2插入V1的表头</span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FristEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class="line"></span><br><span class="line">    // 若是无向图，还要插入边&lt;V2, V1&gt;</span><br><span class="line">    // 为V1建立新的邻接点</span><br><span class="line">    NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));</span><br><span class="line">    NewNode -&gt; AdjV = E-&gt; V1;</span><br><span class="line">    NewNode -&gt; Weight = E-&gt; Weight;</span><br><span class="line">    // 将V1插入V2的表的头</span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FristEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V2].FristEdge = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LGraph BuildGraph()&#123;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    int Nv, i;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv); // 读入顶点个数</span><br><span class="line">    Graph = CreateGraph(Nv); // 初始化有Nv个顶点但没有边的图</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne)); // 读入边数</span><br><span class="line">    if(Graph-&gt;Ne != 0)&#123; // 如果有边</span><br><span class="line">        E = (Edge)malloc(sizeof(struct ENode)); // 建立边结点</span><br><span class="line">        // 读入边，格式为“起点，终点， 权重”，插入邻接矩阵</span><br><span class="line">        for(i=0; i&lt;Graph-&gt;Ne; i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V2, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">            // 注意：如果权重不是整型，Weight的读入格式要改</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果顶点有数据的话，读入数据</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        scanf(&quot;%c&quot;, &amp;(Graph-&gt;G[V].Data));</span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><h6 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h6><h6 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h6><h5 id="最小生成树-Minimum-Spanning-Tree"><a href="#最小生成树-Minimum-Spanning-Tree" class="headerlink" title="最小生成树 (Minimum Spanning Tree)"></a>最小生成树 (Minimum Spanning Tree)</h5><blockquote>
<p>最小生成树存在 &lt;==&gt; 图连通<br>    - 是一颗树<br>      无回路<br>      |V|个顶点一定有|V|-1条边<br>    - 是生成树<br>      包含全部顶点<br>      |V|-1条边都在图里<br>    - 边的权重和最小</p>
</blockquote>
<pre><code>(向生成树中任加一条边都一定构成回路)</code></pre><h6 id="贪心算法-考纲里没有可以了解一下"><a href="#贪心算法-考纲里没有可以了解一下" class="headerlink" title="贪心算法 (考纲里没有可以了解一下)"></a>贪心算法 (考纲里没有可以了解一下)</h6><blockquote>
</blockquote>
<ul>
<li>什么是“贪”：每一步都要最好的</li>
<li>什么是“好”：权重最小的边</li>
<li>需要约束：<pre><code>- 只能用图里有的边
- 只能正好用掉|V|-1条边
- 不能有回路</code></pre><h6 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h6><blockquote>
<p>让一颗小树长大 – 有点像Dijkstra算法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* 邻接矩阵存储 - Prim最小生成树算法*/</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h6><blockquote>
<p>将森林合并成树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* 邻接表存储 - Kruskal最小生成树算法*/</span><br></pre></td></tr></table></figure>

<h5 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h5><blockquote>
<p>在网络中，求两个不同顶点之间的所有路径中权值之和最小的那条路径<br>    - 这条路径就是两点之间的最短路径(Shortest Path)<br>    - 第一个顶点为源点(Source)<br>    - 最后一个顶点为终点(Destination)</p>
</blockquote>
<pre><code>问题分类：
单源最短路径问题： 从某固定源点出发，求其到所有其他顶点的最短路径
    - (有向)无权图
    - (有向)有权图

多源最短路径问题：求任意两顶点间的最短路径</code></pre><h6 id="BFS-广度优先遍历算法"><a href="#BFS-广度优先遍历算法" class="headerlink" title="BFS 广度优先遍历算法"></a>BFS 广度优先遍历算法</h6><blockquote>
<p>无权图的单源最短路径算法</p>
</blockquote>
<h6 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h6><blockquote>
<p>有权图的单源最短路径算法</p>
</blockquote>
<h6 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h6><blockquote>
<p>多源最短路径算法</p>
</blockquote>
<h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><ul>
<li>AOV：Acitivity On Vertex 网络</li>
<li>DAG：Directed Acyclic Graph 有向无环图</li>
<li>拓扑序：如果图中从v到w有一条有向路径，则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序</li>
<li>获得一个拓扑序的过程就是拓扑排序</li>
<li>AOV如果有合理的拓扑序，则必定是有向无环图Directed Acyclic Graph, DAG</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h5><p>有废话啊，边学边学英语，所以都写上去了，可以简单看看</p>
<blockquote>
<p>Sorting is a very classic problem of reordering items(that can be compared,e.g.integers,floating-point numbers,string,etc) of an array(or a list) in a certain order(increasing, non-decreasing, decreasing,non-increasing,lexicographical,etc.) 排序是一个经典的问题，它以一定的顺序对一个数组(或一个列表)中的项进行重新排序(可以进行比较，例如整数，浮点数，字符串等)<br>(增加，非递减，增加，词典等)。</p>
</blockquote>
<p>There are many different sorting algorithms,each has its own advantages and limitations. 有许多不同的排序算法，么个都有其自身的有点和局限性</p>
<p>Sorting is commonly used as the introductory problem in various Computer Science classes to showcase a range of algorithmic ideas. 排序通常被用作各种计算机科学课程中的介绍性问题，以展示一系列算法思想。</p>
<p>Without loss of generality, we assume that we will sort only integers, not necessarily distinct, in non-decreasing order in this visualization, Try clicking Bubble Sort for a sample animation of sorting the list of 5 jumbled integers(with duplicate) above. 在不是概性的情况下,我们假设在这个可视化中，我们将只按非递减顺序对整数进行排序, 但不一定是明显的，尝试点击Bubble Sort以查看上面排序5个混乱整数(带有重复项)列表的示例动画。</p>
<p>Click ‘Next’ (on the top right)/press ‘Page down’ to advance this e-Lecture slide,use the drop down list/press ‘Space’ to jump to a specific slide,or Click ‘X’ (on the bottom right)/press ‘ESC’ to go to Exploration mode. 点击下一步，在右上角，按下翻页来推进这个电子讲座幻灯片，使用下拉列表/按’空格’跳转到特定幻灯片，或者点击’x’(底部 右键)/按 ESC进入探索模式。</p>
<p>Motivation - interesting CS Ideas 动机-有趣的计算机科学想法<br>Sorting problems has a variety of interesting algorithmic solution that embody many Computer Science ideas:<br>排序问题有许多有趣的算法解决方案，体现了很多计算机科学的想法：</p>
<pre><code>1.Comparison versus non-comparison based strategies, 比较与非比较策略
2.Iterative versus Recursive implementation, 迭代与递归实现
3.Divide-and-Conquer paradigm (this or that), 分而治之范式
4.Best/Worst/Average-case Time Complexity analysis, 最佳/最差/平均时间复杂度分析
5.Randomized Algorithms, etc. 随机算法等</code></pre><p>Motivation - Application 动机 - 应用<br>when a (integar) array A is sorted,many problems involving A become easy (or easier):<br>当(整数)数组A排序时, 涉及A的许多问题变得简单(或更容易):<br>    1. Searching for a specific value v in array A. 在数组A中搜索特定值v<br>    2. Finding the min/max or the k-th smallest/largest value in (static) array A.查找(静态)数组A中的最小/最大/第k个最小/最大值<br>    3. Testing for uniqueness and deleting duplicates in array A. 测试唯一性并删除数组A中的重复项<br>    4. Counting how many time a specific value v appear in array A 计算特定值v在数组A中出现多少次<br>    5. Set intersection/union between array A and another sorted array B. 设置数组A和另一个排序数组B之间的交集/联合<br>    6. Finding a target pair x ∈ A and y ∈ A such that x+y equals to a target z,ect. 寻找一个目标对 x∈A 和 y∈A, 使得x+y等于目标z等。</p>
<pre><code>Discussion：In real-life classes, the instructor may elaborate more on these applications. 讨论：在现实生活中，指导员可以详细阐述这些应用</code></pre><p>Actions 动作<br>There are two actions that you can do in this visualization. 你可以在此可视化中执行两项操作。</p>
<p>2.1 Define Your Own Input 定义你自己的输入</p>
<p>The first action is about defining your own input, an array/a list that is:<br>第一步是关于定义你自己的输入，一个数组/一个列表是：<br>    1. Totally random 完全随机的<br>    2. Random but sorted (in ascending/decreasing order) 随机排序(按升序/降序排列)<br>    3. Random but nearly sorted (in ascending/descending order), or 随机但几乎排序(按升序/降序排列)或<br>    4. Defined solely by yourself. 完全有你自己定义</p>
<p>In Exploration mode, you can experiment with various sorting algorithms provided in this visualization to figure out their best and worst case inputs. 在探索模式下，您可以尝试使用此可视化中提供的各种排序算法来找出最佳和最差情况输入。</p>
<p>2.2 Execute the Selected Sorting Algorithm 执行已选择的排序算法<br>The second action is the most important one: Execute the active sorting algorithm by clicking ‘Sort’ menu and then clicking ‘Go’. 第二个操作是最重要的操作：通过单击”Sort”菜单然后单击”Go”执行主动排序算法</p>
<p>Remember that you can switch active algorithm by clicking the respective abbreviation on the top side of this visualization page. 请记住，您可以通过单击此可视化页面顶部的相应缩写来切换活动算法</p>
<p>Some sorting algorithms have certain additional options.You may toggle the options as you wish before clicking ‘Go’.For example, in Bubble Sort(and Merge Sort), there is an option to also compute the inversion index of the input array(this is an advanced topic). 一些排序算法有一些额外的选项，在点击”开始”之前，您可以根据需要切换选项。例如，在冒泡排序(和归并排序)中，还可以选择计算输入数组的一个反向指数(这是一个高级主题).</p>
<p>3.Visualisation 可视化<br>View the visualisation/animation of the chosen sorting algorithm here. 在此处查看所选排序算法的可视化/动画</p>
<p>Without loss of generality,we only show integers in this visualization and our objective is to sort them from the initial state into ascendig order state.</p>
<p>4.Common Sorting Algorithms</p>
<p>At the top,you will see the list of commonly taught sorting algorithms in Computer Science classes.To activate each algorithm, select the abbreviation of respective algorithm name before clicking “Sorting -&gt; Go” </p>
<p>To facilitate more diversity,we randomize the active algorithm upon each page load.</p>
<p>The first six algorithms are comparsion-based sorting algorithms while the last two are not,We will discuss this idea midway through this e-Lecture.前六个算法是基于比较的排序算法，而后两个则不是，我们将在这节电子课程的中途讨论这一思想.</p>
<p>The middle three algorithms are recursive sorting algorithms while the rest are usually implement iteratively.<br>中间的三种算法是递归排序算法，其余的通常是迭代实现的。</p>
<p>4.1 Abbreviations 缩写<br>To save screen space,we abbreviate algorithm names into three character each: 为了节省屏幕空间，我们将算法名称缩写成三个字符：</p>
<pre><code>1.Comparison-based Sorting Alogrithms: 基于比较的排序算法
    1.BUB - Bubble Sort 冒泡排序
    2.SEL - Selection Sort 选择排序
    3.INS - Insertion Sort 插入排序
    4.MER - Merge Sort(recursive implementation) 归并排序 递归实现
    5.QUI - Quick Sort(recursive implementation) 快速排序 递归实现
    6.R-Q- Random Quick Sort(recursive implementation) 随机快速排序 递归实现
2.Not comparison-based Sorting Algorithms: 不基于比较的排序算法
    1.COU - Counting Sort 计算排序
    2.RAD - Radix Sort 基数排序</code></pre><p>We will discuss three comparison-based sorting algorithms in the next few slides: 在接下来的幻灯片，我们将讨论三种基于比较的排序算法</p>
<pre><code>1.Bubble Sort 冒泡排序
2.Selection Sort 选择排序
3.Insertion Sort 插入排序</code></pre><p>They are called comparison-based as they compare pairs of elements of the array and decide whether to swap them or not. 它们被称为基于比较的，因为他们比较数组的元素对并决定是否交换它们.</p>
<p>These three sorting algorithms are the easiest to implement but also not the most efficient, as they run in O(N^2). 这三种排序算法最容易实现，但不是最有效的，因为它们的算法复杂度是O(N^2).</p>
<h5 id="插入排序，算法基本思想，算法代码及基本的时间复杂度分析"><a href="#插入排序，算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="插入排序，算法基本思想，算法代码及基本的时间复杂度分析"></a>插入排序，算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<p>插入排序顾名思义，就是在排序过程中，把数组的每个元素按照大小关系，插入到前面有序区的对应位置。<br> Insertion sort is similar to how most people arrange a hand of poker cards. 插入排序类似于大多人安排扑克牌的方式<br>1st card: 10♠    10♠<br>2nd card：5♠     5♠ 10♠<br>3rd card：K♠     5♠ 10♠ K♠</p>
</blockquote>
<ol>
<li>Start with one card in your hand</li>
<li>Pick the next card and insert it into its proper sorted order.</li>
<li>Repeat previous step for all cards.</li>
</ol>
<p>Without further ado,let’s try Inserion Sort on the small example array[40,13,20,8].</p>
<p>mark first element as sorted 将第一个元素标记为已排序<br>for each unsorted element X 遍历每个没有排序过的元素<br>    ‘extract’ the element X 提取元素X<br>    for j=lastSortedIndex down to 0   j 从最后一个被排序的位置开始到0进行遍历<br>        if current element j &gt; X  如果当前排序过的元素j &gt; 提取过的元素<br>            move sorted element to the right by 1 将排序过的元素向右移一格<br>        break loop and insert X here. 否则插入提取的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void insertionSort(int a[], int N)&#123;</span><br><span class="line">    for (int i = 1; i &lt; N; ++i)&#123; // O(N)</span><br><span class="line">        int X = a[i]; // X is the item to be insert</span><br><span class="line">        int j = i - 1;</span><br><span class="line">        for(;j &gt;= 0&amp;&amp;a[j]&gt;X;--j) // can be fast or slow</span><br><span class="line">            a[j+1] = a[j]; // make a place for X</span><br><span class="line">        a[j+1] = X; // index j+1 is the insertion point</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The outer loop executes N-1 items, that’s quite clear.</p>
<p>But the number of times the inner-loop is executed depend on the input:<br>    1. In best-case scenario,the array is already sorted and(a[j] &gt; X) is always false So no shifting of data is necessary and the inner loop union runs in O(1)<br>    2. In worst-case scenario, the array is reverse sorted and (a[j] &gt; X) is always true Insertion always occur at the front of the array and the inner loop runs in O(N).</p>
<p>Thus,the best-case time is O(N * 1) = O(N) and the worst-case time is O(N*N) = O(N^2).</p>
<h5 id="希尔排序，算法基本思想，算法代码及基本的时间复杂度分析"><a href="#希尔排序，算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="希尔排序，算法基本思想，算法代码及基本的时间复杂度分析"></a>希尔排序，算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<p>Donald Shell<br>  怎样可以对插入排序算法做出优化呢？</p>
<ul>
<li>在大多数元素已经有序的情况下，插入排序的工作量较小（因为不用频繁的进行比较和交换）</li>
<li>在元素数量较少的情况下，插入排序的工作量较小</li>
</ul>
</blockquote>
<pre><code>我们怎么能让大部分元素有序，或者让元素数量减少呢？
不妨对原始数组进行一些预处理，使得原始数组的大部分元素变得有序，分组排序，以此对数组进行一定的粗略调整</code></pre><h5 id="选择排序，算法基本思想，算法代码及基本的时间复杂度分析"><a href="#选择排序，算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="选择排序，算法基本思想，算法代码及基本的时间复杂度分析"></a>选择排序，算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<p>Selection Sort 选择排序<br>    Given an array of N items and L = 0.Selection Sort will: 给定N个项目和L=0的数组，选择排序将：<br>        1.Find the position X of the smallest item in the range of [L…N-1]，在[L…N-1]范围内找出最小项目X的位置<br>        2.Swap X-th item with the L-th item 用第L项交换第X项<br>        3.Increase the lower-bound L by i and repeat Step 1 until L = N - 2. 将下限L增加1并重复步骤1直到L = N-2<br>    Without further ado, let’s try Selection Sort on the same small example array[29, 10, 14, 37, 13]. 别犹豫，让我们在上面的同一个小例子数组上尝试selection Sort.</p>
</blockquote>
<pre><code>Without loss of generality, we can also implement Selection Sort in reverse: 在不失普遍性的情况下，我们也可以实现反向的选择排序
Find the position of the largest item Y and swap it with the last item.找到最大项目Y的位置并将与其最后一个项目交换。</code></pre><blockquote>
<p>Selection Sort 选择排序<br>repeat (numOfElements - 1) times 重复(元素个数 - 1)次<br>    set the first unsorted element as the minum 把第一个没有排序过的元素设置为最小值<br>    for each of the unsorted elements 遍历每个没有排序过的元素<br>        if element &lt; currentMinimum 如果元素 &lt; 现在的最小值<br>            set element as new minimum 将此元素设置成为新的最小值<br>    swap minimum with first unsorted position 将最小值和第一个没有排序过的位置交换</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void selectionSort(int a[], int N) &#123;</span><br><span class="line">    for (int L=0; L&lt;N-2; ++L) &#123; // O(N)</span><br><span class="line">        int X = min_element(a+L, a+N) - a; // O(N)</span><br><span class="line">        swap(a[X], a[L]); // O(1), X may be equal to L(no actual swap)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Total:O(N^2)</p>
<h5 id="快速排序，算法基本思想，算法代码及基本的时间复杂度分析"><a href="#快速排序，算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="快速排序，算法基本思想，算法代码及基本的时间复杂度分析"></a>快速排序，算法基本思想，算法代码及基本的时间复杂度分析</h5><p>这个排序好难，我看了三份资料最后一份资料看懂了</p>
<p>第一份资料：这个没太看懂</p>
<blockquote>
<p>Quick Sort<br>    Quick Sort is another Divide and Conquer sorting alogrithm (the other one discussed in this visualization page is Merge Sort).快速排序是另一个分而治之的排序算法(另一个在这个可视化的页面中讨论的是归并排序)</p>
</blockquote>
<p>We will see that this deterministic,non randomized version of Quick Sort can have bad time complexity of O(N^2) on adversary input before continuing with the randomized and usable version later.我们将看到，这种确定性的，非随机化的快速排序的版本可能在对手输入中具有O(N^2)的很差的时间复杂度，之后再继续随机化的可用版本。</p>
<p>Divid step: Choose an item p(know as the pivot) 划分步骤: 选择一个项p(为枢轴点)<br>Then partition the items of a[i..j] into three parts: a[i..m-1],a[m],amd a[m+1..j] 然后将a[i..j]的项目分为三个部分:a[i..m-1], a[m], a[m+1..j]<br>a[i..m-1](possibly empty) contains items that are greater than or equal to P. a<a href="可能为空">i..m-1</a>包含小于p的项目<br>a[m] is the pivot p,i.e. index m is the correct position for p in the sorted order of array a. a[m]是枢轴点p,例如：指数m是已排序数组a的排序顺序中p的正确位置。<br>a[m+1..j](possibly empty) contains items that are greater than or equal to p. a<a href="可能为空">m+1..j</a>包含大于或等于p的项目。然后，递归地对这两部分进行排序。<br>Then,recursively sort the two parts. 然后递归地这两部分进行排序</p>
<p>Conquer step: Don’t be surprised…We do nothing:O! 解决步骤：不要惊讶……我们什么都不做！</p>
<p>If you compare this with Merge Sort,you will see that Quick Sort D&amp;C steps are totally opposite with Merge Sort. 如果您对将其与归并排序进行比较，您会发现快速排序的D&amp;C步骤与归并排序完全相反。</p>
<p>第二份资料，指针交换排序我看不懂了就</p>
<p>快速排序是从冒泡排序演变而来的算法，但是比冒泡排序要高效的对，所以叫做快速排序<br>快速排序之所以快速，是因为它使用了分治法。同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的<br>不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一遍，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。这种思路就叫做分治法。</p>
<p>在分治法的思想下，原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可拆分为止。</p>
<p>这样一共需要多少轮？平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是O(nlogn)<br>基准元素的选择，以及元素的移动都是快速排序的核心。</p>
<p>如何选择基准元素？</p>
<p>基准元素的选择</p>
<blockquote>
<p>基准元素，英文pivot，用于在分治过程中以此为中心，把其他元素移动到基准元素的左右两边，那么基准元素如何选择呢？</p>
<ul>
<li>最简单的方式是选择数列的第一个元素<br>  这种选择在大多数情况下是没有问题的。但是假如有一个原本逆序的数列，期望排列成顺序数列，那么会出现什么情况呢？<pre><code>          8 7 6 5 4 3 2 1 
第一轮：**8** 7 6 5 4 3 2 1
|——&gt;    1 7 6 5 4 3 2 **8**</code></pre></li>
</ul>
</blockquote>
<pre><code>第二轮： **1** 7 6 5 4 3 2
|——&gt;    **1** 7 6 5 4 3 2

第三轮： **7** 6 5 4 3 2
|——&gt;     2 6 5 4 3 **7**
……

整个数列并没有被分成一半一半，每一轮仅仅确定了基准元素的位置。这种情况下数列第一个元素要么是最小值，要么是最大值，根本无法发挥分治法的优势。在这种极端情况下，快速排序需要进行N轮，时间复杂度退化成了O(N^2)

我们该如何避免这种情况发生呢？其实很简单，我们可以不选择数列的第一个元素，而是随机选择一个元素作为基准元素。

8 7 6 5 **4** 3 2 1

这样一来，即使在数列完全逆序的情况下，也可以有效地数列分成两部分。

当然，及时是随机选择基准元素，每一次也有极小的几率选到数列的最大值或最小值，同样会影响到分治的效果。

所以，快速排序的平均时间复杂度O(nlogn),最坏情况下的时间复杂度是O(n^2).</code></pre><p>元素的移动</p>
<pre><code>选定了基准元素以后，我们要做的就是把其他元素当中小于基准元素的都移动到基准元素的一边，大于基准元素的都移动到基准元素的另一边。
具体如何实现？有两种方法：
1、挖坑法
2、指针交换法

“挖坑法”
给定的原始数列如下，要求从小到大排序:
    4 7 6 5 3 2 8 1
首先，我们选定基准元素Pivot，并记住这个位置index，这个位置相当于一个“坑”。并且设置两个指针left和right，指向数列的最左和最右两个元素:
         index
Pivot=4    4    7    6    5    3    2    8    1
         left                                right
         接下来，从right指针开始，把指针所指向的元素和基准元素做比较。如果比pivot大，则right指针向左移动；如果比pivot小，则把right所指向的元素填入坑中。

         在当前数列中，1 &lt; 4 ,所以把1填入基准元素所在位置，也就是坑的位置。这时候，元素1本来的位置变成了新的坑，同时left向右移动一位。

                                            index
Pivot=4    1    7    6    5    3    2    8    1
              left                          right
         此时，left左边的区域代表着小于基准元素的区域。

         接下来，我们切换了left指针进行比较。如果left指向的元素小于pivot，则left指针向右移动，如果元素大于pivot，则把left指向的元素填入坑中。

         在当前数列中，7&gt;4, 所以把7填入index的位置，这时候7原本的位置称为了新的坑，同事right向左移动一位。
              index                           
Pivot=4    1    7   6    5    3    2    8    7
              left                     right   
         此时，right右边橙色的区域代表着大于基准元素的区域

         接着按照刚才的思路排序
         8 &gt; 4 ，元素位置不变，right左移
              index                           
Pivot=4    1    7   6    5    3    2    8    7
              left                right 
         2 &lt; 4 , 用2来填坑，left右移，切换到left  
                                 index      
Pivot=4    1    2   6    5    3    2    8    7
                   left           right 
        6 &gt; 4 ，用6来填坑，right左移，切换到right
                  index                   
Pivot=4    1    2   6    5    3    6    8    7
                   left     right       
        3 &lt; 4，用3来填坑，left右移，切换到left
                            index      
Pivot=4    1    2   3    5    3    6    8    7
                        left right       
        5 &gt; 4，用5来填坑，right右移，这时候left和right重合在同一个位置
                        index        
Pivot=4    1    2   3    5    5    6    8    7
                        right 
                        left      

        这时候，把之前的pivot元素，也就是4放到index的位置，此时数列左边的元素都小于4，数列右边的元素都大于4，这一轮交换终告结束。

        递归，其实这个还没完，最后的6  8 7 是不对的，

        除了挖坑法以外，要实现元素的移动也可以利用指针交换法</code></pre><p>指针交换法</p>
<pre><code>给定原始数列如下，要求从小到大排序：
4 7 6 5 3 2 8 1

开局和挖坑法相似，我们首先选定基准元素Pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素：

    Pivot = 4    4   7   6   5   3    2    8    1
               left                           right
接下来是第一次循环，从right指针开始，把指针所指向的元素和基准元素做比较。如果大于等于pivot，则指针向左移动，如果小于pivot，则right指针停止移动，切换到了left指针</code></pre><p>第三份资料：浙大的老师 哇终于，看这份资料我理解了，快速动画图示说明理解，看<a href="http://www.feemic.cn/mooc/icourse163/1002654021?type=hot#myTab" target="_blank" rel="noopener">http://www.feemic.cn/mooc/icourse163/1002654021?type=hot#myTab</a> 10.1.3 子集划分</p>
<p>算法概述：</p>
<pre><code>分而治之：伪码描述
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Quicksort(ElementType A[], int N)&#123;</span><br><span class="line">    if (N &lt; 2) return; // 递归跳出的条件 只有一个元素，递归就不用继续了</span><br><span class="line">    pivot = 从A[]中选一个主元; </span><br><span class="line">    将S= &#123;A[] \ pivot&#125; 分成2个独立子集:</span><br><span class="line">        A1 = &#123; a ∈ S | a&lt;= pivot&#125; 和</span><br><span class="line">        A2 = &#123; a ∈ S | a&gt;= pivot&#125;;</span><br><span class="line">    A[] = Quicksort(A1,N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2,N2); // 递归</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

// ?主元怎么选
// ?子集怎么分
// 什么是快速排序算法的最好情况？
    每次正好中分 -&gt; T(N) = O(NlogN)</code></pre><p>选主元</p>
<ul>
<li><p>令pivot = A[0]?</p>
<pre><code>1 2 3 4 5 6 …… N-1 N
  2 3 4 5 6 …… N-1 N
    3 4 5 6 …… N-1 N</code></pre><p>  T(N) = O(N) + T(N-1)</p>
<pre><code>= O(N) + O(N-1) + T(N-2)
= O(N) + O(N-1) + …… + O(1)
= O(N^2)</code></pre></li>
<li><p>随机取pivot?rand()函数很废时间</p>
</li>
<li><p>取头、中、尾的中位数<br>  例如 8、12、3的中位数就是8<br>  测试一下pivot不同的取法对运行速度有多大影响</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ElementType Median3(ElementType A[], int Left, int Right)&#123; // 取三数中位数</span><br><span class="line">    int Center = (Left + Right) / 2;</span><br><span class="line">    if(A[Left] &gt; A[Center])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Center]);</span><br><span class="line">    if(A[Left] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Right]);</span><br><span class="line">    if(A[Center] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Center], &amp;A[Right]);</span><br><span class="line"></span><br><span class="line">// A[Left] &lt;= A[Center] &lt;= A[Right]</span><br><span class="line">Swap(&amp;A[Center], &amp;A[Right - 1]) ;// 将pivot藏到右边</span><br><span class="line">// 只需要考虑A[Left+1]……A[Right-2]</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>子集划分</p>
<pre><code>8   1   4   9   0   3   5   2   7   6

如果相等交换 O(NlogN)
不交换的时间复杂度O(N^2)</code></pre><p>根据时间复杂度来分析，还是遇到相等元素还是交换吧</p>
<p>小规模数据的处理<br>    快速排序的问题：<br>        - 用递归……【会占用额外的系统堆栈的空间】<br>        - 对小规模的数据(例如N不到100)可能还不如插入顺序快<br>    解决方案：<br>        - 当递归的数据规模充分小，则停止递归，直接调用简单排序(例如插入排序)<br>        - 大规模数据用递归<br>        - 在程序中定义一个Cutoff的阈值，比较不同的Cutoff对效率的影响</p>
<p>算法实现<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序</span><br><span class="line">ElementType Median3(ElementType A[], int Left, int Right)&#123;</span><br><span class="line">    int Center = (Left + Right) /2;</span><br><span class="line">    if(A[ left ] &gt; A[ Center ]) Swap(&amp;A[ Left ], &amp;A[ Center ]);</span><br><span class="line">    if(A[ left ] &gt; A[ Right ]) Swap(&amp;A[ Left ], &amp;A[ Right ]);</span><br><span class="line">    if(A[ Center ] &gt; A[ Right ]) Swap(&amp;A[ Center ], &amp;A[ Right ]);</span><br><span class="line">    // 此时A[ Left ] &lt; A[ Center ] &lt; A[ Right ]</span><br><span class="line">    Swap(&amp;A[ Center ], &amp;A[ Right-1 ]); // 将基准pivot藏到右边</span><br><span class="line">    // 只需要考虑A[Left + 1]...A[Right -2]</span><br><span class="line">    return A[Right - 1]; // 返回基准Pivot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Qsort(ElementType A[], int Left, int Right)&#123;</span><br><span class="line">    // 核心递归函数</span><br><span class="line">    int Pivot, Cutoff, Low, High;</span><br><span class="line">    if( Cutoff &lt;= Right - Left)&#123; // 阈值，如果序列元素充分多，做快速排序</span><br><span class="line">        Pivot = Median3(A, Left, Right); // 选主元 选基准</span><br><span class="line">        Low = Left; High = Right - 1; // 划分子集</span><br><span class="line">        while (1)&#123; // 将序列中比基准小的移动到基准的左边，大的移到右边</span><br><span class="line">            while (A[ ++Low ] &lt; Pivot) &#123; &#125;</span><br><span class="line">            while (A[ --Right ] &gt; Pivot) &#123; &#125;</span><br><span class="line">            if(Low &lt; High) Swap(&amp;A[Low], &amp;A[High]);</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 然后把pivot放到正确的位置,将基准换到正确的位置</span><br><span class="line">        Swap(&amp;A[Low], &amp;A[Right-1]); // 把藏到Right-1 上的主元换到A[i]上去</span><br><span class="line">        // 递归排序自集 主元在i的位置上</span><br><span class="line">        Qsort(A, Left, Low-1); // 递归解决左半子集</span><br><span class="line">        Qsort(A, Low+1, Right); // 递归解决右半子集</span><br><span class="line">    &#125; else &#123; // 否则做插入排序 数据太少用简单排序</span><br><span class="line">        Insertion_Sort(A+Lfet, Right-left+1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用一个壳套住 </span><br><span class="line">void QuickSort(ElementType A[], int N)</span><br><span class="line">&#123; // 统一接口</span><br><span class="line">    Qsort(A, 0, N-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="合并排序，算法基本思想，算法代码及基本的时间复杂度分析"><a href="#合并排序，算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="合并排序，算法基本思想，算法代码及基本的时间复杂度分析"></a>合并排序，算法基本思想，算法代码及基本的时间复杂度分析</h5><p>Merge Sort</p>
<blockquote>
<p>Given an array of N items, Merge Sort will: 给定一个N个项目的数组，归并排序将：<br>    1.Merge each pair od individual element (which is by default, sorted)into sorted arrays od 2 elements. 将每对单个元素(默认情况下，已排序)归并为2个元素的有序数组<br>    2.Merge each pair of sorted arrays of 2 elements into sorted arrays of 4 elements,Repeat the process…, 将2个元素的每对有序数组归并成4个元素的有序数组,重复这个过程……<br>    3.Final Step:Merge 2 sorted arrays of N/2 elements (for simplicity of this discussion, we assume that N is even) to obtain a fully sorted array of N elements. 最后一步：归并2个N/2元素的排序数组(为了简化讨论，我们假设N是偶数)以获得完全排序的N个元素数组。</p>
</blockquote>
<p>This is just the general idea and we need a few more details before we can discuss the true form of Merge Sort. 这只是一般的想法，在我们可以讨论归并排序的真正形式之前，我们需要更多的细节。</p>
<p>10.1 Important Subroutine,O(N) Merge 重要的子程序，O(N)归并</p>
<p>We will dissect this Merge Sort algorithm by first discussing its most important subroutine: The O(N) merge.我们首先讨论归并排序算法的最重要的子程序：O(N)归并，然后解析这个归并排序算法</p>
<p>Given two sorted array.A and B,of size N1 and N2, we can efficiently merge them into one large combined sorted array of size N = N1 + N2, in O(N) time. 给定两个大小为N1和N2的排序数组A和B，我们可以在O(N)时间内将它们有效地归并成一个大小为N = N1 + N2的组合排序数组</p>
<p>This is achieved by simply comparing the front of the two arrays and take the smaller of the two at all times.However, this simple but fast O(N) merge sub-routine will need additional array to do this merging correctly.See the next slide. 这是通过简单地比较两个阵列的前面并始终取两个中较小的一个来实现的，但是这个简单但快速的O(N)合并子例程将需要额外的数组来正确地进行合并。</p>
<p>10-2 Merge Suborutine C++ Implementation 归并子程序C++实现方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void merge(int a[], int low, int mid, int high)&#123;</span><br><span class="line">    // subarray1 = a[low..mid], subarray2 = a[mid+1, high], both sorted</span><br><span class="line">    int N = high - low + 1;</span><br><span class="line">    int b[N];// discuss: why do we need a temporary array b  讨论：为什么我们需要一个临时数组b</span><br><span class="line">    int left = low, right = mid + 1, bIdx = 0;</span><br><span class="line">    while (left &lt;= mid &amp;&amp; right &lt;= high) // the mergeing</span><br><span class="line">        b[bIdx++] = (a[left] &lt;= a[right]) ? a[left++] : a[right++];</span><br><span class="line">    while (left &lt;= mid) b[bIdx++] = a[left++]; // leftover, if any</span><br><span class="line">    while (right &lt;= high) b[bIdx++] = a[right++]; // leftover, if any</span><br><span class="line">    for(int k=0; k&lt;N; k++) a[low+k] = b[k]; // copy back 在拷贝回去</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Try Merge Sort on the example array[1,5,19,20,2,11,15,17] that have its first half already sorted [1,5,19,20] and its second half also already sorted [2,11,15,17]. Concentrate on the last merge of the Merge Sort algorithm.在示例数组[1,5,19,20,2,11,15,17]上尝试Merge Sort，其前半部分已经排序[1,5,19,20],其下半部分也已经排序[2,11,15,17]。专注于合并排序算法的最后一次合并。</p>
<p>10-3 Divide and Conquer Paradigm 分而治之的范式<br>Before we continue,let’s talk about Divide and Conquer(abbreviated as D&amp;C), a powerful problem solving paradigm. 在我们继续之前，让我们先谈谈分而治之(Divide and Conquer, 缩写为D&amp;C), 这是一个强大的解决问题的范例。</p>
<p>Divide and Conquer algorithm solves (certain kind of) problem - like our sorting problem - in the following steps: 分而治之算法通过以下步骤解决(某种类型的)问题-比如我们的排序问题：<br>    1. Divide step: Divide the large, original problem into smaller sub-problems and recursively solve the samller sub-problems, 划分步骤： 将大的原始问题划分成较小的子问题并递归地解决较小的子问题,<br>    2. Conquer step: Combine the results of the smaller sub-problems to produce the result of the larger,original problem. 解决步骤：结合较小的子问题的结果来产生较大的原始问题的结果。</p>
<p>10-4 Merge Sort as a D&amp;C Algorithm 归并排序是分而治之的算法</p>
<p>Merge Sort is a Divide and Conquer sorting algorithm. 归并排序是分而治之的排序算法</p>
<p>The divide step is simple: Divide the current array into two halves (perfectly equal if N is even or one side is slightly greater by one element if N is odd) and then recursively sort the two halves. 划分很简单：将当前数组分成两半(如果N是偶数，则将其完全平等，或者如果N是奇数，则一边稍大于一个元素), 然后递归地对这两半进行排序.</p>
<p>The conquer step is the one that does the most work: Merge the two (sorted) halves to form a sorted array,using the merge sub-routine discussed earlier. 解决步骤是最有效的工作：使用前面讨论的，归并子例合并两个(排序)半部分以形成一个有序数组.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void mergeSort(int a[], int low, int high) &#123;</span><br><span class="line">    // the array to be sorted is a[low..high]</span><br><span class="line">    if(low &lt; high) &#123; // based case; low &gt;= high(0 or 1 item)</span><br><span class="line">        int mid = (low + high) / 2;</span><br><span class="line">        mergeSort(a, low, mid); // divide into two halves</span><br><span class="line">        mergeSort(a, mid+1, high); // then recursively sort them</span><br><span class="line">        merge(a, low, mid, high); // conquer: the merge subroutine</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10-6 Demonstration 示范</p>
<p>Please try Merge Sort on the example array [7,2,6,3,8,4,5] to see more details. 请在示例数组[7,2,6,3,8,4,5]上尝试Merge Sort以查看更多详细信息.</p>
<p>Contrary to what many other CS printed textbooks usually show (as textbooks are static), the actual execution of Merge Sort does not split to two subarrays level by level, but it will recursively sort the left subarray first before dealing with the right subarray. 与许多其他CS打印的教科书通常显示的一样(因为教科书是静态的),合并排序的实际执行不会一层一层地分成两个子数组，但是它会在处理正确的子数组之前递归调地排序左边的子数组。</p>
<p>That’s it, on example array[7,2,6,3,8,4,5], it will recurse to [7,2,6,3], then [7,2],then [7](a single element, sorted by default), backtrack,recurse to <a href="sorted">2</a>, backtrack, then finally merge[7,2] into [2,7],before it continue processing [6,3] and so on. 就是这样，在示例数组{7,2,6,3,8,4,5}上，它将缓存到{7,2,6,3}，然后是{7,2}，然后是{7}(单个元素，默认排序)，回溯，递归到{2}(排序)，回溯，然后在继续处理{6,3}等等之前，最终将{7,2}合并{2,7}中.</p>
<p>10-7 Merge Sort: Analysis Part 1 归并排序:第一部分 分析<br>In Merge Sort, the bulk of work is doen in the conquer/merge step as the divide step does not really do anything (treated as O(1)). 在归并排序中，大部分工作是在解决/归并的步骤中完成的，因为分解步骤并没有真正执行任何操作(视为O(1))</p>
<p>When we call merge(a, low, mid, high), we process k = (high - low + 1) items.当我们归并a(a, low, mid, high)时，我们在处理k=(high - low +1)项.<br>There will be at most k-1 comparsons. 最多会有k-1个比较</p>
<p>There are k moves from original array a to temporary array b and other k moves back.In total, number of operations inside merge sub-routine is &lt; 3K-1 = O(k).从原始数组a到临时数组b有k个移动，而另一个k移回。总的来说，归并子例程内操作次数&lt;3k-1 = O(k).</p>
<p>The important question is how many times this merge sub-routine is called? 重要的问题是这个归并子程序被调用了多少次？</p>
<p>10-8 Merge Sort: Analysis Part 2 归并排序:第二部分 分析</p>
<p><img src="/images/Merge_Sort.png" alt="归并排序算法分析"></p>
<p>10-9 Merge Sort：Analysis Part 3 归并排序:第三部分 分析<br>Level 1: 2^0=1 calls to merge() with N/2^1 items each, O(2^0 * 2 * N/2^1) = O(N)<br>Level 2: 2^1=2 calls to merge() with N/2^2 items each, O(2^1 * 2 * N/2^2) = O(N)<br>Level 3: 2^2=4 calls to merge() with N/2^3 items each, O(2^2 * 2 * N/2^3) = O(N)<br>…<br>Level(logN): 2^(logN-1)(or N/2) calls to merge() with N/2^logN(or 1) item each, O(N)</p>
<p>There are logN levels and in each level, we perform O(N) work,thus the overall time complexity is O(NlogN).We will later see that this is an optimal(comparsion-based) sorting algorithm,i.e we cannont do better than this.这是一种最佳(基于比较)的排序算法，即我们无法做的比这更好.</p>
<p>10-10 Pros and Cons 优缺点<br>The most important good part of Merge Sort is its O(NlogN) performance gurantee, regardless of the original ordering of the input.That’s it,there is no adversary test case that can make Merge Sort runs longer than O(NlogN) for any array of N elements. 无论输入的原始顺序如何，归并排序中最重要的部分是其O(NlogN)性能保证。就这样，没有任何敌手测试用例可以使归并排序对于任何N个元素数组运行比O(NlogN)更长的时间。</p>
<p>Merge Sort is therefore very suitable to sort extremely large number of inputs as O(NlogN) grows much slower than the O(N^2) sorting algorithms<br>that we have discussed earlier.因此，归并排序非常适合排序非常大量的输入，因为O(NlogN)比前面讨论的O(N^2)排序算法增长的慢的多。</p>
<p>Merge Sort is also a stable sort algorithm.Discussion: Why? 归并排序也是一个稳定的排序算法，讨论：为什么</p>
<p>There are however,several not-so-good parts of Merge Sort.First, it is actually not easy to implement from scratch (but we don’t have to).Second,it requires additional O(N) storage during merging operation,thus not really memory efficient and not in-place.Btw, if you are interested to see what have been done to address these (classic) Merge Sort not-so-good parts, you can read this. 然而，归并排序有几个不太好的部分。首先，从零开始实施起来并不容易(但我们不必这么做)。其次它在归并操作期间需要额外的O(N)的存储，因此不是真正的存储效率，顺便说一句，如果你有兴趣看看为了解决这些经典归并排序不那么好的部分做了什么，可以阅读一下<a href="https://en.wikipedia.org/wiki/Merge_sort#Variants" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort#Variants</a></p>
<h5 id="基数排序，算法基本思想，算法代码及基本的时间复杂度分析"><a href="#基数排序，算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="基数排序，算法基本思想，算法代码及基本的时间复杂度分析"></a>基数排序，算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<p>基数排序，非比较排序，是桶排序的一种，多关键字排序。可查看基数排序的动画演示：<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">https://visualgo.net/zh/sorting</a><br>Radix Sort<br>    Assumption: If the items to be sorted are integers with large range but of few digits,we can combine Counting Sort idea with Radix Sort to achieve the linear time complexity.假设：如果要排序的项目是大范围但小数位的整数，我们可以将计数排序Counting Sort思想与Radix Sort结合起来，以实现线性时间复杂度</p>
</blockquote>
<pre><code>In Radix Sort, we treat each item to be sorted as a string of w digits(we pad integars that have less than w digits with leading zeros if necessary).在基数排序中，我们将每个项目排序为一个w数字串(如果需要，我们填充小于w数字的前几个零的整数).

For the least significant(rightmost) digit to the most significant digit(leftmost), we pass through the N items and put them according to the active digit into 10 Queues(one for each digit[0..9]),which is like a modified Counting Sort as this one preserves stability. Then we re-concentrate the groups again for subaequent iteration.对于最低有效位(最右边)到最高有效位(最左边)，我们通过N个项目并将它们按照活动数字放到10个队列中(每个数字[0..9]),就好像一个修改的计数排序，因为这保留了稳定性。然后我们再次重新连接组，以便进行后续迭代。

Try Radix Sort on the example array above for clearer explantation. 请尝试上面示例数组Radix Sort来了解更清晰的解释。

Notice that we only perform O(w*(N+k)) iterations. In the example,w=4 and k=10. 请注意，我们只执行了O(w*(N+k))次迭代。在这个例子中，w=4， k10

create 10 buckets (queues) for each digit (0 to 9) 分别给每个位数(0到9)创建10个桶
for each digit placing 遍历每个数位
    for each element in list 遍历数列中的每个元素
        move element into respective bucket 将元素移至相应的桶中
    for each bucket, starting from smallest digit 在每个桶中从最小的数位开始
        while bucket is non-empty 当桶不是空的
            restore elemnt to list 将元素恢复至数列中



例子引入：
    假设我们有N=10个整数，每个整数的值在0到999之间(于是有M=1000个不同的值)。还有可能在线性时间内排序么？

    输入序列： 64，8， 216， 512， 27， 729， 0， 1， 343， 125
    用&quot;次位优先&quot;(Least Significant Digit) 这里的次位就是个位

    基数 10 ，我们就先建立10个桶

    Bucket  0   1   2    3    4    5    6     7    8    9
    Pass 1  0   1  512  343   64  125  216   27    8    729   个位次序排序
    Pass 2  0  512 125        343      64                     十位次序排序
            1  216  27
            8      729

    Pass 3  0  125  216  343       512       729              百位次序排序
            1
            8
        27
        64

    整个次位优先的算法时间复杂度是多少？T = O(P(N+B))

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">// 基数排序-次位优先</span><br><span class="line"></span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"></span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line"></span><br><span class="line">int GetDigit (int X, int D)</span><br><span class="line">&#123;</span><br><span class="line">    /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line"></span><br><span class="line">    for( i=1; i&lt;=D; i++)&#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LSDRadixSort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    /* 基数排序 - 次位优先 */</span><br><span class="line">    int D, Di, i;</span><br><span class="line">    Bucket B;</span><br><span class="line">    PtrToNode, tmp, p, List = Null;</span><br><span class="line"></span><br><span class="line">    for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">        B[i].head = B[i].tail = NULL;</span><br><span class="line">    for (i=0; i&lt;N; i++)&#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">        tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">        tmp-&gt; key = A[i];</span><br><span class="line">        tmp-&gt; next = List;</span><br><span class="line">        List = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 下面开始排序 */</span><br><span class="line">    for(D=1; D&lt;=MaxDigit; D++)&#123; /*对数据的每一位循环处理*/</span><br><span class="line">        /* 下面是分配过程 */</span><br><span class="line">        p = List;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            Di = GetDigit(p-&gt;key, D); /* 获得当前元素的位数字*/</span><br><span class="line">            /* 从List中摘除*/</span><br><span class="line">            tmp = p; p = p-&gt;next;</span><br><span class="line">            /* 插入B[Di]号桶尾*/</span><br><span class="line">            tmp-&gt;next = NULL;</span><br><span class="line">            if(B[Di].head == NULL)</span><br><span class="line">                B[Di].head = B[Di].tail = tmp;</span><br><span class="line">            else &#123;</span><br><span class="line">                B[Di].tail-&gt;next = tmp;</span><br><span class="line">                B[Di].tail = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* 下面是收集的过程*/</span><br><span class="line">        List = NULL;</span><br><span class="line">        for(Di=Radix-1; Di&gt;=0; Di--) &#123; /* 将每个桶的元素顺序收集入List*/</span><br><span class="line">            if(B[Di].head) &#123; /* 如果桶不为空 */</span><br><span class="line">                /* 整桶插入List表头 */</span><br><span class="line">                B[Di].tail-&gt;next = List;</span><br><span class="line">                List = B[Di].head;</span><br><span class="line">                B[Di].head = B[Di].tail = BULL; /* 清空桶 */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 将List倒入A[]并释放空间*/</span><br><span class="line">    for(i=0; i&lt;N; i++)&#123;</span><br><span class="line">        tmp = List;</span><br><span class="line">        List = List -&gt; next;</span><br><span class="line">        A[i] = tmp-&gt;key;</span><br><span class="line">        free(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* 基数排序 - 主位优先 */</span><br><span class="line"></span><br><span class="line">/* 假设元素最多有MaxDigit个关键字， 基数全是同样的Radix */</span><br><span class="line"></span><br><span class="line">#define MaxDigit 4；</span><br><span class="line">#define Radix 10;</span><br><span class="line"></span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line"></span><br><span class="line">int GetDigit (int X,int D)&#123;</span><br><span class="line">    /* 默认次位D=1， 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line"></span><br><span class="line">    for(i=1; i&lt;=D; i++)&#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MSD(ElementType A[], int L, int R, int D)&#123;</span><br><span class="line">    /* 核心递归函数：对A[L]...A[R]的第D位数进行排序 */</span><br><span class="line">    int Di, i, j;</span><br><span class="line">    Bucket B;</span><br><span class="line">    PtrToNode tmp, p, List = NULL;</span><br><span class="line">    if(D==0) return; /* 递归终止条件 */</span><br><span class="line"></span><br><span class="line">    for()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="第二部分-软件工程"><a href="#第二部分-软件工程" class="headerlink" title="第二部分 软件工程"></a>第二部分 软件工程</h3><h4 id="一、软件过程"><a href="#一、软件过程" class="headerlink" title="一、软件过程"></a>一、软件过程</h4><h5 id="软件过程的概念；"><a href="#软件过程的概念；" class="headerlink" title="软件过程的概念；"></a>软件过程的概念；</h5><blockquote>
<p>  软件工程过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。<br>    在完成开发任务时必须要进行一些开发活动，并且使用适当的资源（人员、时间、计算机硬件、软件工具等），在过程结束时将输入（如软件需求）转化为输出（如软件产品），因此ISO9000把过程定义为“把输入传化为输出的一组彼此相关的资源和活动”。过程定义了运用方法的顺序、应该交付的文档资料、为保证软件质量和协调变化所需要采取的管理措施，以及标志软件开发各个阶段任务完成的里程碑。为获得高质量的软件产品，软件过程必须科学、合理。</p>
</blockquote>
<pre><code>讲述在软件生命周期的过程中应该完成的基本任务，并介绍各种常用的过程模型。</code></pre><h5 id="经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）"><a href="#经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）" class="headerlink" title="经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）"></a>经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）</h5><h6 id="瀑布模型-waterfull-model"><a href="#瀑布模型-waterfull-model" class="headerlink" title="瀑布模型 waterfull model"></a>瀑布模型 waterfull model</h6><blockquote>
<p>瀑布模型一直是唯一被广泛采用的生命周期模型。现在它仍是软件工程中应用最广泛的过程模型。<br>    收集需求<br>        |<br>        分析<br>            |<br>            设计<br>                |<br>                编码<br>                    |<br>                    测试<br>                        |<br>                        维护<br>    按照传统的瀑布模型来开发软件，有如下几个特点：<br>    1、阶段间具有顺序性和依赖性<br>    这个特点有两重含义：<br>        - 必须等前一阶段的工作完成之后，才能开始后一阶段的工作<br>        - 前一阶段的输出文档就是后一阶段的输入文档。<br>            因此只有前一个阶段的输出文档正确，后一阶段的工作才能获得正确的结果 。<br>            但是，万一在生命周期某一阶段发现了问题，很可能需要追溯到在它之前的一些阶段，必要时还要修改已经完成的文档。<br>            然而，在生命周期后期改正早期阶段造成的问题，需要付出更高的代价，<br>    2、推迟实现的观点<br>        实践表明，对于规模较大的软件项目来说，往往编码开始开始的越早最终完成开发工作所需要的时间反而越长。这是因为，前面阶段的工作没做或做得不扎实，过早地考虑进行程序实现，往往导致大量返工，有时甚至发生无法弥补的问题，带来灾难性后果。</p>
</blockquote>
<pre><code>    瀑布模型在编码之前设置了系统分析和系统设计的各个阶段，分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现。

    清楚地区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想。
3、质量保证的观点
    为了保证所开发软件的质量，在瀑布模型的每个阶段都要坚持两个重要做法，
    - 每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。完成准确合格文档不仅是软件开发时期各类人员之间相互通信的媒介，也是运行时期对软件进行 维护的重要依据
    - 每个阶段结束 都要对所完成的 文档进行评审，以便尽早发现问题，改正错误。事实上，越是早期阶段犯下的错误，暴露出来的时间就越晚，排除故障改正 错误所需付出的代价也越高。因此，及时审查，是保证 软件质量，降低软件成本的重要措施。

    传统的瀑布模型过于理想化，事实上人在工作过程中不可能不犯错误。在设计阶段可能发现规格说明文档中的错误，而设计上的缺陷或错误可能在实现过程中显现出来，在综合测试阶段将发现需求分析/设计或编码阶段的许多错误。因此，实际的瀑布模型时带“反馈环”的。

    当在后面阶段发现前面阶段的错误时，需要沿图中左侧的反馈线返回前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务</code></pre><h6 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h6><blockquote>
<p>增量模型也称为渐增模型，使用增量模型开发软件时，把软件产品作为一系列增量构件来设计、编码、集成和测试。<br>    每个构件由多个相互作用的模块构成，并且能够完成特定的功能。<br>        使用增量模型时：<br>            第1个增量构件往往实现软件的基本需求，提供最核心的功能。<br>            （如在使用增量模型开发字处理软件时，第一个增量构件可能提供基本的文件管理、编辑、和文档生成功能）<br>            第2个增量构件提供更完善的编辑和文档生成功能时<br>            第3个增量构件实现拼写和语法检查功能<br>            第4个增量构件完成高级的页面排版功能。<br>        把软件产品分解成增量构件时，应该使构件的规模适中，规模过大或过小都不好。<br>        分解时唯一必须遵守的约束条件是：当把新构件集成到现有软件中时，所形成的产品必须是可测试的。<br>            分析-》设计-》编码 -》测试</p>
</blockquote>
<pre><code>增量模型分批地逐步向用户提交产品，每次提交一个满足用户需求子集的可运行的产品。整个产品被分解成许多个增量构件，开发人员一个构件接一个构件地向用户提交产品。每次用户都得到一个满足部分需求的可运行的产品，直到最后一次得到满足全部需求的完整产品。

优点：
- 能在较短时间内向用户提交完成一些有用的工作的产品
- 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击

使用增量模型的困难时，在把每个新的增量构件集成到现有的软件体系结构中时，必须不破坏原来已经开发出的产品。
此外，必须把软件的体系设计得便于按这种方式进行扩充，向现有产品中加入新构件过程必须简单、方便。
也就是说，软件体系结构必须时开放的。
从长远观点看，具有开发结构的软件拥有真正的优势，这种软件的可维护性明显好于封闭结构的软件。
尽管采用增量模型比采用瀑布模型和快速原型模型需要更精心的设计，但在设计阶段多付出的劳动将在维护阶段获得回报。

事实上，使用增量模型时开发软件和扩充软件功能（完善性维护）并没有本质区别，都是向现有产品加入新构件的过程。
从某种意义上说，增量模型本身时自相矛盾的。它一方面要求开发人员把软件看作一个整体，另一方面又要求开发人员把软件看作构件序列，每个构件本质上都独立与另一个构件。除非开发人员有足够的技术 能力协调好这一明显的矛盾，否则用增量模型开发出的产品可能并不令人满意。</code></pre><h6 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h6><h6 id="统一过程模型"><a href="#统一过程模型" class="headerlink" title="统一过程模型"></a>统一过程模型</h6><h5 id="过程评估与CMM-CMMI的基本概念"><a href="#过程评估与CMM-CMMI的基本概念" class="headerlink" title="过程评估与CMM/CMMI的基本概念"></a>过程评估与CMM/CMMI的基本概念</h5><h5 id="敏捷宣言与敏捷过程的特点"><a href="#敏捷宣言与敏捷过程的特点" class="headerlink" title="敏捷宣言与敏捷过程的特点"></a>敏捷宣言与敏捷过程的特点</h5>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NOTE/" rel="tag"># NOTE</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/13/linux/" rel="next" title="linux$">
                <i class="fa fa-chevron-left"></i> linux$
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/16/python/" rel="prev" title="python">
                python <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/bekjae.jpg" alt="KOKI HOO">
            
              <p class="site-author-name" itemprop="name">KOKI HOO</p>
              <p class="site-description motion-element" itemprop="description">PEACE&LOVE</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一部分-数据结构与算法"><span class="nav-number">1.</span> <span class="nav-text">第一部分 数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、栈-Stack-、队列-Queue-和向量-Vector"><span class="nav-number">1.1.</span> <span class="nav-text">一、栈(Stack)、队列(Queue)和向量(Vector)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单链表-Linked-Lists"><span class="nav-number">1.1.1.</span> <span class="nav-text">单链表 Linked Lists</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双向链表-Doubly-Linked-List"><span class="nav-number">1.1.2.</span> <span class="nav-text">双向链表 Doubly Linked List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#循环-环形-链表-Circular-Linked-List"><span class="nav-number">1.1.3.</span> <span class="nav-text">循环(环形)链表 Circular Linked List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#带哨兵结点的链表"><span class="nav-number">1.1.4.</span> <span class="nav-text">带哨兵结点的链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈的基本概念和性质-栈ADT及其顺序、链表实现"><span class="nav-number">1.1.5.</span> <span class="nav-text">栈的基本概念和性质,栈ADT及其顺序、链表实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#栈的基本概念和性质"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">栈的基本概念和性质</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#栈ADT"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">栈ADT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#栈的顺序存储实现"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">栈的顺序存储实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#栈的链式存储实现"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">栈的链式存储实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈的应用；Stack-Application"><span class="nav-number">1.1.6.</span> <span class="nav-text">栈的应用；Stack Application</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈与递归"><span class="nav-number">1.1.7.</span> <span class="nav-text">栈与递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#队列的基本概念和性质-队列ADT及其顺序、链表实现"><span class="nav-number">1.1.8.</span> <span class="nav-text">队列的基本概念和性质,队列ADT及其顺序、链表实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#队列的基本概念和性质"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">队列的基本概念和性质</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#队列ADT"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">队列ADT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#队列顺序、链表实现"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">队列顺序、链表实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#队列的应用"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">队列的应用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#向量的基本概念和性质-向量ADT及其数组、链表实现"><span class="nav-number">1.1.9.</span> <span class="nav-text">向量的基本概念和性质,向量ADT及其数组、链表实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、树"><span class="nav-number">1.2.</span> <span class="nav-text">二、树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#树的基本概念和术语"><span class="nav-number">1.2.1.</span> <span class="nav-text">树的基本概念和术语</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的前序、中序、后序、层次遍历"><span class="nav-number">1.2.2.</span> <span class="nav-text">树的前序、中序、后序、层次遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二叉树及其性质"><span class="nav-number">1.2.3.</span> <span class="nav-text">二叉树及其性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#普通树与二叉树的转换"><span class="nav-number">1.2.4.</span> <span class="nav-text">普通树与二叉树的转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的存储结构，标准形式"><span class="nav-number">1.2.5.</span> <span class="nav-text">树的存储结构，标准形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#完全树（complete-tree）的数组形式存储"><span class="nav-number">1.2.6.</span> <span class="nav-text">完全树（complete tree）的数组形式存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的应用"><span class="nav-number">1.2.7.</span> <span class="nav-text">树的应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Huffman树的定义与应用"><span class="nav-number">1.2.8.</span> <span class="nav-text">Huffman树的定义与应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Huffman树的定义"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">Huffman树的定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Huffman哈夫曼应用"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">Huffman哈夫曼应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、查找-search"><span class="nav-number">1.3.</span> <span class="nav-text">三、查找(search)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、排序"><span class="nav-number">1.4.</span> <span class="nav-text">四、排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、图"><span class="nav-number">1.5.</span> <span class="nav-text">五、图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#图的基本概念"><span class="nav-number">1.5.1.</span> <span class="nav-text">图的基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#图的存储结构"><span class="nav-number">1.5.2.</span> <span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#邻接矩阵"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#邻接表"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#图的遍历"><span class="nav-number">1.5.3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#广度优先遍历"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">广度优先遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#深度优先遍历"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">深度优先遍历</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最小生成树-Minimum-Spanning-Tree"><span class="nav-number">1.5.4.</span> <span class="nav-text">最小生成树 (Minimum Spanning Tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#贪心算法-考纲里没有可以了解一下"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">贪心算法 (考纲里没有可以了解一下)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Prim算法"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">Prim算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Kruskal算法"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最短路径问题"><span class="nav-number">1.5.5.</span> <span class="nav-text">最短路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#BFS-广度优先遍历算法"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">BFS 广度优先遍历算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Dijkstra算法"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Floyd算法"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">Floyd算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拓扑排序"><span class="nav-number">1.5.6.</span> <span class="nav-text">拓扑排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序"><span class="nav-number">1.6.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#排序的基本概念"><span class="nav-number">1.6.1.</span> <span class="nav-text">排序的基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入排序，算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.6.2.</span> <span class="nav-text">插入排序，算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#希尔排序，算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.6.3.</span> <span class="nav-text">希尔排序，算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择排序，算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.6.4.</span> <span class="nav-text">选择排序，算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#快速排序，算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.6.5.</span> <span class="nav-text">快速排序，算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#合并排序，算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.6.6.</span> <span class="nav-text">合并排序，算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基数排序，算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.6.7.</span> <span class="nav-text">基数排序，算法基本思想，算法代码及基本的时间复杂度分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二部分-软件工程"><span class="nav-number">2.</span> <span class="nav-text">第二部分 软件工程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、软件过程"><span class="nav-number">2.1.</span> <span class="nav-text">一、软件过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#软件过程的概念；"><span class="nav-number">2.1.1.</span> <span class="nav-text">软件过程的概念；</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）"><span class="nav-number">2.1.2.</span> <span class="nav-text">经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#瀑布模型-waterfull-model"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">瀑布模型 waterfull model</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#增量模型"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">增量模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#演化模型"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">演化模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#统一过程模型"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">统一过程模型</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#过程评估与CMM-CMMI的基本概念"><span class="nav-number">2.1.3.</span> <span class="nav-text">过程评估与CMM/CMMI的基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#敏捷宣言与敏捷过程的特点"><span class="nav-number">2.1.4.</span> <span class="nav-text">敏捷宣言与敏捷过程的特点</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KOKI HOO</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">46k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jD3hLxRDgCSdorrir1RFkW3R-gzGzoHsz", "9AOQX6uUKthSSONK5UO95RGd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
