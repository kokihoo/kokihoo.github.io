<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="NOTE,">










<meta name="description" content="第一部分 数据结构与算法The ADT defines the logical form of the data type.The data structure implements  the physical form of the data type. 一、栈(Stack)、队列(Queue)和向量(Vector) 内容：单链表，双向链表，环形链表，带哨兵节点的链表；栈的基本概念和性质，栈AD">
<meta name="keywords" content="NOTE">
<meta property="og:type" content="article">
<meta property="og:title" content="NINESIXONE">
<meta property="og:url" content="http://yoursite.com/2019/08/15/961/index.html">
<meta property="og:site_name" content="KOKI">
<meta property="og:description" content="第一部分 数据结构与算法The ADT defines the logical form of the data type.The data structure implements  the physical form of the data type. 一、栈(Stack)、队列(Queue)和向量(Vector) 内容：单链表，双向链表，环形链表，带哨兵节点的链表；栈的基本概念和性质，栈AD">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png">
<meta property="og:image" content="http://yoursite.com/images/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E7%9A%84%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%9C%80%E5%8F%B3%E7%AB%AF%E7%BB%93%E7%82%B9%E5%92%8C%E6%9C%80%E5%B7%A6%E7%AB%AF%E7%BB%93%E7%82%B9.png">
<meta property="og:image" content="http://yoursite.com/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BC%95%E4%BE%8B.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%9C%80%E5%B0%91%E7%BB%93%E7%82%B9%E9%AB%98%E5%BA%A6.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%8F%B3%E5%8D%95%E6%97%8B.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%8F%B3%E5%8D%95%E6%97%8B%E8%B0%83%E6%95%B4.png">
<meta property="og:image" content="http://yoursite.com/images/RR%E6%97%8B%E8%BD%AC_01.png">
<meta property="og:image" content="http://yoursite.com/images/RR%E6%97%8B%E8%BD%AC_02.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%B7%A6%E5%8D%95%E9%80%89.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%B7%A6%E5%8D%95%E6%97%8B%E8%B0%83%E6%95%B4.png">
<meta property="og:image" content="http://yoursite.com/images/LR%E6%97%8B%E8%BD%AC.png">
<meta property="og:image" content="http://yoursite.com/images/LR%E6%97%8B%E8%BD%AC%E8%B0%83%E6%95%B4.png">
<meta property="og:image" content="http://yoursite.com/images/RL%E6%97%8B%E8%BD%AC.png">
<meta property="og:image" content="http://yoursite.com/images/RL%E6%97%8B%E8%BD%AC%E8%B0%83%E6%95%B4.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%A0%86.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%80%89%E4%B8%BB%E5%85%83.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%AD%90%E9%9B%86%E5%88%92%E5%88%86.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%9C%89%E5%BA%8F%E5%AD%90%E5%88%97%E7%9A%84%E5%BD%92%E5%B9%B6.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%9B%BE%E7%9A%84%E5%BC%95%E4%BE%8B.png">
<meta property="og:image" content="http://yoursite.com/images/%E5%9C%B0%E9%93%81%E7%BA%BF%E8%B7%AF.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%87%8D%E8%BE%B9%E5%92%8C%E8%87%AA%E5%9B%9E%E8%B7%AF.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%89%E5%90%91%E5%9B%BE.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%97%A0%E5%90%91%E5%9B%BE.png">
<meta property="og:image" content="http://yoursite.com/images/%E9%82%BB%E6%8E%A5%E8%A1%A8.png">
<meta property="og:image" content="http://yoursite.com/images/Prim%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://yoursite.com/images/Prim_Dijkstra.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://yoursite.com/images/%E6%9C%89%E6%9D%83%E5%9B%BE%E5%8D%95%E6%BA%90%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.png">
<meta property="og:updated_time" content="2019-11-22T10:36:11.549Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NINESIXONE">
<meta name="twitter:description" content="第一部分 数据结构与算法The ADT defines the logical form of the data type.The data structure implements  the physical form of the data type. 一、栈(Stack)、队列(Queue)和向量(Vector) 内容：单链表，双向链表，环形链表，带哨兵节点的链表；栈的基本概念和性质，栈AD">
<meta name="twitter:image" content="http://yoursite.com/images/%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/15/961/">





  <title>NINESIXONE | KOKI</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a5ecac7771fad0fda5191a255b9e3f5c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KOKI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/961/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">NINESIXONE</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T17:51:53+08:00">
                2019-08-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-11-22T18:36:11+08:00">
                2019-11-22
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/15/961/" class="leancloud_visitors" data-flag-title="NINESIXONE">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  29k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  121
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="第一部分-数据结构与算法"><a href="#第一部分-数据结构与算法" class="headerlink" title="第一部分 数据结构与算法"></a>第一部分 数据结构与算法</h3><p>The ADT defines the logical form of the data type.The data structure implements  the physical form of the data type.</p>
<h4 id="一、栈-Stack-、队列-Queue-和向量-Vector"><a href="#一、栈-Stack-、队列-Queue-和向量-Vector" class="headerlink" title="一、栈(Stack)、队列(Queue)和向量(Vector)"></a>一、栈(Stack)、队列(Queue)和向量(Vector)</h4><blockquote>
<p>内容：单链表，双向链表，环形链表，带哨兵节点的链表；栈的基本概念和性质，栈ADT及其顺序，链表实现；栈的应用；栈与递归；队列的基本概念和性质，队列ADT及其顺序、链表实现；队列的应用；向量基本概念和性质；向量ADT及其数组、链接实现；</p>
</blockquote>
<h5 id="单链表-Linked-Lists"><a href="#单链表-Linked-Lists" class="headerlink" title="单链表 Linked Lists"></a>单链表 Linked Lists</h5><p>Arrays are one way to implement Stacks, queues, etc.<br>Linked Lists are another – extremely flexible and general idea! 链表是另外一个非常灵活又常用的方法</p>
<p>Linked list = “Node” objects connected in a “chain” by links (object references) // 结点对象通过”链”连接起来</p>
<p>List Node Objects 链表结点对象<br>class ListNode {<br>    ListNode (Object theElement){ // default constructor<br>        this(theElement, null)<br>    }</p>
<pre><code>ListNode (Object theElement, ListNode n){ // constructor
    element = theElement;
    next = n;
}

ListNode next; // the next Node in the list
Object element; // the data</code></pre><p>}</p>
<pre><code>element    next
Rome        -&gt; null means &quot;ends of list&quot;</code></pre><p>Two special entry points</p>
<pre><code>if we maintain these two special entry points, it is easy to delete or insert entires at the &quot;head&quot; and insert entries at the &quot;tail&quot; 维护这两个特殊的入口点，将很容易在&quot;头&quot;结点处删除或插入实体，在&quot;尾&quot;处插入条目。</code></pre><h5 id="双向链表-Doubly-Linked-List"><a href="#双向链表-Doubly-Linked-List" class="headerlink" title="双向链表 Doubly Linked List"></a>双向链表 Doubly Linked List</h5><h5 id="循环-环形-链表-Circular-Linked-List"><a href="#循环-环形-链表-Circular-Linked-List" class="headerlink" title="循环(环形)链表 Circular Linked List"></a>循环(环形)链表 Circular Linked List</h5><h5 id="带哨兵结点的链表"><a href="#带哨兵结点的链表" class="headerlink" title="带哨兵结点的链表"></a>带哨兵结点的链表</h5><h5 id="栈的基本概念和性质-栈ADT及其顺序、链表实现"><a href="#栈的基本概念和性质-栈ADT及其顺序、链表实现" class="headerlink" title="栈的基本概念和性质,栈ADT及其顺序、链表实现"></a>栈的基本概念和性质,栈ADT及其顺序、链表实现</h5><h6 id="栈的基本概念和性质"><a href="#栈的基本概念和性质" class="headerlink" title="栈的基本概念和性质"></a>栈的基本概念和性质</h6><blockquote>
<p>堆栈: 具有一定操作约束的线性表，只在一端(栈顶，top)做插入，删除<br>    插入数据：入栈（Push）<br>    删除数据：出栈（Pop）<br>    后入先出：Last In First Out（LIFO）</p>
</blockquote>
<h6 id="栈ADT"><a href="#栈ADT" class="headerlink" title="栈ADT"></a>栈ADT</h6><pre><code>类型名称：Stack 栈
数据对象集：一个有0个或多个元素的有穷线性表
操作集：长度为MaxSize的堆栈S∈Stack，堆栈元素item∈ElementType
1、Stack CreateStack(int MaxSize): 生成空堆栈，其最大长度为MaxSize
2、int IsFull(Stack S, ElementType item): 判断堆栈S是否已满
3、void Push(Stack S, ElementType item): 将元素item压入堆栈
4、int IsEmpty(Stack S): 判断堆栈S是否为空；
5、ElementType Pop(Stack S): 删除并返回栈顶元素</code></pre><h6 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h6><blockquote>
<p>  栈的顺序存储结构通常是由一个<strong>一维数组</strong>和一个记录<strong>栈顶</strong>元素位置的变量组成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">typedef int Position</span><br><span class="line">struct SNode &#123;</span><br><span class="line">    ElementType *Data; // 存储元素的数组</span><br><span class="line">    Position Top; // 栈顶指针</span><br><span class="line">    int MaxSize; // 堆栈的最大容量</span><br><span class="line">&#125;</span><br><span class="line">typedef struct SNode *Stack;</span><br><span class="line"></span><br><span class="line">// 生成空堆栈</span><br><span class="line">Stack CreateStack(int MaxSize) &#123;</span><br><span class="line">    Stack S = (Stack)malloc(sizeof(struct SNode));</span><br><span class="line">    S-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));</span><br><span class="line">    S-&gt;Top = -1;</span><br><span class="line">    S-&gt; MaxSize = MaxSize;</span><br><span class="line">    return S</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断堆栈S是否已满</span><br><span class="line">bool IsFull(Stack S)&#123;</span><br><span class="line">    return (S-&gt;Top == S-&gt;MaxSize - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入栈</span><br><span class="line">bool Push(Stack S, ElmentType X)&#123;</span><br><span class="line">    if (IsFull(S))&#123;</span><br><span class="line">        printf(&apos;堆栈已满&apos;);</span><br><span class="line">        return False;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        S-&gt;Data[++(S-&gt;Top)] = X;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断堆栈为空</span><br><span class="line">bool IsEmpty(Stack S)&#123;</span><br><span class="line">    return (S-&gt;Top == -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">ElementType Pop(Stack S)&#123;</span><br><span class="line">    if(IsEmpty(S))&#123;</span><br><span class="line">        printf(&apos;堆栈空&apos;);</span><br><span class="line">        return ERROR; // ERROR是ElementType的特殊值，标志错误</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return S-&gt;Data((S-&gt;Top)--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="栈的链式存储实现"><a href="#栈的链式存储实现" class="headerlink" title="栈的链式存储实现"></a>栈的链式存储实现</h6><blockquote>
<p>栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。栈顶指针Top应该在链表的哪一头？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">typedef struct  SNode *PtrToSNode;</span><br><span class="line">struct SNode &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToSNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToSNode Stack;</span><br><span class="line"></span><br><span class="line">// 1、堆栈初始化</span><br><span class="line">// 2、判断堆栈S是否为空</span><br><span class="line"></span><br><span class="line">Stack CreateStack()&#123;</span><br><span class="line">    // 构建一个堆栈的头结点，返回指针</span><br><span class="line">    Stack S;</span><br><span class="line">    S = (Stack) malloc(sizeof(struct SNode));</span><br><span class="line">    S-&gt;Next = NULL;</span><br><span class="line">    retrun S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(Stack S)&#123;</span><br><span class="line">    // 判断堆栈S是否为空，若为空函数则返回true，否则返回false</span><br><span class="line">    return (S-&gt;Next == NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Push(Stack S, ElemenType X)&#123;</span><br><span class="line">    // 将元素item压入堆栈S</span><br><span class="line">    PtrToSNode TmpCell;</span><br><span class="line">    &lt;!-- TmpCell = (struct SNode *)malloc(sizeof(struct SNode)); --&gt;</span><br><span class="line">    TmpCell = (PtrToSNode)malloc(sizeof(struct SNode));</span><br><span class="line">    TmpCell-&gt; Data = X;</span><br><span class="line">    TmpCell-&gt; Next = S-&gt;next;</span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType Pop(Stack S)&#123;</span><br><span class="line">    // 删除并返回堆栈S的栈顶元素</span><br><span class="line">    &lt;!-- struct SNode *FirstCell; --&gt;</span><br><span class="line">    PtrToSNode FirstCell;</span><br><span class="line">    ElmentType TopElem;</span><br><span class="line">    if(IsEmpty(S))&#123;</span><br><span class="line">        printf(&apos;堆栈空&apos;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        TopElem = FirstCell-&gt;Element;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">        free(FirstCell);</span><br><span class="line">        return TopElem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="栈的应用；Stack-Application"><a href="#栈的应用；Stack-Application" class="headerlink" title="栈的应用；Stack Application"></a>栈的应用；Stack Application</h5><pre><code>【表达式求值】</code></pre><h5 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h5><h5 id="队列的基本概念和性质-队列ADT及其顺序、链表实现"><a href="#队列的基本概念和性质-队列ADT及其顺序、链表实现" class="headerlink" title="队列的基本概念和性质,队列ADT及其顺序、链表实现"></a>队列的基本概念和性质,队列ADT及其顺序、链表实现</h5><h6 id="队列的基本概念和性质"><a href="#队列的基本概念和性质" class="headerlink" title="队列的基本概念和性质"></a>队列的基本概念和性质</h6><blockquote>
<p>队列Queue: 具有一定操作约束的线性表<br>    插入和删除操作：只能在一端插入，而在另一端删除</p>
</blockquote>
<pre><code>数据插入：入队列(AddQ)
数据删除：出队列(DeleteQ)
先来先服务
先进先出： FIFO</code></pre><h6 id="队列ADT"><a href="#队列ADT" class="headerlink" title="队列ADT"></a>队列ADT</h6><blockquote>
</blockquote>
<pre><code>类型名称： 队列(Queue)
数据对象集：一个有0个或多个元素的有穷线性表
操作集：长度为MaxSize的队列Q∈Queue,队列元素item ∈ EelmentType
1、Queue CreateQueue(int MaxSize)：生成长度为MaxSize的空队列
2、int IsFull(Queue Q, int MaxSize): 判断队列Q是否已满
3、void AddQ(Queuq Q, ElementType item): 将数据元素item插入队列Q中
4、int IsEmptyQ(Queue Q): 判断队列Q是否为空
5、ElementType DeleteQ(Queue Q): 将对头数据元素从队列中删除并返回</code></pre><h6 id="队列顺序、链表实现"><a href="#队列顺序、链表实现" class="headerlink" title="队列顺序、链表实现"></a>队列顺序、链表实现</h6><blockquote>
<p>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素的变量rear组成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">typedef int Position</span><br><span class="line">struct QNode &#123;</span><br><span class="line">    ElementType *Data; // 存储元素的数组</span><br><span class="line">    Position Front,Rear; // 队列的头，尾指针</span><br><span class="line">    int MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line"></span><br><span class="line">Queue CreateQueue(int MaxSize)&#123;</span><br><span class="line">    Queue Q = (Queue) malloc (sizeof(struct QNode));</span><br><span class="line">    Q-&gt;Data = (ElementType *) malloc (MaxSize * sizeof(ElementType));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = 0;</span><br><span class="line">    Q-&gt;MaxSize = MaxSize;</span><br><span class="line">    return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsFull(Queue Q)&#123;</span><br><span class="line">    return ((Q-&gt;Rear+1)%Q-&gt;MaxSize == Q-&gt;Front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool AddQ(Queue Q, ElementType X)&#123;</span><br><span class="line">    if(IsFull()) &#123;</span><br><span class="line">        printf(&quot;队列满&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Q-&gt;Rear = (Q-&gt;Rear + 1)%Q -&gt; MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = X;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(Queue Q)&#123;</span><br><span class="line">    return (Q-&gt;Front == Q-&gt;Rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType DeleteQ(Queue Q)&#123;</span><br><span class="line">    if(IsEmpty(Q))&#123;</span><br><span class="line">        printf(&apos;队列空&apos;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tmp = Q-&gt;Data(Q-&gt;Front)</span><br><span class="line">        Q-&gt;Front = (Q-&gt;Front +1 )%Q-&gt;MaxSiz;</span><br><span class="line">        &lt;!-- return Q-&gt;Data(Q-&gt;Front) // 这里不对 --&gt;</span><br><span class="line">        return tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>队列的链式存储结构也可以用一个单链表实现，插入和删除操作分别再链表的两头进行。队列指针front和rear应该分别指向链表的哪一头？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    // 队列中的结点</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode Position;</span><br><span class="line"></span><br><span class="line">struct QNode &#123;</span><br><span class="line">    Position Front, Rear;// 队列的头，尾指针</span><br><span class="line">    int MaxSize; // 队列最大容量</span><br><span class="line">&#125;</span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(Queue Q)&#123;</span><br><span class="line">    return (Q-&gt;Front == NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType DeleteQ(Queue Q)&#123;</span><br><span class="line">    Position FrontCell;</span><br><span class="line">    ElementType FrontElem;</span><br><span class="line"></span><br><span class="line">    if(IsEmpty(Q))&#123;</span><br><span class="line">        printf(&quot;队列为空&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        FrontCell = Q-&gt;Front;</span><br><span class="line">        if(Q-&gt;Front == Q-&gt;Rear) // 若队列只有一个元素</span><br><span class="line">            Q-&gt;Front = Q-&gt;Rear = NULL; // 删除后队列置为空</span><br><span class="line">        else</span><br><span class="line">            Q-&gt;Front = Q-&gt;Front-&gt;Next;</span><br><span class="line">        FrontElem = FrontCell-&gt;Data;</span><br><span class="line">        free(FrontCell); // 释放被删除结点的空间</span><br><span class="line">        return FrontElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h6><h5 id="向量的基本概念和性质-向量ADT及其数组、链表实现"><a href="#向量的基本概念和性质-向量ADT及其数组、链表实现" class="headerlink" title="向量的基本概念和性质,向量ADT及其数组、链表实现"></a>向量的基本概念和性质,向量ADT及其数组、链表实现</h5><h4 id="二、树"><a href="#二、树" class="headerlink" title="二、树"></a>二、树</h4><blockquote>
<p>内容： 树的基本概念和术语；树的前序，中序，后序，层次序遍历；二叉树及其性质；普通树与二叉树的转换；树的存储结构，标准形式；完全树(complete tree)的数组形式存储；树的应用，Huffman树的定义与应用。</p>
</blockquote>
<h5 id="树的基本概念和术语"><a href="#树的基本概念和术语" class="headerlink" title="树的基本概念和术语"></a>树的基本概念和术语</h5><blockquote>
<p>树(Tree): n(n&gt;=0)个结点构成的有限集合。n=0时，称为空树，对于任一颗非空树(n&gt;0),它具备以下性质：</p>
</blockquote>
<pre><code>树中有一个称为“根Root”的特殊结点，用r表示
其余结点可分为m(m&gt;0)个互不相交的有限集T1，T2...Tm, 其中每个集合本身又是一颗树，称为原来的子树

子树是不相交的
除了根结点外，每个结点有且仅有一个父结点
一颗N个结点的树有N-1条边

**树的一些基本术语**
1、结点的度Degree：结点的子树个数
2、树的度：树的所有结点中最大的度数
3、叶结点Leaf：度为0的结点
4、父结点Parent：有子树的结点是其子树根结点的父结点
5、子结点（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点，子结点也称孩子结点
6、兄弟节点Sibling：具有同一父结点的各节点彼此是兄弟节点
7、路径与路径长度：从结点n1到nk的路径为一个结点序列n1，n2……nk，ni是ni+1的父结点，路径所包含边的个数为路径的长度
8、祖先结点Ancestor：沿树根到某一结点路径上所有结点都是这个结点的祖先结点
9、子孙结点Descendant：某一结点的子树中的所有结点是这个节点的子孙
10、结点的层次Level：规定跟结点在1层，其他任一结点的层数是其父结点的层数加1
11、树的深度Depth：树中所有结点中的最大层次是这棵树的深度</code></pre><h5 id="树的前序、中序、后序、层次遍历"><a href="#树的前序、中序、后序、层次遍历" class="headerlink" title="树的前序、中序、后序、层次遍历"></a>树的前序、中序、后序、层次遍历</h5><pre><code>(1) 先序遍历
    遍历过程为：
        1、访问根结点
        2、先序遍历左子树
        3、先序遍历右子树
    ![先序遍历](/images/先序遍历.png)
    A(BDFE)(CGHI)
    先序遍历=&gt; A B D F E C G H I

    void PreOrderTraversal(BinTree BT){
        if(BT){
            printf(&apos;%d&apos;, BT-&gt;Data);
            PreOrderTraversal(BT-&gt;Left);
            PreOrderTraversal(BT-&gt;Right);
        }
    }

    第一次碰到的时候弹出:
    void PreOrderTraversal(BinTree BT){
        BinTree T BT;
        Stack S = CreatStack(MaxSize) ;// 创建并初始化堆栈S
        while( T || !IsEmpty(S)){
            while(t){ // 一直向左并将沿途结点压入堆栈
                Push(S, T);
                T = Pop(S); // 结点弹出堆栈
                printf(&quot;%5d&quot;, T-&gt;Data);
                T = T-&gt;Left;

                if(!IsEmpty(S)){
                    T = T-&gt;Right; // 转向右子树
                }

            }
        }
    }


(2) 中序遍历
    遍历过程为：
        1、中序遍历其左子树;
        2、访问根结点
        3、中序遍历其右子树
    ![中序遍历](/images/中序遍历.png)
    (DBEF) A (GHCI)
    中序遍历=&gt; DBEFAGHCI

    void InOrderTraversal(BinTree BT){
        if(BT){
            InOrderTraversal(BT-&gt;Left);
            printf(&apos;%d&apos;, BT-&gt;Data);
            InOrderTraversal(BT-&gt;Right);
        }
    }

    中序遍历非递归遍历算法：
        非递归算法实现的基本思路：使用堆栈
        - 遇到一个结点，就把它压栈，并去遍历它的左子树；
        - 当左子树遍历结束后，从栈顶弹出这个结点并访问它
        - 然后按其右指针再去中序遍历该结点的右子树
    第二次碰到的时候弹出

    void InOrderTraversal(BinTree BT) {
        BinTree T = BT;
        Stack S = CreatStack(MaxSize); // 创建并初始化堆栈S
        while( T || !IsEmpty(S)) { // 树不空或者堆栈不空
            while(T) {
                Push(S, T);
                T = T -&gt; Left;
            }
            if(!IsEmpty(S)){
                T = Pop(S); // 结点弹出堆栈
                printf(&quot;%5d&quot;, T-&gt;Data); // 访问打印结点
                T = T-&gt;Right; // 转向右子树
            }
        }
    }


(3) 后序遍历
    遍历过程为：
        1、后序遍历左子树
        2、后序遍历右子树
        3、访问根结点
    ![后序遍历](/images/后序遍历.png)
    (DEFB)(HGIC)A
    后序遍历=&gt; D E F B H G I C A
    void PostOrderTraversal(BinTree BT){
        if(BT){
            PostOrderTraversal(BT-&gt;Left);
            PostOrderTraversal(BT-&gt;Right);
            printf(&quot;%d&quot;, BT-&gt;Data);
        }
    }


(4) 层序遍历
    二叉树遍历的核心问题：二维结构的线性化
        - 从结点访问其左右儿子结点
        - 访问左儿子后，右儿子结点怎么办？
            需要一个存储结构保存暂不访问的结点
            存储结构：堆栈、队列
    队列实现： 遍历从根结点开始，首先将根结点入队，然后开始执行循环，结点出队，访问该结点，其左右儿子入队。
    ![层序遍历](/images/层序遍历.png)

     A B C D F G I E H
     层序遍历： A B C D F G I E H

    层序基本过程： 先跟结点入队，然后：
    1、从队列中取出一个元素；
    2、访问该元素所指结点
    3、若该元素所指结点的左右孩子结点非空，则将其左右孩子的指针顺粗入队

    void LevelOrderTraversal(BinTree BT){
        Queue Q;
        BinTree T;
        if(!BT) return; // 若是空树返回
        Q = CreateQueue(MaxSize); // 创建并初始化队列Q
        AddQ(Q, BT);
        while(!IsEmptyQ(Q)){
            T = DeleteQ(Q);
            printf(&apos;%d\n&apos;, T-&gt;Data); // 访问取出队列的结点
            if(T-&gt;left) AddQ(Q, T-&gt;Left);
            if(T-&gt;right) AddQ(Q, T -&gt; Right);
        }
    }</code></pre><h5 id="二叉树及其性质"><a href="#二叉树及其性质" class="headerlink" title="二叉树及其性质"></a>二叉树及其性质</h5><blockquote>
<p>二叉树的定义;<br>    二叉树T：一个有穷的结点集合<br>            这个集合可以为空<br>            若不为空，则它是由根结点和称为其左子树Tl和右子树Tr的两个不想交的二叉树组成</p>
</blockquote>
<pre><code>二叉树具体五种基本形态：

 空      O           O           O             O
                 Tl                 Tr     Tl     Tr

(a)     (b)         (c)          (d)           (e)


二叉树的子树有左右顺序之分
   A                    A
B                          B
(左子树)                (右子树)


特殊二叉树：
    * 斜二叉树 Skewed Binary Tree
    A
       B
          C 
             D
完美二叉树 Perfact Binary Tree 满二叉树 Full Binary Tree
                    A
            B                     C
        D     E              F        G
    H   I J   K          L   M    N    O

完全二叉树 Complete Binary Tree
    有n个结点的二叉树，对树中结点按从上到下，从左到右顺序进行编号，编号为i(1&lt;=i&lt;=n)结点与满二叉树中编号为i结点在二叉树中位置相同。

二叉树几个重要性质：
1、一个二叉树第i层的最大结点数为2^i-1, i&gt;=1
2、深度为k的二叉树有最大结点总数为：2^k - 1, k&gt;= 1
3、对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶子结点个数，那么满足关系n0 = n2 + 1
     A
  B     C
D   E  F
  J  K   H   

  n0 ：D J K H 4
  N1：C F 2
  N2：A B E 3

  No=N2 + 1 叶子结点个数为度为2的非叶子结点个数+1</code></pre><h5 id="普通树与二叉树的转换"><a href="#普通树与二叉树的转换" class="headerlink" title="普通树与二叉树的转换"></a>普通树与二叉树的转换</h5><pre><code>树转换为二叉树：
  1、加线：在兄弟之间加一条线
  2、抹线：对每个结点，除了其左孩子外，抹掉其与其余孩子之间的连线
  3、旋转：将树作适当的旋转即可

二叉树转换成树：
  1、逆旋转：把二叉树从左上到右下分为若干层，然后调整为水平方向
  2、加线：找到每一层结点在其上层的父结点，将每层的结点和其父结点相连
  3、抹线：删掉每一层结点之间的连接</code></pre><h5 id="树的存储结构，标准形式"><a href="#树的存储结构，标准形式" class="headerlink" title="树的存储结构，标准形式"></a>树的存储结构，标准形式</h5><blockquote>
<p>二叉树的存储结构<br>    1、顺序存储结构<br>    完全二叉树：按从上到下，从左到右顺序存储n个结点的完全二叉树的结点父子关系<br>                    A<br>         B                   O<br>      C    S              M     Q<br>    W   K</p>
</blockquote>
<pre><code>非根结点(序号i&gt;1)的父结点的序号是i/2
结点(序号为i)的左孩子结点的序号是2i，若2i&lt;= n，否则没有左孩子
结点(序号为i)的右孩子结点的序号是2i+1，若2i+1在&lt;= n,否则没有右孩子

结点   A    B   O   C   S    M    Q    W    K
序号   1    2   3   4   5    6    7    8    9

一般二叉树也可以采用这种结构，但会造成空间浪费


2、链表存储
typedef struct TreeNode *BinTree;
typedef BinTree Position; // 二叉树类型
struct TreeNode {
    ElementType data;
    BinTree Left;s
    BinTree Right;
}

Left Data Right

![二叉树链表存储](/images/二叉树链表存储.png)</code></pre><h5 id="完全树（complete-tree）的数组形式存储"><a href="#完全树（complete-tree）的数组形式存储" class="headerlink" title="完全树（complete tree）的数组形式存储"></a>完全树（complete tree）的数组形式存储</h5><pre><code>完全二叉树：按从上到下，从左到右顺序存储n个结点的完全二叉树的结点父子关系
                A
    B                   O
C    S              M     Q
W   K

非根结点(序号i&gt;1)的父结点的序号是i/2
结点(序号为i)的左孩子结点的序号是2i，若2i&lt;= n，否则没有左孩子
结点(序号为i)的右孩子结点的序号是2i+1，若2i+1在&lt;= n,否则没有右孩子

结点   A    B   O   C   S    M    Q    W    K
序号   1    2   3   4   5    6    7    8    9

一般二叉树也可以采用这种结构，但会造成空间浪费</code></pre><h5 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h5><blockquote>
<pre><code>一、遍历二叉树的应用：输出二叉树中的叶子结点
在二叉树的遍历算法中增加检测结点的&quot;左右子树是否都为空&quot;
void PreOrderPrintLeaves(BinTree BT){
    if(BT){
        if(!BT-&gt;Left &amp;&amp; !BT-&gt;Right)
            printf(&quot;%d&quot;, BT-&gt;Data);
        PreOrderPrintLeaves(BT-&gt;Left);
        PreOrderPrintLeaves(BT-&gt;Right);
    }
}</code></pre></blockquote>
<pre><code>二、求二叉树的高度]
            O

左子树(Hl)      右子树(HR)
Height = max(HL, HR) + 1;

// 这个算法好像是有问题 如果是伪码的话好像也差点意思
int PostOrderGetHeight(BinTree BT){
    int HL, HR, MaxH;
    if(BT) {
        HL = PostOrderGetHeight(BT-&gt;Left); // 求左子树的深度
        HR = PostOrderGetHeight(BT-&gt;Right); // 求右子树的深度
        MaxH = （HL &gt; HR) ? HL : HR; // 取左右子树较大的深度
        return (MaxH + 1); // 返回树的深度
    }
    else return 0; // 空树深度为0
}

三、二元运算表达式及其遍历
                 +

            +                         *
      a          *                  +        g
               b    c            *    f
                             d      e



    三种遍历可以得到三种不同的访问结果：
    先序遍历得到前缀表达式： + + a * b c * + * d e f g
    中序遍历得到中缀表达式：a + b * c + d * e + f * g
    后序遍历得到后缀表达式：a b c * + d e * f + g * +

四、由两种遍历序列确定二叉树
    问：已知三种遍历中的任意两种遍历序列能否唯一确定一颗二叉树呢？
    答案：必须要有中序遍历

    先序和中序遍历序列来确定一颗二叉树
    分析：
    - 根据先序遍历序列第一个结点确定根结点
    - 根据根结点在中序遍历序列中分割出左右两个子序列
    - 对左子树和右子树分别递归使用相同的方法继续分解

    先序序列：根结点 左子树 右子树
    中序序列：左子树 根结点 右子树

    类似的，后序和中序遍历序列也可以确定一颗二叉树</code></pre><h5 id="Huffman树的定义与应用"><a href="#Huffman树的定义与应用" class="headerlink" title="Huffman树的定义与应用"></a>Huffman树的定义与应用</h5><h6 id="Huffman树的定义"><a href="#Huffman树的定义" class="headerlink" title="Huffman树的定义"></a>Huffman树的定义</h6><blockquote>
<p><strong>带权路径长度</strong>WPL：设二叉树有n个叶子结点，每个叶子结点带有权值Wk。从根结点到每个叶子结点的长度为Lk，则每个叶子结点的带权路径长度之和就是：WPL = ∑(n, k=1)WkLk<br>  最优二叉树或哈夫曼树：<strong>WPL最小的二叉树</strong></p>
</blockquote>
<p>  判定树 查找效率 找出最优二叉树 最优判别树 提高查找效率<br>  比率*比较次数</p>
<p>  <strong>根据结点不同的查找效率构造更有效的搜索树–这就是哈夫曼树要解决的问题</strong></p>
<p>  哈夫曼树的构造<br>    1、每次把权值最小的两颗二叉树合并<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int Weight;</span><br><span class="line">    HuffmanTree Left, Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuffmanTree Huffman(MinHeap H)&#123;</span><br><span class="line">    // 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里</span><br><span class="line">    int i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H); // 将H-&gt;Elements[]按权值调整为最小堆</span><br><span class="line">    for(i=1; i&lt;H-&gt;Size; i++) &#123;</span><br><span class="line">        // 做H-&gt;Size -1次合并</span><br><span class="line">        T = malloc(sizeof(struct TreeNode)); // 建立新结点</span><br><span class="line">        T-&gt;Left = DeleteMin(H); // 从最小堆中删除一个结点，作为新T的左结点</span><br><span class="line">        T-&gt;Right = DeleteMin(H); // 从最小堆中删除一个结点，作为新T的右结点</span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class="line">        Insert(H, T); // 将T插入到最小堆</span><br><span class="line">    &#125;</span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>整体时间复杂度为O(NlogN)
如何选取两个最小的？ 利用堆！排序方法效率不如堆！


哈夫曼树的特点：
1、没有度为1的结点
2、n个叶子结点的哈夫曼树共有2n-1个结点
3、哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树

    n0：叶结点总数
    n1：只有一个儿子的结点总数
    n2：有2个儿子的结点总数

    n2 = n0 -1
？对同一组权值{w1, w2, …… wn},是否存在不同构的两颗哈夫曼树呢？
对一组权值，不同构的两棵哈夫曼树WPL相同</code></pre><h6 id="Huffman哈夫曼应用"><a href="#Huffman哈夫曼应用" class="headerlink" title="Huffman哈夫曼应用"></a>Huffman哈夫曼应用</h6><pre><code>哈夫曼编码：
给定一段字符串，如何对字符进行编码，可以使得该字符串的编码存储空间最小？
[例]假设有一段文本，包含58个字符，并由一下7个字符构成：a，e，i，s，t，空格（sp），换行（nl）；这7个字符出现的次数不同。如何对这7个字符进行编码，使得总编码空间最少？
【分析】：
(1) 用等长ASCII编码：58*8 = 464位
(2) 用等长3位编码：58*3 = 174位
(3) 不等长编码：出现频率高的字符用的编码短些，出现频率低的字符则编码可以长些
怎么进行不等长编码?
如何避免二义性?
前缀码prefix code：任何字符的编码都不是另一个字符编码的前缀
    - 可以无二义地解码
二叉树用于编码：
    用二叉树进行编码：
    1、左右分支：0、1
    2、字符只在叶结点上

四个字符的频率：a：4， u：1， x：2， z: 1

       0|1
    0|1     0|1
 |a   u| |x   z|

a: 00
u: 01
x: 10
z: 11
当所有字符在叶结点上时，不会出现一个字符的编码是另一个字符的前缀码

Cost(aaaxuaxz-&gt;0000001001001011) = 2*4 + 2*1 + 2*2 + 2*1 = 16

然后哈夫曼树构造一颗编码代价最小的二叉树
    0|1
a|     0|1
     x|  0|1
       u|   z|
a: 0
u: 110
x: 10
z: 111
Cost(aaaxuaxz-&gt;00010110010111) = 1*4 + 3*1 + 2*2 + 3*1 = 14

怎么构造一颗编码代价最小的二叉树？
哈夫曼编码：
Ci a  e  i  s  t  sp  nl
fi 10 15 12 3  4  13  1

构造哈夫曼树：
               0|58|1
        0|25|1            0|33|1
    12i      sp13      e15       0|18|1
                             0|8|1      0|10a|1
                           4t   0|4|1
                              1nl   3s
然后哈夫曼编码就出来了
a：111
e: 10
i: 00
s: 11011
t: 1100
sp: 01
nl: 11010</code></pre><h4 id="三、查找-search"><a href="#三、查找-search" class="headerlink" title="三、查找(search)"></a>三、查找(search)</h4><blockquote>
<p>内容：<br>    查找的基本概念；<br>    对线性关系结构的查找；<br>    顺序查找；<br>    二分查找；<br>    Hash查找法；<br>    常见的Hash函数（直接定址法，随机数法）<br>    hash冲突的概念<br>    解决冲突的方法(开散列方法/拉链法，闭散列方法/开址定址法)<br>    二次聚集现象；<br>    BST树定义，性质，ADT及其实现，BST树查找，插入，删除算法；平<br>    衡树(AVL)的定义，性质，ADT及其实现，平衡树查找，插入算法，平衡因子的概念；<br>    优先队列与堆，堆的定义，堆的生成，调整算法；<br>    范围查询；</p>
</blockquote>
<h5 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h5><blockquote>
<p>  查找(Searching)<br>    查找：根据某个给定关键字K，从集合R中找出关键字与K相同的记录</p>
</blockquote>
<pre><code>静态查找：集合中记录是固定的
    - 没有插入和删除操作，只有查找
动态查找：集合中记录是动态变化的
    - 除了查找，还可能发生插入和删除</code></pre><h5 id="对线性关系结构的查找"><a href="#对线性关系结构的查找" class="headerlink" title="对线性关系结构的查找"></a>对线性关系结构的查找</h5><h6 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int SequentialSearch (StaticTable *Tb1, ElementType K)&#123;</span><br><span class="line">    // 在表Tbl[1] ~ Tbl[n]中查找关键字为K的数据元素</span><br><span class="line">    int i;</span><br><span class="line">    Tbl-&gt;Element[0] = K; // 建立哨兵</span><br><span class="line">    for(i=Tbl-Length; Tbl-&gt;Element[i]!=K; i--);</span><br><span class="line">    return i; // 查找成功返回所在单元下标，不成功返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

顺序查找算法的时间复杂度为O(n)</code></pre><h6 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h6><blockquote>
<p>  假设n个数据元素的关键字满足有序(比如：从小到大)<br>    K1 &lt; K2 &lt;……&lt; Kn<br>    并且是连续存放(数组),那么可以进行二分查找</p>
</blockquote>
<pre><code>【例】假设有13个数据元素，按关键字由小到大顺序存放。二分查找关键字为444的数据元素过程如下：—— 找得到情况

    5   16   39   45   51   98   100   202   226   321   368   444   501
    1    2    3    4    5    6    7     8     9     10    11    12    13
    left                          mid                                     right

    1、left = 1 ， right=13； mid = (1+13)/2 = 7; 100&lt;444;
    2、left = mid + 1 = 8, right = 13; mid = (8+13)/2 = 10;  321 &lt; 444
    3、 left = mid +1 = 11, right = 13, mid = (11+13)/2 = 12; 查找结束

【例】 仍然以上面13个数据元素构成的有序线性表为例二分查找关键字为43的数据元素如下: —— 找不到的情况

    5   16   39   45   51   98   100   202   226   321   368   444   501
    1    2    3    4    5    6    7     8     9     10    11    12    13
    left                          mid                                 right

    1、left=1, right=13; mid=(1+13)/2=7;  100&gt;43
    2、left=1, right=mid-1=6; mid=(1+6)/2=3;  39&lt;43
    3、left=mid+1=4, right=6; mid=(4+6)/2=5;  51&gt;43
    4、left=4, right=mid-1=4; mid=(4+4)/2=4;  45&gt;43
    5、left=4, right=mid-2=3; left&gt;right?  查找失败，结束；

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 二分查找算法</span><br><span class="line">int BinarySearch(StaticTable *Tbl, ElementType K)</span><br><span class="line">&#123;// 在表Tbl中查找关键字为K的数据元素</span><br><span class="line">    int left, right, mid, NoFound=-1;</span><br><span class="line"></span><br><span class="line">    left=1; // 初始左边界</span><br><span class="line">    right = Tbl-&gt;Length; // 初始右边界</span><br><span class="line">    while(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left+right)/2; // 计算中间元素坐标</span><br><span class="line">        if(K &lt; Tbl-&gt;Element[mid]) right = mid - 1; // 调整右边界</span><br><span class="line">        else if(K &gt; Tbl-&gt;Element[mid]) left = mid + 1;//  调整左边界</span><br><span class="line">        else return mid; // 查找成功，返回数据元素的下标</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NotFound; // 查找不成功，返回-1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    二分查找法具有对数的时间复杂度O(logN)

    这里还可以引申一个二分查找判定树，东西太多了，这个就不多说了，增加负担，后面的知识会涉及，到时候仔细</code></pre><h5 id="Hash查找法"><a href="#Hash查找法" class="headerlink" title="Hash查找法"></a>Hash查找法</h5><blockquote>
<p>  查找的本质: 已知对象找位置<br>        - 有序安排对象：全序、半序<br>        - 直接“算出”对象位置：散列</p>
</blockquote>
<pre><code>散列(哈希)查找法的两项基本工作：
    - 计算位置：构造散列(哈希)函数确定关键字存储位置
    - 解决冲突：应用某种策略解决多个关键词位置相同的问题

时间复杂度几乎是常量：O(1)，即查找时间与问题规模无关！

“散列(Hashing)”的基本思想是：
    1、以关键字key为自变量，通过一个确定的函数h(散列函数),计算出对应的函数值h(key),作为数据对象的存储地址
    2、可能不同的关键字会映射到同一个散列地址上，
        即h(keyi) = h(keyj)(当keyi不等于keyj)，称为“冲突(Collision)”。-- 需要某种冲突解决策略

装填因子(Loading Factor)：设散列表空间大小为m，填入表中元素个数是n，则称α = n/m为散列表的装填因子</code></pre><h6 id="常见的哈希函数-直接定址法、随机数法"><a href="#常见的哈希函数-直接定址法、随机数法" class="headerlink" title="常见的哈希函数(直接定址法、随机数法)"></a>常见的哈希函数(直接定址法、随机数法)</h6><blockquote>
<p>  一个“好”的散列函数一般应考虑下列两个因素：<br>    1、计算简单，以便提高转换速度<br>    2、关键词对应的地址空间分布不均，以尽量减少冲突</p>
</blockquote>
<pre><code>直接定址法、除留余数法(h(key) = key mod p)、数字分析法、折叠法(56793542，h(56793542)=542+793+056=391)、平方取中法(56793542，56793542*56793542= 3225506412905764，h(56793542)=641)、随机数法</code></pre><p>####### 直接定址法<br>    取关键词的某个线性函数值为散列地址，即h(key) = a*key + b (a、b为常数)</p>
<p><img src="/images/%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95.png" alt="直接定址法"></p>
<pre><code>h(key) = key - 1990</code></pre><p>####### 随机数法<br>    选择一个随机函数，取关键字的随机函数值为它的哈希地址，即h(key) = random(key),其中random为随机函数，通常，当关键字长度不等时采用此法构造哈希函数较恰当。</p>
<h6 id="hash冲突的概念"><a href="#hash冲突的概念" class="headerlink" title="hash冲突的概念"></a>hash冲突的概念</h6><blockquote>
<p>  不同的关键字会映射到同一个散列地址上，<br>            即h(keyi) = h(keyj)(当keyi不等于keyj)，称为“冲突(Collision)”。– 需要某种冲突解决策略</p>
</blockquote>
<h6 id="解决冲突的方法-开散列方法-拉链法，闭散列方法-开放定址法"><a href="#解决冲突的方法-开散列方法-拉链法，闭散列方法-开放定址法" class="headerlink" title="解决冲突的方法(开散列方法/拉链法，闭散列方法/开放定址法)"></a>解决冲突的方法(开散列方法/拉链法，闭散列方法/开放定址法)</h6><blockquote>
<p>  常用处理冲突的思路：<br>    - 换个位置：开放地址法<br>    - 同一个位置的冲突对象组织在一起：链地址法(拉链法)</p>
</blockquote>
<p>####### 开散列方法/拉链法</p>
<blockquote>
<p>  Separate Chaining 分离链接法：将相应位置上冲突的所有关键词存储在同一个单链表中</p>
</blockquote>
<pre><code>把一个位置上的所有有冲突的元素全部串在一起

【例】设关键字序列为47, 7, 29, 11, 16, 92, 22, 8, 3, 50, 37, 89, 94, 21;
散列函数取为：h(key) = key mod 11;
用分离链接法(链地址法)处理冲突.</code></pre><p><img src="/images/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png" alt="链地址法"></p>
<pre><code>表中有9个结点只需1次查找
5个结点需要2次查找
查找成功的平均查找次数：
ASL s=(9+5*2) / 14 ≈ 1.36

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#define KEYLENGTH 15                   /* 关键词字符串的最大长度 */</span><br><span class="line">typedef char ElementType[KEYLENGTH+1]; /* 关键词类型用字符串 */</span><br><span class="line">typedef int Index;                     /* 散列地址类型 */</span><br><span class="line">/******** 以下是单链表的定义 ********/</span><br><span class="line">typedef struct LNode *PtrToLNode;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToLNode Position;</span><br><span class="line">typedef PtrToLNode List;</span><br><span class="line">/******** 以上是单链表的定义 ********/</span><br><span class="line"></span><br><span class="line">typedef struct TblNode *HashTable; /* 散列表类型 */</span><br><span class="line">struct TblNode &#123;   /* 散列表结点定义 */</span><br><span class="line">    int TableSize; /* 表的最大长度 */</span><br><span class="line">    List Heads;    /* 指向链表头结点的数组 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HashTable CreateTable( int TableSize )</span><br><span class="line">&#123;</span><br><span class="line">    HashTable H;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    H = (HashTable)malloc(sizeof(struct TblNode));</span><br><span class="line">    /* 保证散列表最大长度是素数，具体见代码5.3 */</span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line"></span><br><span class="line">    /* 以下分配链表头结点数组 */</span><br><span class="line">    H-&gt;Heads = (List)malloc(H-&gt;TableSize*sizeof(struct LNode));</span><br><span class="line">    /* 初始化表头结点 */</span><br><span class="line">    for( i=0; i&lt;H-&gt;TableSize; i++ ) &#123;</span><br><span class="line">        H-&gt;Heads[i].Data[0] = &apos;\0&apos;;</span><br><span class="line">        H-&gt;Heads[i].Next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Position Find( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position P;</span><br><span class="line">    Index Pos;</span><br><span class="line">    </span><br><span class="line">    Pos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */</span><br><span class="line">    P = H-&gt;Heads[Pos].Next; /* 从该链表的第1个结点开始 */</span><br><span class="line">    /* 当未到表尾，并且Key未找到时 */ // 遍历单向链表的循环</span><br><span class="line">    while( P &amp;&amp; strcmp(P-&gt;Data, Key) )</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line"></span><br><span class="line">    return P; /* 此时P或者指向找到的结点，或者为NULL */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Insert( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position P, NewCell;</span><br><span class="line">    Index Pos;</span><br><span class="line">    </span><br><span class="line">    P = Find( H, Key );</span><br><span class="line">    if ( !P ) &#123; /* 关键词未找到，可以插入 */</span><br><span class="line">        NewCell = (Position)malloc(sizeof(struct LNode));</span><br><span class="line">        strcpy(NewCell-&gt;Data, Key);</span><br><span class="line">        Pos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */</span><br><span class="line">        /* 将NewCell插入为H-&gt;Heads[Pos]链表的第1个结点 */</span><br><span class="line">        NewCell-&gt;Next = H-&gt;Heads[Pos].Next;</span><br><span class="line">        H-&gt;Heads[Pos].Next = NewCell; </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; /* 关键词已存在 */</span><br><span class="line">        printf(&quot;键值已存在&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyTable( HashTable H )</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    Position P, Tmp;</span><br><span class="line">    </span><br><span class="line">    /* 释放每个链表的结点 */</span><br><span class="line">    for( i=0; i&lt;H-&gt;TableSize; i++ ) &#123;</span><br><span class="line">        P = H-&gt;Heads[i].Next;</span><br><span class="line">        while( P ) &#123;</span><br><span class="line">            Tmp = P-&gt;Next;</span><br><span class="line">            free( P );</span><br><span class="line">            P = Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free( H-&gt;Heads ); /* 释放头结点数组 */</span><br><span class="line">    free( H );        /* 释放散列表结点 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>####### 闭散列方法/开放定址法</p>
<blockquote>
<p>  开放地址法 Open Addressing<br>    一旦产生了冲突(该地址已有其他元素)，就按某种规则去寻找另一空地址</p>
</blockquote>
<pre><code>若发生了第i次冲突，试探的下一个地址将增加di，基本公式是：hi(key) = (h(key) + di) mod TableSize (1&lt;=i&lt;TableSize)
偏移量di决定了不同的解决冲突方案：线性探测(di = i)、平方探测(di = +-i^2)、双散列(di = i*h2(key))


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 创建开放定址法的散列法</span><br><span class="line">#define MAXTABLESIZE 100000 /* 允许开辟的最大散列表长度 */</span><br><span class="line">typedef int ElementType;    /* 关键词类型用整型 */</span><br><span class="line">typedef int Index;          /* 散列地址类型 */</span><br><span class="line">typedef Index Position;     /* 数据所在位置与散列地址是同一类型 */</span><br><span class="line">/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */</span><br><span class="line">typedef enum &#123; Legitimate, Empty, Deleted &#125; EntryType;</span><br><span class="line"></span><br><span class="line">typedef struct HashEntry Cell; /* 散列表单元类型 */</span><br><span class="line">struct HashEntry&#123;</span><br><span class="line">    ElementType Data; /* 存放元素 */</span><br><span class="line">    EntryType Info;   /* 单元状态 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct TblNode *HashTable; /* 散列表类型 */</span><br><span class="line">struct TblNode &#123;   /* 散列表结点定义 */</span><br><span class="line">    int TableSize; /* 表的最大长度 */</span><br><span class="line">    Cell *Cells;   /* 存放散列单元数据的数组 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int NextPrime( int N )</span><br><span class="line">&#123; /* 返回大于N且不超过MAXTABLESIZE的最小素数 */</span><br><span class="line">    int i, p = (N%2)? N+2 : N+1; /*从大于N的下一个奇数开始 */</span><br><span class="line"></span><br><span class="line">    while( p &lt;= MAXTABLESIZE ) &#123;</span><br><span class="line">        for( i=(int)sqrt(p); i&gt;2; i-- )</span><br><span class="line">            if ( !(p%i) ) break; /* p不是素数 */</span><br><span class="line">        if ( i==2 ) break; /* for正常结束，说明p是素数 */</span><br><span class="line">        else  p += 2; /* 否则试探下一个奇数 */</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashTable CreateTable( int TableSize )</span><br><span class="line">&#123;</span><br><span class="line">    HashTable H;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    H = (HashTable)malloc(sizeof(struct TblNode));</span><br><span class="line">    /* 保证散列表最大长度是素数 */</span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line">    /* 声明单元数组 */</span><br><span class="line">    H-&gt;Cells = (Cell *)malloc(H-&gt;TableSize*sizeof(Cell));</span><br><span class="line">    /* 初始化单元状态为“空单元” */</span><br><span class="line">    for( i=0; i&lt;H-&gt;TableSize; i++ )</span><br><span class="line">        H-&gt;Cells[i].Info = Empty;</span><br><span class="line"></span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>######## 线性探测法 Linear Probing</p>
<blockquote>
<p>  线性探测法：以增量序列1， 2， ……，(TableSize-1),循环试探下一个存储地址</p>
</blockquote>
<pre><code>【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，
    散列表表厂TableSize=13 (装填因子α=9/13≈0.69)；
    散列函数为：h(key)=key mod 11
    用线性探测法处理冲突，列出依次插入后的散列表，并估算查找性能

    关键字(key) | 47 |  7  |  29  |  11  |  9  |  84  |  54  |  20  |  30  |
    -|-|-|-|-|-|-|-|-|-
    散列地址h(key) | 3 | 7 | 7 | 0 | 9 | 7 | 10 | 9 | 8 |
    冲突次数 | 0 | 0 | 1 | 0 | 0 | 3 | 1 | 3 | 6 |</code></pre><p><img src="/images/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.png" alt="线性探测法"></p>
<pre><code>散列表查找性能分析：平均查找次数/平均查找长度
成功平均查找长度ASLs
不成功平均查找长度ASLu

散列表：
H(key) | 0 |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  10  |  11  |  12  
    -|-|-|-|-|-|-|-|-|-
    key | 11 | 30 |  | 47 |  |  |  | 7 | 29 | 9 | 84 | 54 | 20 |
    冲突次数 | 0 | 6 |  | 0 |  |  |  | 0 | 1 | 0 | 3 | 1 | 3 |

【分析】
ASLs： 查找表中关键字的平均查找比较次数(其冲突次数加1)
ASLs = (1 + 7 + 1 + 1 + 2 + 1 + 4 + 2 + 4)/9 = 23/9 ≈ 2.56
ASLu： 不在散列表中的关键词的平均查找次数(不成功)
    一般方法：将不在散列表中的关键词分若干类
        如：根据H(key)值分类 // 额这个我没看懂
    ASLu = (3 + 2 + 1 + 2 + 1 + 1 + 1 + 9 + 8 + 7 + 6) / 11 = 41/11 ≈ 3.73</code></pre><p>######## 平方探测法 Quadratic Probing – 二次探测</p>
<blockquote>
<p>  平方探测法：以增量序列1^2， -1^2， 2^2， -2^2，……， q^2,-q^2且q&lt;=|TableSize/2|,循环试探下一个存储地址<br>    【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，<br>        散列表表厂TableSize=13 (装填因子α=9/13≈0.69)；<br>        散列函数为：h(key)=key mod 11<br>        用平方探测法处理冲突，列出依次插入后的散列表，并估算查找性能ASLs</p>
</blockquote>
<pre><code>关键字(key) | 47 |  7  |  29  |  11  |  9  |  84  |  54  |  20  |  30  |
-|-|-|-|-|-|-|-|-|-
散列地址h(key) | 3 | 7 | 7 | 0 | 9 | 7 | 10 | 9 | 8 |
冲突次数 | 0 | 0 | 1 | 0 | 0 | 2 | 0 | 3 | 3 |</code></pre><p><img src="/images/%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95.png" alt="平方探测法"><br>        ASLs = (1+1+2+1+1+3+1+4+4)/9 = 18/9 = 2 平均成功查找次数</p>
<pre><code>是否有空间，平方探测(二次探测)就能找到？ 明明有空间，但是就是找不到</code></pre><p><img src="/images/%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="平方探测的问题"></p>
<pre><code>    跳来跳去就是找不到后面两个空位，但是避免了线性探测也很大的问题，就是聚集现象，二次探测也有聚集现象但没那么严重

    有定理显示：如果散列表长度TableSize是某个4k+3(k是正整数)形式的素数时，平方探测法就可以探查到整个散列表空间。

        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 平方探测法的查找与插入</span><br><span class="line">Position Find( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position CurrentPos, NewPos;</span><br><span class="line">    int CNum = 0; /* 记录冲突次数 */</span><br><span class="line"></span><br><span class="line">    NewPos = CurrentPos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */</span><br><span class="line">    /* 当该位置的单元非空，并且不是要找的元素时，发生冲突 */</span><br><span class="line">    while( H-&gt;Cells[NewPos].Info!=Empty &amp;&amp; H-&gt;Cells[NewPos].Data!=Key ) &#123;</span><br><span class="line">                                        /* 字符串类型的关键词需要 strcmp 函数!! */</span><br><span class="line">        /* 统计1次冲突，并判断奇偶次 */</span><br><span class="line">        if( ++CNum%2 )&#123; /* 奇数次冲突 */</span><br><span class="line">            NewPos = CurrentPos + (CNum+1)*(CNum+1)/4; /* 增量为+[(CNum+1)/2]^2 */</span><br><span class="line">            if ( NewPos &gt;= H-&gt;TableSize )</span><br><span class="line">                NewPos = NewPos % H-&gt;TableSize; /* 调整为合法地址 */</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; /* 偶数次冲突 */</span><br><span class="line">            NewPos = CurrentPos - CNum*CNum/4; /* 增量为-(CNum/2)^2 */</span><br><span class="line">            while( NewPos &lt; 0 )</span><br><span class="line">                NewPos += H-&gt;TableSize; /* 调整为合法地址 */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NewPos; /* 此时NewPos或者是Key的位置，或者是一个空单元的位置（表示找不到）*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Insert( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position Pos = Find( H, Key ); /* 先检查Key是否已经存在 */</span><br><span class="line"></span><br><span class="line">    if( H-&gt;Cells[Pos].Info != Legitimate ) &#123; /* 如果这个单元没有被占，说明Key可以插入在此 */</span><br><span class="line">        H-&gt;Cells[Pos].Info = Legitimate;</span><br><span class="line">        H-&gt;Cells[Pos].Data = Key;</span><br><span class="line">        /*字符串类型的关键词需要 strcpy 函数!! */</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;键值已存在&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

再散列Rehashing</code></pre><h6 id="二次聚集现象"><a href="#二次聚集现象" class="headerlink" title="二次聚集现象"></a>二次聚集现象</h6><blockquote>
<p>  指在处理冲突过程中发生的两个第一个哈希地址不同的记录争夺同一个后继哈希地址的现象</p>
</blockquote>
<h5 id="BST树-二叉搜索树-Binary-Search-Tree"><a href="#BST树-二叉搜索树-Binary-Search-Tree" class="headerlink" title="BST树(二叉搜索树) Binary Search Tree"></a>BST树(二叉搜索树) Binary Search Tree</h5><blockquote>
<pre><code>也称二叉排序树或二叉查找树
查找问题：
    静态查找与动态查找
    针对动态查找，数据如何组织？</code></pre></blockquote>
<h6 id="BST树定义、性质、ADT及其实现"><a href="#BST树定义、性质、ADT及其实现" class="headerlink" title="BST树定义、性质、ADT及其实现"></a>BST树定义、性质、ADT及其实现</h6><blockquote>
<p>  二叉搜索树： 一颗二叉树，可以为空，如果不为空，满足以下性质：<br>        1、非空左子树的所有键值小于其根结点的键值<br>        2、非空右子树的所有键值大于其根结点的键值<br>        3、左、右子树都是二叉搜索树</p>
</blockquote>
<pre><code>Position Find(ElementType X, BinTree BST) : 从二叉搜索树BST中查找元素X，返回其所在结点的地址
Position FindMin(BinTree BST): 从二叉搜索树BST中查找并返回最小元素所在结点的地址
Position FindMax(BinTree BST): 从二叉搜索树BST中查找并返回最大元素所在结点的地址
BinTree Insert(ElementType X, BinTree BST)
BinTree Delete(ElementType X, BinTree BST)</code></pre><h6 id="BST树查找、插入、删除算法"><a href="#BST树查找、插入、删除算法" class="headerlink" title="BST树查找、插入、删除算法"></a>BST树查找、插入、删除算法</h6><p>####### 二叉搜索树的查找操作： Find</p>
<blockquote>
<p>  Position Find(ElementType X, BinTree BST) : 从二叉搜索树BST中查找元素X，返回其所在结点的地址<br>    查找从根结点开始，如果树为空，返回NULL<br>    若搜索树非空，则根结点关键字与X进行比较，并进行不同处理：<br>        1、若X小于根结点的键值，只需在左子树中继续搜搜<br>        2、如果X大于根结点的键值，在右子树中进行继续搜索<br>        3、若两者比较结果是相等，搜索完成，返回指向此结点的指针</p>
</blockquote>
<pre><code>                                r  r=X， OK！

                    X&lt;r     Tl     Tr    X&gt;r

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 递归的方法  而且使用的都是尾递归 效率不高</span><br><span class="line">Position Find(ElementType X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    if(!BST) return NULL; // 查找失败</span><br><span class="line">    if(X&gt;BST-&gt;Data)</span><br><span class="line">        return Find(X, BST-&gt;Right); // 在右子树中继续查找</span><br><span class="line">    else if(X&lt;BST-&gt;Data)</span><br><span class="line">        return Find(X, BST-&gt;Left); // 在左子树中继续查找</span><br><span class="line">    else  // X == BST-&gt;Data</span><br><span class="line">        return BST; // 查找成功，返回结点的找到结点的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

由于非递归函数的执行效率高，可将“尾递归”函数改为迭代函数，用循环
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Position IterFind(ElementType X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    while(BST)&#123;</span><br><span class="line">        if(X&gt;BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Right; // 向右子树中移动，继续查找</span><br><span class="line">        else if(X&lt;BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Left; // 向左子树中移动，继续查找</span><br><span class="line">        else // X== BST-&gt;Data</span><br><span class="line">            return BST; // 查找成功，返回结点的找到结点的地址</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL; // 查找失败</span><br><span class="line">&#125;</span><br><span class="line">// 查找的效率决定于树的高度</span><br></pre></td></tr></table></figure>

查找最大和最小元素
    最大元素一定是在树的最右分支的端结点上
    最小元素一定是在树的最左分支的端结点上</code></pre><p><img src="/images/%E6%9C%80%E5%8F%B3%E7%AB%AF%E7%BB%93%E7%82%B9%E5%92%8C%E6%9C%80%E5%B7%A6%E7%AB%AF%E7%BB%93%E7%82%B9.png" alt="最右端结点和最左端结点"><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 查找最小元素的递归函数</span><br><span class="line">Position FindMin(BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    if(!BST) return NULL; // 空的二叉搜索树，返回NULL</span><br><span class="line">    else if(!BST-&gt;Left)</span><br><span class="line">        return BST; // 找到最左叶结点并返回</span><br><span class="line">    else</span><br><span class="line">        return FindMin(BST-&gt;Left); // 沿左分支继续查找</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找最大元素的迭代函数</span><br><span class="line">Position FindMax(BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    if(BST)</span><br><span class="line">        while(BST-&gt;Right) BST = BST-&gt;Right;</span><br><span class="line">        // 沿右分支继续查找，直到最右叶结点</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####### 二叉搜索树的插入</p>
<blockquote>
<p>  【分析】关键是要找到元素应该插入的位置，可以采用与Find类似的方法，插入完成后要保证仍然是二叉搜索树</p>
</blockquote>
<p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5.png" alt="二叉树的插入"></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 二叉搜索树的插入算法</span><br><span class="line">BinTree Insert(ElementType X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    if(!BST)&#123;</span><br><span class="line">        // 若原树为空，生成并返回一个结点的二叉搜索树</span><br><span class="line">        BST = malloc(sizeof(struct TreeNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = NULL;</span><br><span class="line">    &#125;else &#123; // 开始找要插入元素的位置</span><br><span class="line">        if(X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Insert(X, BST-&gt;Left); // 递归插入左子树</span><br><span class="line">        else if(X&gt;BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Insert(X, BST-&gt;Right); // 递归插入右子树</span><br><span class="line">        // else X已经存在，什么都不做</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>####### 二叉搜索树的删除</p>
<blockquote>
<p>  考虑三种情况：<br>    1、要删除的是叶结点：直接删除，并再修改其父结点指针——置为NULL<br>    2、要删除的结点只有一个孩子结点：将其父结点的指针指向要删除结点的孩子结点<br>    3、要删除的结点有左、右两颗子树：<br>        用另一结点替代被删除结点：<strong>右子树的最小元素</strong>或者<strong>左子树的最大元素</strong><br>        1、取右子树的最小元素替代<br>        2、取左子树的最大元素替代</p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BinTree Delete(ElementType X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    if(!BST) printf(&quot;要删除的元素未找到&quot;);</span><br><span class="line">    else if(X&lt;BST-&gt;Data)</span><br><span class="line">        BST-&gt;Left = Delete(X, BST-&gt;Left); // 左子树递归删除</span><br><span class="line">    else if(X&gt;BST-&gt;Data)</span><br><span class="line">        BST-&gt;Right = Delete(X, BST-&gt;Right); // 右子树递归删除</span><br><span class="line">    else // 找到要删除的结点</span><br><span class="line">        if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; // 被删除结点有左右两个子结点</span><br><span class="line">            Tmp = FindMin(BSt-&gt;Right); // 在右子树中找最小的元素填充删除结点</span><br><span class="line">            BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right); // 在删除结点的右子树中删除最小元素</span><br><span class="line">        &#125;else &#123; // 被删除结点有一个或无子结点</span><br><span class="line">            Tmp = BST;</span><br><span class="line">            if(!BST-&gt;Left) // 有右孩子或无子结点</span><br><span class="line">                BST = BST-&gt;Right;</span><br><span class="line">            else if(!BST-&gt;Right) // 有左孩子或无子结点</span><br><span class="line">                BST = BST-&gt;Left;</span><br><span class="line">            free(Tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="平衡树AVL"><a href="#平衡树AVL" class="headerlink" title="平衡树AVL"></a>平衡树AVL</h5><blockquote>
<p>  平衡二叉树<br>    【例】搜索树结点不同插入次序，将导致不同的深度和平均查找长度ASL。<br>        “按照字典顺序比较大小”</p>
</blockquote>
<p><img src="/images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BC%95%E4%BE%8B.png" alt="平衡二叉树引例"><br>    a.自然月份序列<br>        ASL(a) = (1 + 2<em>2 + 3</em>3 + 4<em>3 + 5</em>2 + 6*1)/12 = 3.5<br>    b.按July，Feb，May，Mar，Aug，Jan， Apr，Jun， Oct， Sept， Nov， Dec<br>        ASL(b) = 3.0<br>    c.月份字符串大小顺序<br>        ASL(c) = 6.5</p>
<h6 id="平衡树-AVL-定义、性质、ADT及其实现"><a href="#平衡树-AVL-定义、性质、ADT及其实现" class="headerlink" title="平衡树(AVL)定义、性质、ADT及其实现"></a>平衡树(AVL)定义、性质、ADT及其实现</h6><blockquote>
<p>  平衡二叉树(Blanced Binary Tree) AVL树<br>        空树，或者<strong>任一结点</strong>左、右子树高度差的绝对值不超过1，即|BF(T)| &lt;= 1</p>
</blockquote>
<pre><code>&quot;平衡因子(Blance Factor，简称BF)&quot;：BF(T) = hl - hr,其中hl和hr分别为T的左、右子树的高度，左右子树的高度差</code></pre><p><img src="/images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="平衡二叉树"></p>
<pre><code>平衡二叉树的高度能达到Log2^n吗? 完全二叉树的情况</code></pre><p><img src="/images/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6.png" alt="完全二叉树高度"></p>
<pre><code>设nh高度为h的平衡二叉树的最少结点树，结点数最少时：</code></pre><p><img src="/images/%E6%9C%80%E5%B0%91%E7%BB%93%E7%82%B9%E9%AB%98%E5%BA%A6.png" alt="最少结点高度"><br>    斐波那契序列：F0 = 1； F1 = 1；Fi = Fi-1 + Fi-2 for i&gt;1</p>
<pre><code>给定结点树为n的AVL树的最大高度为O(log2^n)</code></pre><h6 id="平衡树-AVL-查找、插入算法"><a href="#平衡树-AVL-查找、插入算法" class="headerlink" title="平衡树(AVL)查找、插入算法"></a>平衡树(AVL)查找、插入算法</h6><blockquote>
<p>  平衡二叉树的插入和删除都会有一个问题，会破坏原平衡二叉树的平衡，涉及到平衡二叉树的调整，也一定要保证二叉搜索树的条件成立</p>
</blockquote>
<pre><code>RR旋转 右子树的右子树添加</code></pre><p><img src="/images/%E5%8F%B3%E5%8D%95%E6%97%8B.png" alt="右单旋"><br>    不平衡的“发现者”是Mar，“麻烦结点”Nov在发现者右子树的右边，因而叫RR插入，需要RR旋转(右单旋)</p>
<p><img src="/images/%E5%8F%B3%E5%8D%95%E6%97%8B%E8%B0%83%E6%95%B4.png" alt="右单旋调整"></p>
<p><img src="/images/RR%E6%97%8B%E8%BD%AC_01.png" alt="RR旋转_例1"></p>
<p><img src="/images/RR%E6%97%8B%E8%BD%AC_02.png" alt="RR旋转_例2"></p>
<pre><code>LL旋转 左子树的左子树添加</code></pre><p><img src="/images/%E5%B7%A6%E5%8D%95%E9%80%89.png" alt="左单旋"><br>    “发现者”是Mar，“麻烦结点”Apr在发现者的左子树的左边，因而叫LL插入，需要LL旋转(左单旋)</p>
<p><img src="/images/%E5%B7%A6%E5%8D%95%E6%97%8B%E8%B0%83%E6%95%B4.png" alt="左单旋调整"></p>
<pre><code>LR旋转 左右旋转，左子树的右子树上添加</code></pre><p><img src="/images/LR%E6%97%8B%E8%BD%AC.png" alt="LR旋转"></p>
<pre><code>“发现者”是May,&quot;麻烦结点&quot;Jan在左子树的右边，因而叫LR插入，需要LR旋转 ，中间结点旋转到中间位置   </code></pre><p><img src="/images/LR%E6%97%8B%E8%BD%AC%E8%B0%83%E6%95%B4.png" alt="LR旋转调整"></p>
<pre><code>RL旋转 右左旋转，右子树的左子树上添加</code></pre><p><img src="/images/RL%E6%97%8B%E8%BD%AC.png" alt="RL旋转.png"></p>
<p><img src="/images/RL%E6%97%8B%E8%BD%AC%E8%B0%83%E6%95%B4.png" alt="RL旋转调整"></p>
<pre><code>注意：有时候插入元素即便不需要调整结构，也可能需要重新计算一些平衡因子。</code></pre><h6 id="平衡因子的概念"><a href="#平衡因子的概念" class="headerlink" title="平衡因子的概念"></a>平衡因子的概念</h6><blockquote>
<p>  “平衡因子(Blance Factor，简称BF)”：BF(T) = hl - hr,其中hl和hr分别为T的左、右子树的高度，左右子树的高度差</p>
</blockquote>
<h5 id="优先队列与堆"><a href="#优先队列与堆" class="headerlink" title="优先队列与堆"></a>优先队列与堆</h5><blockquote>
<p>  很多时候排队不一定要按时间顺序来进行排队，很多任务会有优先级别，类似CPU的调度，这个时候的排队原则又是什么呢？<br>    优先队列(Priority Queue): 特殊的”队列”,取出元素的顺序是依照元素的优先权(关键字)大小，而不是元素进入队列的先后顺序。</p>
</blockquote>
<h6 id="优先队列与堆的定义"><a href="#优先队列与堆的定义" class="headerlink" title="优先队列与堆的定义"></a>优先队列与堆的定义</h6><blockquote>
<p>  若采用数组或链表实现优先队列<br>    数组：<br>        插入 —— 元素总是插入尾部 O(1)<br>        删除 —— 查找最大(或最小)关键字从数组中删去元素O(n)，需要移动元素O(n)</p>
</blockquote>
<pre><code>链表：
    插入 —— 元素总是插入链表的头部 O(1)
    删除 —— 查找最大(最小)关键字O(n), 删去结点O(1)

有序数组：
    插入 —— 找到合适的位置O(n)或O(log2^n)，移动元素并插入O(n)
    删除 —— 删去最后一个元素 O(1)

有序链表：
    插入 —— 找到合适的位置O(n), 插入元素O(1)
    删除 —— 删除首元素或最后元素 O(1)

是否可以采用二叉树存储结构？
    - 二叉搜索树？ 树可能会歪
    - 如果采用二叉树结构，应更关注插入还是删除？ 重点考虑删除
        - 树结点顺序怎么安排？
        - 树结构怎样？

    最大值在根结点，用堆，完全二叉树进行存储

优先队列的完全二叉树表示：</code></pre><p><img src="/images/%E5%A0%86.png" alt="堆"></p>
<pre><code>堆的两个特性：
    结构性：用数组表示的完全二叉树
    有序性：任一结点的关键字是其子树所有结点的最大值(或最小值)
        “最大堆MaxHeap”, 也称&quot;大顶堆&quot;： 最大值
        “最小堆Minheap”, 也称“小顶堆”： 最小值

堆的ADT 抽象数据类型描述
类型对象：最大堆(MaxHeap)
数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值
操作集：最大堆H∈ MaxHeap, 元素item∈ElementType，主要操作有：
    - MaxHeap Create(int MaxSize): 创建一个空的最大堆
    - Boolean Is Full(MaxHeap H): 判断最大堆H是否已满
    - Insert(MaxHeap H, ElementType item): 将元素item插入最大堆H   **
    - Boolean IsEmpty(MaxHeap H): 判断最大堆H是否为空
    - ElementType DeleteMax(MaxHeap H): 返回H中最大元素 (高优先级) **</code></pre><h6 id="堆的生成"><a href="#堆的生成" class="headerlink" title="堆的生成"></a>堆的生成</h6><blockquote>
<p>  最大堆的建立<br>    堆的一个应用：堆排序<br>    —— 需要先建堆</p>
</blockquote>
<pre><code>建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中。
方法一： 通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为O(NlogN)
方法二：在线性时间复杂度下建立最大堆
    (1) 将N个元素按输入顺序存入，先满足完全二叉树的结构特性
    (2) 调整各结点位置，以满足最大堆的有序特性

建堆时间复杂性： O(n) 树中个结点的高度和

最大堆的操作

    最大堆的创建
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct HeapStruct *MaxHeap;</span><br><span class="line">struct HeapStruct&#123;</span><br><span class="line">    ElementType *Elements; // 存储堆元素的数组</span><br><span class="line">    int Size; // 堆的当前元素个数</span><br><span class="line">    int Capacity // 堆的最大容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MaxHeap Create (int MaxSize)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建容量为MaxSize的空的最大堆</span><br><span class="line">    // 然后对结构里的三个分量进行赋值</span><br><span class="line">    MaxHeap H = malloc(sizeof(struct HeapStruct));</span><br><span class="line">    H-&gt;Elements = malloc((MaxSize+1) * sizeof(ElementType)); // 在申请一个数组空间，从下标为1的地方开始存放</span><br><span class="line">    H-&gt;Size = 0;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Elements[0] = MaxData; // 定义哨兵为大于堆中所有可能元素的值，便于以后更快操作</span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    最大堆的插入
    算法：将新增结点插入到从其父结点到根结点的有序序列中
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Insert(MaxHeap H, ElementType item)</span><br><span class="line">&#123;</span><br><span class="line">    // 将元素item插入到最大堆H，其中H-&gt;Elements[0]已经定义为哨兵</span><br><span class="line">    int i;</span><br><span class="line">    if(IsFull(H))&#123;</span><br><span class="line">        printf(&quot;最大堆已满&quot;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size; // i指向插入堆中的最后一个元素的位置</span><br><span class="line">    for( ; H-&gt;Elements[i/2] &lt; item; i/=2) // 与父结点比较，父结点位置为i/2</span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i/2]; // 向下过滤结点</span><br><span class="line">    // 注意for循环里面的第三个分式，for循环条件满足，i/=2, i赋值为原父结点，然后将值插入到调整后的i结点</span><br><span class="line">    // H-&gt;Element[0]是哨兵元素，它不小于堆中的最大元素，控制循环结束，如果没有哨兵可以在条件加&amp;&amp; i&gt;1</span><br><span class="line">    H-&gt;Elements[i] = item; // 将item插入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        时间复杂度 T(N) = O(logN)

    最大堆的删除
    取出根结点(最大值)元素，同时删除堆的一个结点
    时间复杂度为树的高度：T(N) = O(logN)

        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ElementType DeleteMax(MaxHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    // 从最大堆H中取出键值为最大的元素，并删除一个结点</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType MaxItem, temp;</span><br><span class="line"></span><br><span class="line">    // 1.首先判断堆空不空，如果为空就不需要删除任何东西了</span><br><span class="line">    if(IsEmpty(H))&#123;</span><br><span class="line">        printf(&quot;最大堆已空&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.然后把删的元素先保存起来</span><br><span class="line">    MaxItem = H-&gt;Elements[1]; // 取出根结点最大值</span><br><span class="line"></span><br><span class="line">    // 3.把最后一个元素替换上来</span><br><span class="line">    // 用最大堆中最后一个元素从根结点开始向上过滤下层结点</span><br><span class="line">    temp = H-&gt;Elements[H-&gt;Size--];</span><br><span class="line">    // 4. 找Temp该放在哪里， for循环就找temp的位置， 用parent来指示</span><br><span class="line">    // Parent*2 &lt;= H-&gt;Size; 判断是否有左儿子</span><br><span class="line">    // 然后进入循环找左右儿子里面最大的跟Parent比较</span><br><span class="line">    for(Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child)</span><br><span class="line">    &#123;</span><br><span class="line">        Child = Parent * 2; // Child指向左儿子  右儿子就是Child + 1</span><br><span class="line">        // Child = H-&gt;Size; 意味着左儿子是最后一个元素， Child != H-&gt;Size  意味着一定有右儿子</span><br><span class="line">        if((Child != H-&gt;Size) &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + 1])) // 比较左右儿子</span><br><span class="line">            Child++; </span><br><span class="line">        // Child指向左右子结点的较大者 </span><br><span class="line">        if(temp &gt;= H-&gt;Elements[Child]) break;</span><br><span class="line">        else // 移动temp元素到下一层</span><br><span class="line">            H-&gt;Elements[Parent] = H-&gt;Elements[Child]; // 就是把左右儿子中最大的提上来</span><br><span class="line">        // 然后for循环中的Parent = Child；就是让Parent下去，到左右儿子中最大的那个位置上去</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class="line">    return MaxItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">// 堆的定义与操作</span><br><span class="line">typedef struct HNode *Heap; /* 堆的类型定义 */</span><br><span class="line">struct HNode &#123;</span><br><span class="line">    ElementType *Data; /* 存储元素的数组 */</span><br><span class="line">    int Size;          /* 堆中当前元素个数 */</span><br><span class="line">    int Capacity;      /* 堆的最大容量 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef Heap MaxHeap; /* 最大堆 */</span><br><span class="line">typedef Heap MinHeap; /* 最小堆 */</span><br><span class="line"></span><br><span class="line">#define MAXDATA 1000  /* 该值应根据具体情况定义为大于堆中所有可能元素的值 */</span><br><span class="line"></span><br><span class="line">MaxHeap CreateHeap( int MaxSize )</span><br><span class="line">&#123; /* 创建容量为MaxSize的空的最大堆 */</span><br><span class="line"></span><br><span class="line">    MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode));</span><br><span class="line">    H-&gt;Data = (ElementType *)malloc((MaxSize+1)*sizeof(ElementType));</span><br><span class="line">    H-&gt;Size = 0;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Data[0] = MAXDATA; /* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*/</span><br><span class="line"></span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsFull( MaxHeap H )</span><br><span class="line">&#123;</span><br><span class="line">    return (H-&gt;Size == H-&gt;Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Insert( MaxHeap H, ElementType X )</span><br><span class="line">&#123; /* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if ( IsFull(H) ) &#123; </span><br><span class="line">        printf(&quot;最大堆已满&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size; /* i指向插入后堆中的最后一个元素的位置 */</span><br><span class="line">    for ( ; H-&gt;Data[i/2] &lt; X; i/=2 )</span><br><span class="line">        H-&gt;Data[i] = H-&gt;Data[i/2]; /* 上滤X */</span><br><span class="line">    H-&gt;Data[i] = X; /* 将X插入 */</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define ERROR -1 /* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */</span><br><span class="line"></span><br><span class="line">bool IsEmpty( MaxHeap H )</span><br><span class="line">&#123;</span><br><span class="line">    return (H-&gt;Size == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType DeleteMax( MaxHeap H )</span><br><span class="line">&#123; /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType MaxItem, X;</span><br><span class="line"></span><br><span class="line">    if ( IsEmpty(H) ) &#123;</span><br><span class="line">        printf(&quot;最大堆已为空&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxItem = H-&gt;Data[1]; /* 取出根结点存放的最大值 */</span><br><span class="line">    /* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span><br><span class="line">    X = H-&gt;Data[H-&gt;Size--]; /* 注意当前堆的规模要减小 */</span><br><span class="line">    for( Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2;</span><br><span class="line">        if( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line"></span><br><span class="line">    return MaxItem;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*----------- 建造最大堆 -----------*/</span><br><span class="line">void PercDown( MaxHeap H, int p )</span><br><span class="line">&#123; /* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line"></span><br><span class="line">    X = H-&gt;Data[p]; /* 取出根结点存放的值 */</span><br><span class="line">    for( Parent=p; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2;</span><br><span class="line">        if( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BuildHeap( MaxHeap H )</span><br><span class="line">&#123; /* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */</span><br><span class="line">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    /* 从最后一个结点的父节点开始，到根结点1 */</span><br><span class="line">    for( i = H-&gt;Size/2; i&gt;0; i-- )</span><br><span class="line">        PercDown( H, i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h6 id="调整算法"><a href="#调整算法" class="headerlink" title="调整算法"></a>调整算法</h6><blockquote>
<p>  调整算法在上面对的操作里详细的说明，可以记一下</p>
</blockquote>
<h6 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h6><blockquote>
<p>  这个不知道说的是什么，没找到资料</p>
</blockquote>
<h4 id="四、排序"><a href="#四、排序" class="headerlink" title="四、排序"></a>四、排序</h4><blockquote>
<p>  内容：<br>        排序基本概念；<br>        插入排序，<br>        希尔排序，<br>        选择排序，<br>        快速排序，<br>        合并排序，<br>        基数排序<br>        等排序算法基本思想，算法代码及基本的时间复杂度分析</p>
</blockquote>
<h5 id="排序基本概念"><a href="#排序基本概念" class="headerlink" title="排序基本概念"></a>排序基本概念</h5><blockquote>
<p>  排序算法的效率很重要，大多数情况下，为简单起见，讨论从小到大的整数排序，N是正整数，只讨论基于比较的排序(&gt; = &lt; 有定义)，只讨论内部排序，假设内存空间足够大，排序可一次完成，稳定性：任意两个相等的数据，排序前后的相对位置不发生改变<br>    没有一种排序是任何情况下都表现最好的。</p>
</blockquote>
<h5 id="冒泡排序——不要求"><a href="#冒泡排序——不要求" class="headerlink" title="冒泡排序——不要求"></a>冒泡排序——不要求</h5><pre><code>Bubble Sort,是一种最基础的交换排序
把相邻的元素两两比较，根据大小交换元素位子

原始的冒泡排序是稳定排序，由于冒泡排序每一轮要遍历所有元素，循环的次数和元素数组相当，所以时间复杂度为O(N^2)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Bubble_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    for(P=N-1; P&gt;=0; P--)&#123;</span><br><span class="line">        flag = 0;</span><br><span class="line">        for(i=0; i&lt;P; i++)&#123; // 一趟冒泡</span><br><span class="line">            if(A[i] &gt; A[i+1])&#123;</span><br><span class="line">                Swap(A[i], A[i+1]);</span><br><span class="line">                flag = 1; // 标识发生了交换</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(flag == 0) break; // 全程无交换</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

// 简单 稳定 两两交换
最好情况：顺序T = O(N)  
最坏情况：逆序T = O(N^2)</code></pre><h5 id="插入排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#插入排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="插入排序算法基本思想，算法代码及基本的时间复杂度分析"></a>插入排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<p>  扑克牌抓牌</p>
</blockquote>
<pre><code>就想玩牌一样，插入排序算法也是类似的思想：维护一个有序区，把元素一个一个插入到有序区的适当位置，直到所有元素有序位置，当我们把每一个新元素插入到有序区时，并不需要立马进行元素的两两交换，可以将待插入元素暂存起来，将有序区元素从左向右复制移动位置，找到带插入位置后，将元素插入。

mark first element as sorted 将第一个元素标记为已排序
for each unsorted element X 遍历每个没有排序过的元素
    &apos;extract&apos; the element X 提取元素X
    for j=lastSortedIndex down to 0   j 从最后一个被排序的位置开始到0进行遍历
        if current element j &gt; X  如果当前排序过的元素j &gt; 提取过的元素
            move sorted element to the right by 1 将排序过的元素向右移一格
        break loop and insert X here. 否则插入提取的元素


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 从后往前比</span><br><span class="line">void Insertion_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    int P, i;</span><br><span class="line">    ElementType Tmp;</span><br><span class="line"></span><br><span class="line">    for(P=1; P&lt;N; P++)&#123;</span><br><span class="line">        Tmp = A[P]; // 摸下一张牌,取出末排序序列中的第一个元素</span><br><span class="line">        for(i=P; i&gt;0 &amp;&amp; A[i-1]&gt;Tmp; i--)</span><br><span class="line">            A[i] = A[i-1]; // 移出空位 依次与已排序序列中元素比较并右移</span><br><span class="line">        A[i] = Tmp; // 新牌落位 放进合适的位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

// 稳定
最好情况：顺序T = O(N)
最坏情况：逆序T = O(N^2)</code></pre><h5 id="希尔排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#希尔排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="希尔排序算法基本思想，算法代码及基本的时间复杂度分析"></a>希尔排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<p>  by Donald Shell<br><img src="/images/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="希尔排序"></p>
</blockquote>
<pre><code>怎样可以对插入排序算法做出优化呢？
- 在大多数元素已经有序的情况下，插入排序的工作量较小(因为不用频繁的进行比较和交换)
- 在元素数量较小的情况下，插入排序的工作量较小

我们怎么能让大部分元素有序，或者让元素数量减少呢？
不妨对原始数组进行一些预处理，使得原始数组的大部分元素变得有序，分组排序，以此对数组进行一定的粗略调整

分组跨度，被称为希尔排序的增量，增量的选择可以有很多种。

利用分组粗调的方式减少了直接插入排序的工作量，是的算法的时间复杂度低于O(N^2)

原始希尔排序 Dm = [N/2], Dk = [Dk+1/2]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Shell_sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    for(D=N/2; D&gt;0; D/=2)&#123; // 希尔增量系列</span><br><span class="line">        for(P=D; P&lt;N; P++)&#123; // 插入排序</span><br><span class="line">            Tmp = A[P];</span><br><span class="line">            for(i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D)</span><br><span class="line">                A[i] = A[i-D];</span><br><span class="line">            A[i] = Tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

最快情况： T = cita(N^2)

注意：增量元素不互质，则小增量可能根本不起作用
更多增量序列
- Hibbard增量序列 1, 3, 7, 15……
    Dk = 2^k - 1 相邻元素互质
    最坏情况：T = cita(N^3/2)
- Sedgewick增量序列 {1， 5， 9， 41， 109}
    —— 9*4^i-9*2^i+1 或4^i-3*2^i + 1
    最坏时间复杂度：cita(N^(4/3))

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void ShellSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 希尔排序 - 用Sedgewick增量序列 */</span><br><span class="line">    int Si, D, P, i;</span><br><span class="line">    ElementType Tmp;</span><br><span class="line">    /* 这里只列出一小部分增量 */</span><br><span class="line">    int Sedgewick[] = &#123;929, 505, 209, 109, 41, 19, 5, 1, 0&#125;;</span><br><span class="line">    </span><br><span class="line">    for ( Si=0; Sedgewick[Si]&gt;=N; Si++ ) </span><br><span class="line">        ; /* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span><br><span class="line"></span><br><span class="line">    for ( D=Sedgewick[Si]; D&gt;0; D=Sedgewick[++Si] )</span><br><span class="line">        for ( P=D; P&lt;N; P++ ) &#123; /* 插入排序*/</span><br><span class="line">            Tmp = A[P];</span><br><span class="line">            for ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )</span><br><span class="line">                A[i] = A[i-D];</span><br><span class="line">            A[i] = Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

希尔排序是不稳定排序，值相同的元素可能被调换位置</code></pre><h5 id="选择排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#选择排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="选择排序算法基本思想，算法代码及基本的时间复杂度分析"></a>选择排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
</blockquote>
<pre><code>冒泡排序，就是把每一个元素和下一个元素进行比较和交换，使得较大的元素像气泡一样向右侧移动这样一来，每一轮操作都可以把最大元素移动到最右侧，经过多轮操作，无序的数列称为了升序数列，冒泡排序有一个很大的弊端，就是元素交换次数太多了。频繁的数组元素交换意味着更多的内存读写操作，严重影响了代码运行效率

每一轮选出最小者直接交换到左侧的思路，就是选择排序的思路，这种排序的最大优势就是省去了多余的元素交换。

选择排序存在一个明显问题，就是不稳定性也就是说，当数列包含多个值相等的元素时，选择排序有可能打乱它们的原有顺序。

repeat (numOfElements - 1) times 重复(元素个数 - 1)次
set the first unsorted element as the minum 把第一个没有排序过的元素设置为最小值
for each of the unsorted elements 遍历每个没有排序过的元素
    if element &lt; currentMinimum 如果元素 &lt; 现在的最小值
        set element as new minimum 将此元素设置成为新的最小值
swap minimum with first unsorted position 将最小值和第一个没有排序过的位置交换

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Selection_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    for(i=0; i&lt;N; i++)&#123;</span><br><span class="line">        MinPosition = ScanForMin(A, i, N-1); // 从A[i]到A[N-1]中找最小元，并将其位置赋给MinPosition</span><br><span class="line">        Swap(A[i], A[MinPostion]); // 将末排序部分的最小元换到有序部分的最后位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

无论如何： T = cita(N^2)  如何快速找到最小元？ 这个地方用到了堆排序

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void Swap( ElementType *a, ElementType *b )</span><br><span class="line">&#123;</span><br><span class="line">    ElementType t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PercDown( ElementType A[], int p, int N )</span><br><span class="line">&#123;   /* 改编代码4.24的PercDown( MaxHeap H, int p )    */</span><br><span class="line">    /* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line"></span><br><span class="line">    X = A[p]; /* 取出根结点存放的值 */</span><br><span class="line">    for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2 + 1;</span><br><span class="line">        if( (Child!=N-1) &amp;&amp; (A[Child]&lt;A[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= A[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            A[Parent] = A[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    A[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapSort( ElementType A[], int N ) </span><br><span class="line">&#123; /* 堆排序 */</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    for ( i=N/2-1; i&gt;=0; i-- )/* 建立最大堆 */</span><br><span class="line">        PercDown( A, i, N );</span><br><span class="line">    </span><br><span class="line">    for ( i=N-1; i&gt;0; i-- ) &#123;</span><br><span class="line">        /* 删除最大堆顶 */</span><br><span class="line">        Swap( &amp;A[0], &amp;A[i] ); /* 见代码7.1 */</span><br><span class="line">        PercDown( A, 0, i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="快速排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#快速排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="快速排序算法基本思想，算法代码及基本的时间复杂度分析"></a>快速排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<pre><code>快速排序是从冒泡排序演变过来的算法，但是比冒泡排序要高效的多，所以叫做快速排序。快速排序之所以快速，是因为它使用了分治法。同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大元素移动到数列的另一边，从而把数列拆解成了两个部分。这种思想就叫做分治法。在分治法的思想下原数列在每一轮被拆解分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。</code></pre></blockquote>
<pre><code>**分而治之**</code></pre><p><img src="/images/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B.png" alt="分而治之"></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Quicksort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    if(N &lt; 2) return; // 如果只有一个元素，直接return</span><br><span class="line">    pivot = 从A[]中选一个元 // ？怎么选主元</span><br><span class="line">    将S = &#123; A[] \ pivot &#125; 分成2个独立子集：// ？怎么分子集</span><br><span class="line">        A1 = &#123; a∈S | a&lt;= pivot &#125; 和</span><br><span class="line">        A2 = &#123; a∈S | a&lt;= pivot &#125;;</span><br><span class="line"></span><br><span class="line">    A[] = Quicksort(A1, N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2, N2);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

什么是快速排序算法的最好的情况？
每次正好中分 =&gt; T(N) = O(NlogN)

平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是O(nlogn)

那么基准元素是如何选出呢？又如何把其他元素移动到基准元素的两端呢？
基准元素的选择，以及元素的移动，都是快速排序的核心问题。

**选主元**
-  最简单的方式是选择数列的第一个元素 令pivot = A[0]
        这种选择在绝大多数情况下是没问题的，但是假如有一个原本逆序或顺序的数列，期望排序成顺序序列，整个数列并没有被分成一半一半，每一轮仅仅确定了基准元素的位置，这种情况下数列第一个要么是最小值，要么是最大值，根本无法发挥分治法的优势，在这种极端情况下，快速排序需要进行N轮，时间复杂度化成了O(N^2)</code></pre><p><img src="/images/%E9%80%89%E4%B8%BB%E5%85%83.png" alt="选主元"></p>
<pre><code>-  可以不选择数列第一个元素，而是随机选择一个元素作为基准元素 rand()函数不便宜
        这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分，当然即使是随机选择基准元素，每次也有极小的几率选到数列的最大值或最小值，同样会影响分治的效果。
-   取头、中、尾的中位数
        例如 8、12、3的中位数就是8

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ElementType Median3(ElementType A[], int Left, int Right)</span><br><span class="line">&#123;</span><br><span class="line">    int Center = (Left + Right) / 2;</span><br><span class="line">    if(A[Left] &gt; A[Center])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Center]);</span><br><span class="line">    if(A[Left] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Right]);</span><br><span class="line">    if(A[Center] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Center], &amp;A[Right]);</span><br><span class="line">    // A[Left] &lt;= A[Center] &lt;= A[Right]</span><br><span class="line">    Swap(&amp;A[Center], &amp;A[Right - 1]); // 将pivot藏到右边</span><br><span class="line">    // 只需要考虑A[Left + 1]  …… A[Right - 2]</span><br><span class="line"></span><br><span class="line">    return A[Right - 1] ;// 返回pivot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**子集划分**</code></pre><p><img src="/images/%E5%AD%90%E9%9B%86%E5%88%92%E5%88%86.png" alt="子集划分"></p>
<pre><code>如果有元素正好等pivot怎么办？ 停下来交换

快速排序的问题：
    用递归
    对于小规模的数据(例如N不到100)可能还不如插入排序快


解决方案
    - 当递归的数据规模充分小，则停止递归，直接调用简单排序（例如插入排序）
    - 在程序中定义一个Cutoff的阈值


一次排序就会把主元放到正确的位置上，以后也不会移动，这也是快速排序快的原因

算法实现
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序</span><br><span class="line">ElementType Median3(ElementType A[], int Left, int Right)&#123;</span><br><span class="line">    int Center = (Left + Right) /2;</span><br><span class="line">    if(A[ left ] &gt; A[ Center ]) Swap(&amp;A[ Left ], &amp;A[ Center ]);</span><br><span class="line">    if(A[ left ] &gt; A[ Right ]) Swap(&amp;A[ Left ], &amp;A[ Right ]);</span><br><span class="line">    if(A[ Center ] &gt; A[ Right ]) Swap(&amp;A[ Center ], &amp;A[ Right ]);</span><br><span class="line">    // 此时A[ Left ] &lt; A[ Center ] &lt; A[ Right ]</span><br><span class="line">    Swap(&amp;A[ Center ], &amp;A[ Right-1 ]); // 将基准pivot藏到右边</span><br><span class="line">    // 只需要考虑A[Left + 1]...A[Right -2]</span><br><span class="line">    return A[Right - 1]; // 返回基准Pivot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Qsort(ElementType A[], int Left, int Right)&#123;</span><br><span class="line">    // 核心递归函数</span><br><span class="line">    int Pivot, Cutoff, Low, High;</span><br><span class="line">    if( Cutoff &lt;= Right - Left)&#123; // 阈值，如果序列元素充分多，做快速排序</span><br><span class="line">        Pivot = Median3(A, Left, Right); // 选主元 选基准</span><br><span class="line">        Low = Left; High = Right - 1; // 划分子集</span><br><span class="line">        while (1)&#123; // 将序列中比基准小的移动到基准的左边，大的移到右边</span><br><span class="line">            while (A[ ++Low ] &lt; Pivot) &#123; &#125;</span><br><span class="line">            while (A[ --Right ] &gt; Pivot) &#123; &#125;</span><br><span class="line">            if(Low &lt; High) Swap(&amp;A[Low], &amp;A[High]);</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 然后把pivot放到正确的位置,将基准换到正确的位置</span><br><span class="line">        Swap(&amp;A[Low], &amp;A[Right-1]); // 把藏到Right-1 上的主元换到A[i]上去</span><br><span class="line">        // 递归排序自集 主元在i的位置上</span><br><span class="line">        Qsort(A, Left, Low-1); // 递归解决左半子集</span><br><span class="line">        Qsort(A, Low+1, Right); // 递归解决右半子集</span><br><span class="line">    &#125; else &#123; // 否则做插入排序 数据太少用简单排序</span><br><span class="line">        Insertion_Sort(A+Lfet, Right-left+1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用一个壳套住 </span><br><span class="line">void QuickSort(ElementType A[], int N)</span><br><span class="line">&#123; // 统一接口</span><br><span class="line">    Qsort(A, 0, N-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="合并排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#合并排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="合并排序算法基本思想，算法代码及基本的时间复杂度分析"></a>合并排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<pre><code>每个小组内部先比较出先后顺序之后，小组之间会展开进一步的比较和排序，合并成一个大组；大组之间继续比较和排序，再合并成更大的组……最终，所有的元素合并成一个有序集合。</code></pre></blockquote>
<p><img src="/images/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="合并排序"></p>
<pre><code>这个比较与合并的过程叫做归并，Merge

核心：有序子列的归并</code></pre><p><img src="/images/%E6%9C%89%E5%BA%8F%E5%AD%90%E5%88%97%E7%9A%84%E5%BD%92%E5%B9%B6.png" alt="有序子列的归并"></p>
<pre><code>如果两个子列一共有N个元素，则归并的时间复杂度是？ T(N) = O(N)



递归算法：

典型分而治之的应用

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序 —— 递归实现</span><br><span class="line">// L = 左边起始位置，R = 右边起始位置，RightEnd = 右边终点位置</span><br><span class="line">void Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">    // 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列</span><br><span class="line">    int LeftEnd， NumElements, Tmp;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    LeftEnd = R-1; // 左边终点位置 ，假设左右两列挨着</span><br><span class="line">    Tmp = L; // 有序序列的起始位置  存放结果的数组的初始位置</span><br><span class="line">    NumElements = RightEnd - L + 1;</span><br><span class="line"></span><br><span class="line">    // 归并过程</span><br><span class="line">    while(L&lt;=LeftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        if(A[L]&lt;= A[R])</span><br><span class="line">            TmpA[Tmp++] = A[L++]; // 将左边元素复制到TmpA</span><br><span class="line">        else</span><br><span class="line">            TmpA[Tmp++] = A[R++]; // 将右边的元素复制到TmpA</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(L&lt;= LeftEnd)</span><br><span class="line">        TmpA(Tmp++) = A[L++]; // 直接复制左边剩下的</span><br><span class="line">    while(R&lt;= RightEnd)</span><br><span class="line">        TmpA(Tmp++) = A[R++]; // 直接复制右边剩下的</span><br><span class="line"></span><br><span class="line">    // 此时TmpA为归并以后的结果，再将TmpA中的结果倒回到A里， 起始位置可能会有变化，从后往回倒，一共执行NumElements次</span><br><span class="line">    for(i=0; i&lt;NumElements; i++, RightEnd--)</span><br><span class="line">        A[RightEnd] = TmpA[RightEnd]; // 将有序的TmpA[]复制回A[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Msort(ElementType A[], ElementType TmpA[], int L, int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">    // A[] 待排数组 TmpA[] 临时数组 L 当前待排数组最左边位置 RightEnd当前待排数组最右边位置</span><br><span class="line">    // 核心递归排序函数</span><br><span class="line">    int Center; /// 记录中间位置，将待排数组一分为二</span><br><span class="line"></span><br><span class="line">    if(L &lt; RightEnd) &#123; // 当待排序列有元素的时候</span><br><span class="line">        Center = (L+RightEnd)/2;</span><br><span class="line">        Msort(A, TmpA, L, Center); // 递归解决左边</span><br><span class="line">        Msort(A, TmpA, Center+1, RightEnd); // 递归解决右边</span><br><span class="line">        Merge(A, TmpA, Center+1, RightEnd); // 合并两段有序序列</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSort(ElmentType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    // 归并排序</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line">    TmpA = (ElementType *)malloc(N*sizeof(ElementType)); // 这个时候的好处，临时数组只要创建和销毁一次</span><br><span class="line"></span><br><span class="line">    if(TmpA != NULL)&#123;</span><br><span class="line">        Msort(A, TmpA, 0, N-1);</span><br><span class="line">        free(TmpA);</span><br><span class="line">    &#125;</span><br><span class="line">    else printf(&quot;空间不足&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

T(N) = T(N/2) + T(N/2) + O(N) 
T(N) = O(NlogN)
稳定



非递归算法</code></pre><p><img src="/images/%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95.png" alt="非递归合并算法"></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序 —— 循环实现</span><br><span class="line"></span><br><span class="line">void Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">    // 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列</span><br><span class="line">    int LeftEnd， NumElements, Tmp;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    LeftEnd = R-1; // 左边终点位置 ，假设左右两列挨着</span><br><span class="line">    Tmp = L; // 有序序列的起始位置  存放结果的数组的初始位置</span><br><span class="line">    NumElements = RightEnd - L + 1;</span><br><span class="line"></span><br><span class="line">    // 归并过程</span><br><span class="line">    while(L&lt;=LeftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        if(A[L]&lt;= A[R])</span><br><span class="line">            TmpA[Tmp++] = A[L++]; // 将左边元素复制到TmpA</span><br><span class="line">        else</span><br><span class="line">            TmpA[Tmp++] = A[R++]; // 将右边的元素复制到TmpA</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(L&lt;= LeftEnd)</span><br><span class="line">        TmpA(Tmp++) = A[L++]; // 直接复制左边剩下的</span><br><span class="line">    while(R&lt;= RightEnd)</span><br><span class="line">        TmpA(Tmp++) = A[R++]; // 直接复制右边剩下的</span><br><span class="line"></span><br><span class="line">    &lt;!-- </span><br><span class="line">    // 非递归算法不用最后这步</span><br><span class="line">    // 此时TmpA为归并以后的结果，再将TmpA中的结果倒回到A里， 起始位置可能会有变化，从后往回倒，一共执行NumElements次 </span><br><span class="line">    for(i=0; i&lt;NumElements; i++, RightEnd--)</span><br><span class="line">        A[RightEnd] = TmpA[RightEnd]; // 将有序的TmpA[]复制回A[] </span><br><span class="line">    --&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这个是一趟的归并</span><br><span class="line">// N整个待排序列长度</span><br><span class="line">// Length = 当前有序子列的长度 Length在初始的时候是1，在执行的过程中lenght要加倍</span><br><span class="line">void Merge_pass(ElementType A[], ElementType TmpA[], int N, int length)</span><br><span class="line">&#123;   </span><br><span class="line">    // 两两归并相邻有序子列</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    for(i=0; i&lt;N-2*length; i+=2*length)  // i+=2*length 跳过两段去找下一对 结束条件保证把成对的处理完</span><br><span class="line">        Merge(A, TmpA, i, i+length, i+2*length-1);  // 这里的merge跟递归算法里的merge有点不一样，不做最后一步，不用将TmpA里的数据写回到A</span><br><span class="line">        // 从左到右一对一对的执行Merge i最左边位置， i+length跳过子列长度下一列的初始位置， i+2*length-1 下一段的终止位置</span><br><span class="line">    if(i+length &lt; N) // 说明最后不止一个子列，归并最后2个子列</span><br><span class="line">        Merge(A, TmpA. i, i+length, N-1); // 注意最后一个子列的结尾无论如何都是N-1</span><br><span class="line">    else // 最后只剩1个子列， 直接把剩下的A倒到TmpA里面去</span><br><span class="line">        for(j=i; j&lt;N; j++) TmpA[j] = A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    int length;</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line"></span><br><span class="line">    length = 1; // 初始化子序列长度</span><br><span class="line">    TmpA = malloc(N * sizeof(ElementType)); // 申请一个临时数组跟原始数组等长的数组</span><br><span class="line">    if(TmpA != NULL)&#123;</span><br><span class="line">        while(length &lt; N)&#123;</span><br><span class="line">            Merge_pass(A, TmpA, N, length); // 一趟归并A将结果存在在TmpA中</span><br><span class="line">            length *= 2;</span><br><span class="line">            Merge_pass(TmpA, A, N, length); // 将归并后的结果TmpA倒回到A里</span><br><span class="line">            length *=2;</span><br><span class="line"></span><br><span class="line">            // 归并两次的原因，保证归并后的结果是存放在A里面的</span><br><span class="line">        &#125;</span><br><span class="line">        free(TmpA);</span><br><span class="line">    &#125;</span><br><span class="line">    else prinft(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

额外空间复杂度是 O(N)
T(N) = T(N/2) + T(N/2) + O(N) 
T(N) = O(NlogN)


Merge Sort是稳定的
主要用于外排，不用于内排</code></pre><h5 id="基数排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#基数排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="基数排序算法基本思想，算法代码及基本的时间复杂度分析"></a>基数排序算法基本思想，算法代码及基本的时间复杂度分析</h5><h4 id="五、图"><a href="#五、图" class="headerlink" title="五、图"></a>五、图</h4><blockquote>
<p>  内容：<br>        图的基本概念<br>        图的存储结构<br>            - 邻接矩阵<br>            - 邻接表<br>        图的遍历<br>            - 广度优先遍历<br>            - 深度优先遍历；<br>        最小生成树基本概念<br>            - Prim算法<br>            - Kruskal算法<br>        最短路径问题<br>            - 广度优先遍历算法<br>            - Dijkstra算法<br>            - Floyd算法；<br>        拓扑排序</p>
</blockquote>
<h5 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h5><p><img src="/images/%E5%9B%BE%E7%9A%84%E5%BC%95%E4%BE%8B.png" alt="图的引例"><br>    从陈家村到张家村，怎么走最快呢？ 图最经典的最短路径问题<br>    怎么修公路使的村村通的花费最少呢？ 图最经典的最小生成树问题<br>    边可以理解为一种关系<br><img src="/images/%E5%9C%B0%E9%93%81%E7%BA%BF%E8%B7%AF.png" alt="地铁线路"></p>
<pre><code>什么是“图”(Graph)
    - 表示“多对多”的关系 【包含线性表和树的关系】
    - 包含
        - 一组顶点：通常用V(Vertex)表示顶点集合
        - 一组边：通常用E(Edge)表示边的集合
            - 边是顶点对：(v,w) ∈ E，其中v,w ∈ V    v —— w 双向 圆括号表示
            - 有向边&lt;v,w&gt;表示从v指向w的边(单行边)    v ——&gt; w 单向 尖括号表示
            - 不考虑重边和自回路   </code></pre><p><img src="/images/%E9%87%8D%E8%BE%B9%E5%92%8C%E8%87%AA%E5%9B%9E%E8%B7%AF.png" alt="重边和自回路"></p>
<pre><code>抽象数据类型定义 ADT
- 类型名称： 图 (Graph)
- 数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成
- 操作集：对于任意图G ∈ Graph，以及v ∈ V，e ∈ E
    - Graph Create(): 建立并返回空图
    - Graph InsertVertex(Graph G, Vertex v): 将v插入G
    - Graph InsertEdge(Graph G, Edge e): 将e插入G
    - void DFS(Graph G, Vertex v): 从顶点v出发深度优先遍历图G
    - void BFS(Graph G, Vertex v): 从顶点v出发广度优先遍历图G
    - void ShortestPath(Graph G, Vertex v, int Dist[]): 计算图G中顶点v到任意其他顶点的最短距离
    - void MST(Graph G): 计算图G的最小生成树
    ……</code></pre><p><img src="/images/%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%89%E5%90%91%E5%9B%BE.png" alt="无向图有向图"><br>    如果图中所有边无所谓反向，称为无向图<br>    图中边有可能双向有可能单向，称为有向图<br>    边上有数字，叫权重，权重可以赋予现实中的各种意义，带权重的图叫网络</p>
<h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h5><blockquote>
<p>  怎么在程序中表示一个图，以下不止邻接矩阵和邻接表两种方法，还可以有别的方法。</p>
</blockquote>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><blockquote>
<p>  邻接矩阵G[N][N]——N个顶点从0到N-1编号<br>        G[i][j] = {  1   若&lt;vi, vj&gt;是G中的边<br>                    0   否则               }</p>
</blockquote>
<p><img src="/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="邻接矩阵"></p>
<pre><code>    不允许自回路边，所以对角线全为0, 对称阵，其实有一条边存了两次，显然浪费空间


邻接矩阵
    - 问题：对于无向图的存储，怎样可以省一半空间?
        只存下三角，用一维元素</code></pre><p><img src="/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%97%A0%E5%90%91%E5%9B%BE.png" alt="邻接矩阵无向图"><br>    问题：Vi和Vj之间若没有边怎么办？</p>
<pre><code>邻接矩阵 —— 有什么好处？
- 直观、简单、好理解
- 方便检查任意一对顶点间是否存在边
- 方便找任一顶点的所有“邻接点”（有边直接相连的顶点）
- 方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数为“入度”）
    · 无向图：对应行(或列)非0元素的个数
    · 有向图：对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度”
邻接矩阵 —— 有什么不好？
- 浪费空间 —— 存稀疏图（点很多而边很少）有大量无效元素
    · 对稠密图(特别是完全图)还是很合算的
- 浪费时间 —— 统计稀疏图中一共有多少条边

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// 大纲没有要求，可以看看，有对图有编码的感觉</span><br><span class="line">/* 图的邻接矩阵表示法 */</span><br><span class="line">#define MaxVertexNum 100  /* 最大顶点数设为100*/</span><br><span class="line">#define INFINITY 65535  /* ∞设为双字节无符号整数的最大值65535*/</span><br><span class="line">typedef int Vertex;  /* 用顶点下标表示顶点，为整型*/</span><br><span class="line">typedef int WeightType;  /* 边的权值设为整型 */ </span><br><span class="line">typedef char DataType;  /*  顶点存储的数据类型设为字符型 */</span><br><span class="line"></span><br><span class="line">/* 边的定义*/</span><br><span class="line">typedef struct ENode *PtrToENode; // 指向边结点的指针</span><br><span class="line">struct ENode &#123;</span><br><span class="line">    Vertex V1, V2; // 有向边&lt;V1, V2&gt; 两个顶点</span><br><span class="line">    WeightType Weight; // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">/*图结点的定义*/</span><br><span class="line">typedef struct GNode *PtoToGNode; // 指向结点的指针</span><br><span class="line">struct GNode &#123;</span><br><span class="line">    int Nv; // 顶点数</span><br><span class="line">    int Ne; // 边数</span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum]; // 邻接矩阵  定义二维数组</span><br><span class="line">    DataType Data[MaxVertexNum];  // 存顶点的数据</span><br><span class="line">    // 在很多情况下，顶点无数据，此时Data[]可以不用出现</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode MGraph; // 以邻接矩阵存储的图类型</span><br><span class="line"></span><br><span class="line">// 初始化一个有VertexNum个顶点但没有边的图</span><br><span class="line">MGraph CreateGraph(int VertexNum)&#123;</span><br><span class="line">    Vertex V, W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = (MGraph)malloc(sizeof(struct GNode)); // 建立图</span><br><span class="line">    Graph -&gt; Nv = VertexNum;</span><br><span class="line">    Graph -&gt; Ne = 0;</span><br><span class="line">    // 初始化邻接矩阵</span><br><span class="line">    // 注意：这里默认顶点编号从0开始，到(Graph -&gt; Nv - 1)</span><br><span class="line">    for(V=0; V &lt; Graph-&gt;Nv, V++)</span><br><span class="line">        for(W=0; W &lt; Graph-&gt;Nv; W++)</span><br><span class="line">            Graph-&gt;G[V][W] = INFNITY; //或“0” 表示没有变</span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 向MGraph中插入边</span><br><span class="line">void InsertEdge(MGraph Graph, Edge E)&#123;</span><br><span class="line">    // 插入边&lt;V1, V2&gt;</span><br><span class="line">    Graph -&gt; G[E-&gt;V1][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">    // 若是无向图，还要插入边&lt;V2, V1&gt;</span><br><span class="line">    Graph -&gt; G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 完整地建立一个MGraph</span><br><span class="line">// - 输入格式：Nv Ne</span><br><span class="line">// V1 V2 Weight</span><br><span class="line">MGraph BuildGraph()&#123;</span><br><span class="line">    // 声明临时变量</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    int Nv, i;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv); // 读入顶点个数</span><br><span class="line">    Graph = CreateGraph(Nv); // 初始化有Nv个顶点 但没有边的图</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne)); // 读入边数</span><br><span class="line">    if( Graph -&gt; Ne != 0)&#123; // 如果Ne为零，表示读进来的边数，就是没有一条边，就可以直接退出</span><br><span class="line">        E = (Edge) malloc (sizeof(struct ENode)); // 建立临时边结点，去存读入的边</span><br><span class="line">        // 读入边，格式为“起点 终点 权重”，插入邻接矩阵</span><br><span class="line">        for(i=0; i&lt;Graph-&gt;Ne;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">            // 注意：如果权重不是整型，Weight的读入格式要改</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果顶点有数据的话，读入数据</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        scanf(&quot;%c&quot;, &amp;(Graph-&gt;Data[V]));</span><br><span class="line"></span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 简短一点写，核心代码可简化为</span><br><span class="line">int G[MAXN][MAXN], Nv, Ne;</span><br><span class="line">void BuildGraph()&#123;</span><br><span class="line">    int i, j, v1, v2, w;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv);</span><br><span class="line">    // CreateGraph</span><br><span class="line">    for(i=0; i&lt;Nv; i++&gt;)</span><br><span class="line">        for(j=0; j&lt;Nv; j++&gt;)</span><br><span class="line">            G[i][j] = 0; // 或INFINITY</span><br><span class="line">            </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Ne);</span><br><span class="line">    for(i=0; i&lt;Ne; i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;, &amp;v1, &amp;v2, &amp;w);</span><br><span class="line">        // InsertEdge</span><br><span class="line">        G[v1][v2] = w;</span><br><span class="line">        G[v2][v1] = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><blockquote>
<p>  怎么在程序中表示一个图的另一种表示法 —— 邻接表<br>    邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素<br>    <strong>对于网络，结构中要增加权值的域</strong><br>    为每一个结点开一个指针，指针数组，数组的元素是头指针</p>
</blockquote>
<p><img src="/images/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="邻接表"></p>
<pre><code>邻接表的表示不唯一，链表的顺序不唯一
无向边被存了两遍

邻接表一定要够稀疏才够合算

邻接表的好处？
- 方便还找任一顶点的所有“邻接点”
- 节约稀疏图的空间
    -   需要N个头只在指针 + 2E个结点（每个结点至少2个域）
- 方便计算任一顶点的“度”？
    - 对无向图：是的
    - 对有向图：只能计算“出度”;需要构造“逆邻接表”（存指向自己的边）来方便计算&quot;入度&quot;
- 方便检查任意一对顶点间是否存在边？
    NO

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">// 大纲没有要求，可以看看，有点对图有编码的感觉</span><br><span class="line">// 图的邻接表表示法</span><br><span class="line">#define MaxVertexNum 100 //最大顶点数设为100</span><br><span class="line">typedef int Vertex; // 用顶点下标表示顶点，为整型</span><br><span class="line">typedef int WeightType; // 边的权值设为整型</span><br><span class="line">typedef char DataType; // 顶点存储的数据类型设为字符型</span><br><span class="line"></span><br><span class="line">// 边的定义</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode &#123;</span><br><span class="line">    int Nv; // 顶点数</span><br><span class="line">    int Ne; // 边数</span><br><span class="line">    AdjList G; // 邻接表</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode LGraph;</span><br><span class="line">// 以邻接表方式存储图的类型</span><br><span class="line"></span><br><span class="line">// 邻接点的定义</span><br><span class="line">typedef struct AdjVNode *PtrToAdjVNode;</span><br><span class="line">struct AdjNode&#123;</span><br><span class="line">    Vertex AdjV; // 邻接点下标</span><br><span class="line">    WeightType Weight; // 边权重</span><br><span class="line">    PtrToAdjVNode Next; // 指向下一个邻接点的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 顶点表头结点的定义</span><br><span class="line">typedef struct Vnode&#123;</span><br><span class="line">    PtrToAdjVNode FirstEdge; // 边表有指针</span><br><span class="line">    DataType Data; // 存顶点的数据</span><br><span class="line">    // 注意：很多情况下，顶点无数据，此时Data可以不用出现</span><br><span class="line">&#125; AdjList[MaxVertexNum]; // AdjList是邻接表类型</span><br><span class="line"></span><br><span class="line">// 图结点的定义</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode &#123;</span><br><span class="line">    int Nv; // 顶点数</span><br><span class="line">    int Ne; // 边数</span><br><span class="line">    AdjList G; // 邻接表</span><br><span class="line">&#125;</span><br><span class="line">typedef PtrToGNode LGraph; // 以邻接表方式存储的图类型</span><br><span class="line"></span><br><span class="line">// LGraph初始化 初始化一个有VertexNum个顶点但没有变的图</span><br><span class="line">typedef int Vertex; // 用顶点下标表示顶点，为整型</span><br><span class="line">LGraph CreateGraph(int VertexNum)&#123;</span><br><span class="line">    // 初始化一个有VertexNum个顶点但没有边的图</span><br><span class="line">    Vertex V;</span><br><span class="line">    LGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = (LGraph)malloc(sizeof(struct GNode)); // 建立图</span><br><span class="line">    Graph-&gt;Nv = VertexnNum;</span><br><span class="line">    Graph-&gt;Ne = 0;</span><br><span class="line">    // 初始化邻接表头指针</span><br><span class="line">    // 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1)</span><br><span class="line">        for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">            Graph-&gt;G[V].FristEdge = NULL;</span><br><span class="line"></span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//向LGraph中插入边， 顶点插入链表中，插入头部</span><br><span class="line">void InsertEdge(LGraph Graph, Edge E)&#123;</span><br><span class="line">    PtrToAdjVNode NewNode;</span><br><span class="line"></span><br><span class="line">    // 插入边&lt;V1, V2&gt;</span><br><span class="line">    // 为V2建立新的邻接点</span><br><span class="line">    NewNode = (PtrToAdjNode)malloc(sizeof(struct AdjVNode));</span><br><span class="line">    NewNode -&gt; AdjV = E-&gt;V2;</span><br><span class="line">    NewNode -&gt; Weight = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">    // 将V2插入V1的表头</span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FristEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class="line"></span><br><span class="line">    // 若是无向图，还要插入边&lt;V2, V1&gt;</span><br><span class="line">    // 为V1建立新的邻接点</span><br><span class="line">    NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));</span><br><span class="line">    NewNode -&gt; AdjV = E-&gt; V1;</span><br><span class="line">    NewNode -&gt; Weight = E-&gt; Weight;</span><br><span class="line">    // 将V1插入V2的表的头</span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FristEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V2].FristEdge = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 完整地建立一个LGraph</span><br><span class="line">LGraph BuildGraph()&#123;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    int Nv, i;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv); // 读入顶点个数</span><br><span class="line">    Graph = CreateGraph(Nv); // 初始化有Nv个顶点但没有边的图</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne)); // 读入边数</span><br><span class="line">    if(Graph-&gt;Ne != 0)&#123; // 如果有边</span><br><span class="line">        E = (Edge)malloc(sizeof(struct ENode)); // 建立边结点</span><br><span class="line">        // 读入边，格式为“起点，终点， 权重”，插入邻接矩阵</span><br><span class="line">        for(i=0; i&lt;Graph-&gt;Ne; i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V2, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">            // 注意：如果权重不是整型，Weight的读入格式要改</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果顶点有数据的话，读入数据</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        scanf(&quot;%c&quot;, &amp;(Graph-&gt;G[V].Data));</span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><blockquote>
<p>  把图中的每个顶点访问一遍，不可重复访问。<br>    那为什么要做图遍历呢？可以解决很多问题</p>
</blockquote>
<pre><code>为什么需要两种遍历？
图不连通怎么办？

连通：如果从v到w存在一条(无向)路径，则称v和w是连通的
路径：v到w的路径是一系列顶点{V, v1, v2,……, vn, W}的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数(如果带权，则是所有边的权重和)。如果v到w之间的所有顶点都不同，则称简单路径。
回路：起点等于终点的路径， 图中有回路，则不是简单路径
连通图：图中任意两顶点均连通


图不连通怎么办？
无向图：
    连通分量：无向图的极大连通子图
    极大顶点数：再加1个顶点就不连通了
    极大边数：包含子图中所有顶点相连的所有边
有向图:
    强连通：有向图中顶点v和w之间存在双向路径，则称v和w是强连通的
    强连通图：有向图中任意两顶点均强连通
    强连通分量：有向图的极大强连通子图</code></pre><h6 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h6><blockquote>
<p>  Breadth First Search, BFS<br>    一层一层的访问结点<br>    程序实现，借用队列<br>    类似层序遍历<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void BFS(Vertex V)&#123;</span><br><span class="line">    visited[V] = true;</span><br><span class="line">    Enqueue(V, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        for(V的每个邻接点W)</span><br><span class="line">            visited[W] = true;</span><br><span class="line">            Enqueue(W, Q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>若有N个顶点、E条边，时间复杂度是
* 用邻接表存储图，有O(N+E)
* 用邻接矩阵存储图，有O(N^2)</code></pre><h6 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h6><blockquote>
<p>  Depth First Search, DFS<br>    类似于树的<strong>先序遍历</strong><br>    访问完结点一定要原路返回，原路返回，对应堆栈出栈<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Vertex V)&#123;</span><br><span class="line">    visited[V] = true;</span><br><span class="line">    for(V的每个邻接点W)</span><br><span class="line">        if(!visited[W])</span><br><span class="line">            DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>若有N个顶点，E条边，时间复杂度是
* 用邻接表存储图，有O(N+E)
* 用邻接矩阵存储图，有O(N^2)</code></pre><h5 id="最小生成树-Minimum-Spanning-Tree"><a href="#最小生成树-Minimum-Spanning-Tree" class="headerlink" title="最小生成树 (Minimum Spanning Tree)"></a>最小生成树 (Minimum Spanning Tree)</h5><blockquote>
<p>最小生成树存在 &lt;==&gt; 图连通, 最少边，花费最少<br>    - 是一颗树<br>      无回路<br>      |V|个顶点一定有|V|-1条边<br>    - 是生成树<br>      包含全部顶点<br>      |V|-1条边都在图里<br>    - 边的权重和最小</p>
</blockquote>
<pre><code>(向生成树中任加一条边都一定构成回路)</code></pre><h6 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h6><blockquote>
<p>有两种 Prim算法 和 Kruskal算法</p>
<ul>
<li>什么是“贪”：每一步都要最好的</li>
<li>什么是“好”：权重最小的边</li>
<li>需要约束：<pre><code>- 只能用图里有的边
- 只能正好用掉|V|-1条边
- 不能有回路</code></pre></li>
</ul>
</blockquote>
<p>####### Prim算法</p>
<blockquote>
<p>让一颗小树长大 – 有点像Dijkstra算法<br><img src="/images/Prim%E7%AE%97%E6%B3%95.png" alt="Prim算法"><br>    Prim Dijkstra算法对比：<br><img src="/images/Prim_Dijkstra.png" alt="Prim_Dijkstra算法对比"></p>
</blockquote>
<pre><code>Prim算法里的dist， 当前顶点与最小生成树中收录所有顶点的最短距离，V，将V收录进最小生成树MST，此时结点到最小生成树的距离dist[V] = 0;
最小生成树里的树怎么存呢？ 对每个顶点存 parent[S] = -1 (父结点的编号)，此处为根结点
dist[V] = E&lt;S, V&gt; 或 正无穷
T = O(|V|^2)---稠密图合算</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/* 邻接矩阵存储 - Prim最小生成树算法*/</span><br><span class="line">Vertex FindMinDist(MGraph Graph, WeightType dist[])</span><br><span class="line">&#123;</span><br><span class="line">    // 返回未被收录顶点中dist最小者</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    WeightType MinDist = INFINITY; // 无穷大</span><br><span class="line"></span><br><span class="line">    for(V=0; V&lt;Graph-&gt; Nv; V++)&#123;</span><br><span class="line">        if(dist[V] != 0 &amp;&amp; dist[V] &lt; MinDist)&#123;</span><br><span class="line">            // 若V未被收录，且dist[V]更小</span><br><span class="line">            MinDist = dist[V]; // 更新最小距离</span><br><span class="line">            MinV = V; // 更新对应顶点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(MinDist &lt; INFINITY) // 若找到最小dist</span><br><span class="line">        return MinV; // 返回对应的顶点下标</span><br><span class="line">    else retuen ERROR; // 若这样的顶点不存在，返回-1作为标记</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Prim(MGraph Graph, LGraph MST)</span><br><span class="line">&#123;</span><br><span class="line">    // 将最小生成树保存为邻接表存储的图MST， 返回最小权重和</span><br><span class="line">    WeightType dist[MaxVertexNum], TotalWeight;</span><br><span class="line">    Vertex parent[MaxVertexNum], V, W;</span><br><span class="line">    int VCount;</span><br><span class="line">    Edge E;</span><br><span class="line"></span><br><span class="line">    // 初始化，默认初始点下标为0</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)&#123;</span><br><span class="line">        // 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY</span><br><span class="line">        dist[V] = Graph -&gt; G[0][V];</span><br><span class="line">        parent[V] = 0; // 暂且定义所有顶点的父结点都是初始点0</span><br><span class="line">    &#125;</span><br><span class="line">    TotalWeight = 0; // 初始化权重和</span><br><span class="line">    VCount = 0; // 初始化收录的顶点数</span><br><span class="line">    // 创建包含所有顶点但没有边的图，注意用邻接表版本</span><br><span class="line">    MST = CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    E = (Edge)malloc(sizeof(struct ENode)); // 建立空的边结点</span><br><span class="line"></span><br><span class="line">    // 将初始点0收录进MST</span><br><span class="line">    dist[0] = 0;</span><br><span class="line">    VCount ++;</span><br><span class="line">    parent[0] = -1; // 当前树根是0</span><br><span class="line"></span><br><span class="line">    while(1)&#123;</span><br><span class="line">        V = FindMinDist(Graph, dist);</span><br><span class="line">        // V = 未被收录点中dist最小者</span><br><span class="line">        if(V == ERROR) // 若这样的V不存在</span><br><span class="line">            break; // 算法结束</span><br><span class="line">        // 将V及相应的边&lt;parent[V], V&gt;收录进MST</span><br><span class="line">        E-&gt; V1 = parent[V];</span><br><span class="line">        E-&gt; V2 = V;</span><br><span class="line">        E-&gt; Weight = dist[V];</span><br><span class="line">        InsertEdge(MST. E);</span><br><span class="line">        TotalWeigt += dist[V];</span><br><span class="line">        dist[V] = 0;</span><br><span class="line">        VCount++;</span><br><span class="line"></span><br><span class="line">        for(w=0; w&lt;Graph-&gt;Nv; w++) // 对图中的每个顶点w</span><br><span class="line">            if(dist[w]！=0 &amp;&amp; Graph-&gt; G[V][W]&lt;INFINITY) &#123;</span><br><span class="line">                // 若w是v的邻接点并且未被收录</span><br><span class="line">                    if(Graph-&gt;G[V][W] &lt; dist[W])&#123;</span><br><span class="line">                        // 若收录V使得dist[W]变小</span><br><span class="line">                        dist[W] = Graph-&gt;G[V][W]; // 更新dist[W]</span><br><span class="line">                        parent[W] = V; // 更新树</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; // while结束</span><br><span class="line">    if(VCount &lt; Graph-&gt;Nv) // MST中收的顶点不到|V|个</span><br><span class="line">        TotalWeight = ERROR;</span><br><span class="line">    return TotalWeight; // 算法执行完毕，但会最小权重和或错误标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####### Kruskal算法 </p>
<blockquote>
<p>将森林合并成树–稀疏图合算， 很多结点，边的条数比较少<br>    默认每个结点都是一棵树，然后通过不断的收录最小权重的边，合并树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 伪码</span><br><span class="line">void Kruskal (Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    MST = &#123;&#125;; // 这里收录的是边，不是顶点， 一开始是空集</span><br><span class="line">    while ( MST中不到|V| - 1条边 &amp;&amp; E中还有边)&#123;</span><br><span class="line">        从E中取一条权重最小的边E&lt;V, W&gt;; // 从边集中取，怎么取？ **最小堆**</span><br><span class="line">        将E&lt;V, W&gt;从E中删除;</span><br><span class="line">        if (E&lt;v, w&gt;不在MST中构成回路) // 怎么知道有没有构成回路？ **并查集**， 边的两个顶点在不同的集合</span><br><span class="line">            将E&lt;v, w&gt;加入MST</span><br><span class="line">        else</span><br><span class="line">            彻底无视 E&lt;v, w&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    // MST中还没收满 循环已经跳出来了，E中没有边了</span><br><span class="line">    if (MST 中不到|V| - 1 条边)</span><br><span class="line">        Error(&quot;生成树不存在&quot;); // 原图不连通</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>T = O(|E|log|E|)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">/* 邻接表存储 - Kruskal最小生成树算法*/</span><br><span class="line">/* ------------------------顶点并查集-------------------*/</span><br><span class="line">typedef Vertex ElementType; // 默认元素可以用非负整数表示</span><br><span class="line">typedef Vertex SetName; // 默认用根结点的下标作为集合名称</span><br><span class="line">typedef ElementType SetType[MaxVertexNum]; // 假设集合元素下标从0开始</span><br><span class="line"></span><br><span class="line">void InitializeVSet(SetType S, int N)&#123;</span><br><span class="line">    // 初始化并查集</span><br><span class="line">    ElementType X;</span><br><span class="line">    for(X=0; X&lt;N; X++) S[X] = -1;</span><br><span class="line">&#125;</span><br><span class="line">void Union(SetType S, SetName Root1, SetName Root2)</span><br><span class="line">&#123;</span><br><span class="line">    // 这里默认Root1和Root2是不同集合的根结点</span><br><span class="line">    // 保证小集合并入大集合</span><br><span class="line">    if(S[Root2] &lt; S[Root1]) &#123; // 如果集合2比较大</span><br><span class="line">        S[Root2] += S[Root1]; // 集合1并入集合2</span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        S[Root1] += S[Root2];</span><br><span class="line">        S[Roots1] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SetName Find(SetType S, ElementType X)</span><br><span class="line">&#123;</span><br><span class="line">    // 默认集合元素全部初始化为-1</span><br><span class="line">    if( S[X] &lt; 0) // 找到集合的根</span><br><span class="line">        return X;</span><br><span class="line">    else </span><br><span class="line">        return S[X] = Find( S, S[X]); // 路径压缩</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CheckCycle(SetType VSet, Vertex V1, Vertex V2)</span><br><span class="line">&#123;</span><br><span class="line">    // 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路</span><br><span class="line">    Vertex Root1, Root2;</span><br><span class="line"></span><br><span class="line">    Root1 = Find(VSet, V1); // 得到V1所属的连通集名称</span><br><span class="line">    Root2 = Find(VSet, V2); // 得到V2所属的连通集名称</span><br><span class="line"></span><br><span class="line">    if(Root1 == Root2) // 若V1和V2已经连通，则该边不能要</span><br><span class="line">        return false;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 否则该边可以被收集，同时将V1和V2并入同一连通集</span><br><span class="line">        Union(VSet, Root1, Root2);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*-----------------------并查集定义结束--------------------------------*/</span><br><span class="line">/*-----------------------边的最小堆定义--------------------------------*/</span><br><span class="line">void PercDown(Edge ESet, int p, int N)</span><br><span class="line">&#123;</span><br><span class="line">    // 将N个元素的边数组中国已ESet[p]为根的子堆调整为关于Weight的最小堆</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    struct ENode X;</span><br><span class="line"></span><br><span class="line">    X = ESet[p]; // 取出根结点存放的值</span><br><span class="line">    for(Parent=p; (Parent*2 + 1) &lt; N; Parent=Child)&#123;</span><br><span class="line">        Child = Parent*2 + 1;</span><br><span class="line">        if((Child!=N-1) &amp;&amp; (ESet[Child].Weight &gt; ESet[Child+1].Weight))</span><br><span class="line">            Child++; // Child指向左右子结点的较小者</span><br><span class="line">        if(X.Weight &lt;= ESet[Child].Weight) break; // 找到了合适位置</span><br><span class="line">        else // 下滤X</span><br><span class="line">            ESet[Parent] = ESet[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    ESet[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitializeESet(LGraph Graph, Edge ESet)&#123;</span><br><span class="line">    // 将图的边存入数组Set， 并且初始化为最小堆</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    int ECount;</span><br><span class="line"></span><br><span class="line">    // 将图的边存入数组ESet</span><br><span class="line">    ECount = 0;</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        for(W=Graph-&gt;G[V].FristEdge; W; W=W-&gt;Next)</span><br><span class="line">            if(V&lt;W-&gt;AdjV) &#123; // 避免重复录入无向图的边，之手V1&lt;V2的边</span><br><span class="line">                ESet[ECount].V1 = V;</span><br><span class="line">                ESet[ECount].V2 = W-&gt;AdjV;</span><br><span class="line">                ESet[Ecount++].Weight = W-&gt;Weight;</span><br><span class="line">            &#125;</span><br><span class="line">    // 初始化为最小堆</span><br><span class="line">    for(ECount=Graph-&gt;Ne/2; ECount&gt;=0; ECount--)</span><br><span class="line">        PercDown(ESet, ECount, Graph-&gt;Ne);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetEdge(Edge ESet, int CurrentSize)</span><br><span class="line">&#123;</span><br><span class="line">    // 给定当前堆的大小CurrentSize， 将当前最小边位置弹出并调整堆</span><br><span class="line"></span><br><span class="line">    // 将最小边与当前堆的最后一个位置的边交换</span><br><span class="line">    Swap(&amp;ESet[0], &amp;ESet[CurrentSize - 1]);</span><br><span class="line">    // 将剩下的边继续调整成最小堆</span><br><span class="line">    PercDown(ESet, 0, CurrentSize - 1);</span><br><span class="line"></span><br><span class="line">    return CurrentSize - 1; // 返回最小边所在位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /*-----------------------最小堆定义结束--------------------------------*/</span><br><span class="line"></span><br><span class="line"> int Kruskal(LGraph Graph, LGraph MST)</span><br><span class="line"> &#123;// 将最小生成树保存为邻接表存储的图MST， 返回最小权重和</span><br><span class="line">    WeightType TotalWeight;</span><br><span class="line">    int ECount, NextEdge;</span><br><span class="line">    SetType VSet; // 顶点数组</span><br><span class="line">    Edge ESet; // 边数组</span><br><span class="line"></span><br><span class="line">    InitializeVSet(VSet, Graph-&gt;Nv); // 初始化顶点并查集</span><br><span class="line">    ESet = (Edge)malloc(sizeof(struct ENode)*Graph-&gt;Ne);</span><br><span class="line">    InitializeESet(Graph, ESet); // 初始化边的最小堆</span><br><span class="line">    // 创建包含所有顶点但没有边的图，用邻接表</span><br><span class="line">    MST = CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    TotalWeight = 0; // 初始化权重和</span><br><span class="line">    ECount = 0; // 初始化收录的边数</span><br><span class="line"></span><br><span class="line">    NextEdge = Graph-&gt;Ne; //原生边集的规模</span><br><span class="line">    while(ECount &lt; Graph-&gt;Nv - 1)&#123;</span><br><span class="line">        // 当收集的边不足以构成树时</span><br><span class="line">        NextEdge = GetEdge(ESet, NextEdge); // 从边集中得到最小边的位置</span><br><span class="line">        if(NextEdge &lt; 0) // 边集已空</span><br><span class="line">            break;</span><br><span class="line">        // 如果该边的加入不构成回路，即两端结点不属于同一连通集</span><br><span class="line">        if(CheckCycle(VSet, ESet[NextEdge].V1, ESet[NextEdge].V2) ==  true)&#123;</span><br><span class="line">            // 将该边插入MST</span><br><span class="line">            InsertEdge(MST, ESet+NextEdge);</span><br><span class="line">            TotalWeight += ESet[NextEdge].Weight; // 累计权重</span><br><span class="line">            Ecount++; // 生成树中边数加1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ECount &lt; Graph-&gt;Nv - 1)</span><br><span class="line">        TotalWeight = -1; // 设置错误标记，表示生成树不存在</span><br><span class="line">    return TotalWeight;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h5><blockquote>
<p>在网络中，求两个不同顶点之间的所有路径中权值之和最小的那条路径<br>    - 这条路径就是两点之间的最短路径(Shortest Path)<br>    - 第一个顶点为源点(Source)<br>    - 最后一个顶点为终点(Destination)</p>
</blockquote>
<pre><code>问题分类：
单源最短路径问题： 从某固定源点出发，求其到所有其他顶点的最短路径
    - (有向)无权图
    - (有向)有权图

多源最短路径问题：求任意两顶点间的最短路径</code></pre><h6 id="BFS-广度优先遍历算法"><a href="#BFS-广度优先遍历算法" class="headerlink" title="BFS 广度优先遍历算法"></a>BFS 广度优先遍历算法</h6><blockquote>
<p>  [无权图的单源最短路径算法]<br>    详细的看视频讲解理解算法：(<a href="http://jdvodrvfb210d.vod.126.net/mooc-video/nos/mp4/2016/08/22/1004848002_652eec25c98b4cfe833863aa38a720e7_hd.mp4?ak=99ed7479ee303d1b1361b0ee5a4abcee0b5d8d309c21117103b4f89c70f969d3ea1f14bab52959e1c73ef3ae2f753c140d5fd180c9d920a388c7f0113a203cf6dc73ca898c2e909ad081fb3bc930be9adae3070f62128a029f5d4c798f8df62e8d527559dfc298f46da8ad5f53c2548f0797ab0443b0ce0c1b07fa8415bc5e265f33a26f5b1c3ca6c5fb7b88ad4b8b179b7ad6f2c848f1a32a51c2df2fed3c1e9e78811ec85e3d19ea763a2749a2e3af" target="_blank" rel="noopener">http://jdvodrvfb210d.vod.126.net/mooc-video/nos/mp4/2016/08/22/1004848002_652eec25c98b4cfe833863aa38a720e7_hd.mp4?ak=99ed7479ee303d1b1361b0ee5a4abcee0b5d8d309c21117103b4f89c70f969d3ea1f14bab52959e1c73ef3ae2f753c140d5fd180c9d920a388c7f0113a203cf6dc73ca898c2e909ad081fb3bc930be9adae3070f62128a029f5d4c798f8df62e8d527559dfc298f46da8ad5f53c2548f0797ab0443b0ce0c1b07fa8415bc5e265f33a26f5b1c3ca6c5fb7b88ad4b8b179b7ad6f2c848f1a32a51c2df2fed3c1e9e78811ec85e3d19ea763a2749a2e3af</a>)</p>
</blockquote>
<pre><code>按照递增(非递减)的顺序找出各个顶点的最短路
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void BFS(Vertex S)&#123;</span><br><span class="line">    visited[S] = true;//不需要</span><br><span class="line">    Enqueue(S, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        for(V的每个邻接点W)</span><br><span class="line">            if(!visited[W]) &#123;// 不需要</span><br><span class="line">                visited[W] = true; // 不需要</span><br><span class="line">                Enqueue(W, Q)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

dist[W] = S到W的最短距离
dist[S] = 0
path[W] = S到W的路上经过的某顶点

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Unweighted(Vertex S)&#123;</span><br><span class="line">    Enqueue(S, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        for(V的每个邻接点W)</span><br><span class="line">            if(dist[W] == -1)&#123;</span><br><span class="line">                dist[W] = dist[V] + 1;</span><br><span class="line">                path[W] = V;</span><br><span class="line">                Enqueue(W, Q)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><img src="/images/%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.png" alt="无权图的单源最短路径算法"></p>
<pre><code>准备工作


初始化dist path两个数组， -1， 队列Q空
取V3作为源点 dist第三个元素初始化为0
源点入队Q，然后进入while循环，检查队列是否为空
队列中有V3
不为空，V3出列，
对V3的两个邻接点V1 V6 进行遍历
是否为-1（判断是不是没有被访问过），是的，dist距离+1，然后将v3记录在路径上
然后将V1压进队列中，
然后遍历V6 ，没有访问过，v3距离+1 ，然后将v3记录在路径上，
将V6压入队列中
while一次循环结束
队列中有V1 V6 接着进行循环
然后V1出队列，遍历V1的两个邻接点V2 V4，
dist[2] = 2
path[2] = 1
V2 入队， 队列元素为V6 V2
然后遍历另外一个临界点V4
dist[4] = 2
path[4] = 1
V4，入队，先队列元素为V6 V2 V4
又进入下一次while循环，队列不为空
V6出队，V6没有邻接点，直接跳出for循环，进入下一次while循环
V2出队，V2邻接点V4 V5， 进入for循环 V4不等于-1 已经访问过了无视，然后遍历V5，没有访问过
dist[5] = 3
path[5] = 2
V5入队，然后进入下一次while循环检查队列，县队列 V4 V5
V4出队，遍历V4邻接点V4 V5 V6 V7，（V4， V5， V6已被访问过直接跳过）
dist[7] = 3
path[7] = 4
完成后V7入队，现队列 V5 V7
再进入whilw循环
V5 出队， 一个临界点V7 已被访问过，什么都不做，进入下一次while循环，现队列中V7
在进入while循环
V7出队，V7邻接点V6，已被访问过，什么都不做，在回到while循环，此时队列为空，循环结束

dist[2] = 2: V2的最短路径为2
path[2] = 1： 且这条最短路径是为V1到达V2的

下标   1   2   3   4   5    6   7
dist   1   2   0   2   3    1   3
path   3   1  -1   1   2    3   4


查找最短路径，依次顺着path路径入栈，再出栈,然后就找到最短路径

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 邻接表存储 - 无权图的单源最短路径算法</span><br><span class="line">// dist[] path[] 全部初始化为1</span><br><span class="line">    void Unweighted(LGraph Graph, int dist[], int path[], Vertex S)&#123;</span><br><span class="line">        Queue Q;</span><br><span class="line">        Vertex V;</span><br><span class="line">        PtrToAdjVNode W;</span><br><span class="line"></span><br><span class="line">        Q = CreateQueue(Graph-&gt; Nv); //创建空队列，MaxSize为外部定义的常数</span><br><span class="line">        dist[S] = 0; // 初始化源点</span><br><span class="line">        AddQ(Q, S);</span><br><span class="line"></span><br><span class="line">        while(!IsEmpty(Q))&#123;</span><br><span class="line">            V = DeleteQ(Q);</span><br><span class="line">            for(W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next) // 对V的每个邻接点W-&gt;AdjV</span><br><span class="line">                if(dist[W-&gt;AdjV == -1]) // 若w-&gt;AdjV未被访问过</span><br><span class="line">                    dist[W-&gt;AdjV] = dist[V] + 1; // W-&gt;AdjV到S的距离更新</span><br><span class="line">                    path[W-&gt;AdjV] = V; // 将V记录在S到w-&gt;AdjV的路径上</span><br><span class="line">                    Add(Q, W-&gt;AdjV);</span><br><span class="line">        &#125; // whilw结束</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><h6 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h6><blockquote>
<p>  有权图的单源最短路径算法<br>    有权图最短路和无权图最短路，最大的区别是有权图最短路径不一定是经过顶点数最少的路径</p>
</blockquote>
<pre><code>- 按照递增的顺序找出各个顶点的最短路 
- Dijkstra算法
    - 令S = {源点S + 已经确定了最短路径的顶点vi}
    - 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过S中的顶点。即路径{s-&gt;(vi ∈ S)-&gt;v}的最小长度
    - 若路径是按照递增(非递减)的顺序生成的，则
        - 真正的最短路必须只经过S中的顶点
        - 每次从未收录的顶点中选一个dist最小的收录(贪心算法思想)
        - 增加一个v进入S，可能影响另一个w的dist值
            dist[w] = min{dist[w], dist[v]+&lt;v, w&gt;d的权重}</code></pre><p><img src="/images/%E6%9C%89%E6%9D%83%E5%9B%BE%E5%8D%95%E6%BA%90%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.png" alt="有权图单源路径算法"><br>    V1源点 V6终点，从V1到V6的最短路径是哪条？<br>    不考虑，负值圈negative-costcycle</p>
<pre><code>首先初始化dist path两个数组
下标   1    2    3    4    5    6    7
dist   ∞    ∞   ∞     ∞    ∞    ∞   ∞
path   -1   -1  -1    -1   -1   -1   -1
选择V1作为源点，源点到自己的距离dist[1] = 0 相邻结点V2 V4的距离就被更新为权重，路径桑的顶点更新为1
下标   1    2    3    4    5    6    7
dist   0    2    ∞    1    ∞    ∞   ∞
path   -1   1    -1   1   -1   -1   -1

初始化完毕进入Dijkstra函数处理
找到未收录顶点dist最小数，V = V4 = 1， 标志为被访问过
遍历V4的每个邻接点W， V3 V5 V6 V7
V3遍历，判断没有被访问过，dist[v] = dist[V4] = 1 + E&lt;v,w&gt;=E&lt;v4, v3&gt;的权重=2 显然是小于dist[w] = dist[v3]=∞
所以dist[w] = dist[v3]更新为 dist[V] + E&lt;v,w&gt; = 1 + 2 = 3;
path[V3] = V4
下标   1    2    3    4    5    6    7
dist   0    2    3     1    ∞    ∞   ∞
path   -1   1    4     1   -1   -1   -1

至此完成V4一个邻接点的处理，进入下一个邻接点V5 进行处理
V5遍历，没有被访问过，同V3，dist[V]+E&lt;v, w&gt; &lt; dist[W] =&gt; dist[V4] + E&lt;V4, V5&gt; = 1 + 2 &lt; ∞
dist[V5] = 3
path[V5] = v4
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    ∞   ∞
path   -1   1    4     1   4   -1   -1
处理 V6 没有被访问过，同V3，dist[V]+E&lt;v, w&gt; &lt; dist[W] =&gt; dist[V4] + E&lt;V4, V6&gt; = 1 + 8 &lt; ∞
dist[V6] = 9
path[V6] = v4
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    9   ∞
path   -1   1    4     1   4    4   -1
处理 V7 没有被访问过，同V3，dist[V]+E&lt;v, w&gt; &lt; dist[W] =&gt; dist[V4] + E&lt;V4, V7&gt; = 1 + 4 &lt; ∞
dist[V7] = 5
path[V7] = v4
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    9    5
path   -1   1    4     1   4    4    4
至此处理完V4
接着进入下一轮循环，在没被收录顶点dist中找最小的 显然是顶点V2 = 2
然后对顶点V2的邻接点w， V4， V5进行遍历
V4已被访问过， 跳过
遍历V5，现在的dist[V] = dist[V2] = 2 ;E&lt;V2, V5&gt; = 10  
dist[V] + E&lt;V2, V5&gt; &gt; dist[w] = dist[V5] = 3
保持V5原路径不变
接着进入下一轮循环，找到未收录顶点dist最小数，V = V3/V5 = 3，选择V3 标志为被访问过
然后对V3的邻接点遍历访问 V1 V6
V1已被访问过跳过
V6，dist[V] = dist[V3] = 3 ;E&lt;V3, V6&gt; = 5  
dist[3] + E&lt;V3, V6&gt; = 8  &lt; dist[w] = dist[V6] = 9, 更新路径
dist[V6] = 8
path[V6] = v3
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    8    5
path   -1   1    4     1   4    3    4
对V3处理完毕后，接着找未收录顶点dist最小数 V5 =3，标志被访问过，
对V5的邻接点遍历处理 ，只有一个邻接点V7， V7现在的最短距离是5 从V4过来的
遍历V7，现在的dist[V] = dist[V5] = 3 ;E&lt;V5, V7&gt; = 6  
dist[V] + E&lt;V5, V7&gt;=9 &gt; dist[w] = dist[V7] = 5
保持V7原路径不变
对V5处理完毕后，接着找未收录顶点dist最小数 V7 = 5，标志被访问过，
V7唯一的邻接点V6， V6现在最短距离是8
dist[V7] = 5, V&lt;V7, V6&gt; = 1 
(dist[V7] = 5 )+ (V&lt;V7, V6&gt; = 1 ) = 6 &lt; dist[W]=dist[V6] = 8更新路径
dist[V6] = 6
path[V6] = V7
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    6    5
path   -1   1    4     1   4    7    4
继续找下一个未被收录顶点dist最小数 V6 访问V6
V6无邻接点，V6循环结束
在接着找未被收录顶点dist最小数，这样的顶点已经不存在了，至此跳出while循环，结束算法

算法完成后，V1到V6的最短路径是哪一条呢？
从path[V6]开始找到V7，然后path[V7]找到path[V4]，然后在path[V4]找到path[V1],然后找path[V1] = -1 &lt; 0.所以V1是源点
得到路径 V1-&gt;V4-&gt;V7-&gt;V6

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        V = 未收录顶点中dist最小者</span><br><span class="line">        if(这样的v不存在)</span><br><span class="line">            break; // 跳出循环</span><br><span class="line"></span><br><span class="line">        collected[V] = true;</span><br><span class="line">        for( V的每个邻接点W)</span><br><span class="line">            if(collected[W] == false) // 还没有被收录</span><br><span class="line">                if(dist[V]+E&lt;v, w&gt; &lt; dist[W])&#123;</span><br><span class="line">                    dist[W] = dist[V] + E&lt;v, w&gt;</span><br><span class="line">                    path[W] = V</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 不能解决有负边的情况</span><br></pre></td></tr></table></figure>

// 时间复杂度：这个程序的算法复杂度很大程度上取决于怎么做V = 未收录顶点中dist最小者
- 方法1：直接扫描所有未收录顶点-O(|V|)
    T = O(|V|^2 + |E|) 对稠密图效果好
- 方法2: 将dist存在最小堆中- O(log|V|)
    更新dist[w]的值 - O(log|V|)
    T = O(|V|log|V| + |E|log|V|) = O(|E|log|V|) 对于稀疏图效果好

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 邻接矩阵存储 - 有权图的单源最短路径算法</span><br><span class="line">Vertex FindMinDist(MGraph Graph, int dist[], int collected[])&#123;</span><br><span class="line">    // 返回未被收录顶点中dist最少这</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    int MinDist = INFINITY;</span><br><span class="line"></span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv;V++)&#123;</span><br><span class="line">        if(collected[V] == false &amp;&amp; dist[V]&lt;MinDist)&#123;</span><br><span class="line">            // 若V未被收录，且dist[V]更小</span><br><span class="line">            MinDist = dist[V]; //更新最小距离</span><br><span class="line">            MinV = V; // 更新对应顶点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(MinDist &lt; INFINITY) // 若找到最小dist</span><br><span class="line">        return MinV; // 返回对应的顶点下标</span><br><span class="line">    else return ERROR; // 若这样的顶点不存在，返回错误标记</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool Dijkstra(MGraph Graph, int dist[], int path[], Vertex S)&#123;</span><br><span class="line">    int collected[MaxVertexNum];</span><br><span class="line">    Vertex V, W;</span><br><span class="line"></span><br><span class="line">    // 初始化：此处默认邻接矩阵中不存在的边用INFINITY表示</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)&#123;</span><br><span class="line">        dist[V] = Graph-&gt;G[S][V];</span><br><span class="line">        if(dist[V]&lt;INFINITY)</span><br><span class="line">            path[V] = S;</span><br><span class="line">        else</span><br><span class="line">            path[V] = -1;</span><br><span class="line">        collected[S] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 先将起点收入集合</span><br><span class="line">    dist[S] = 0;</span><br><span class="line">    collected[S] = true;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        // V = 未被收录顶点中dist最小者</span><br><span class="line">        V = FindMinDist(Graph, dist, collected);</span><br><span class="line">        if(V== ERROR) // 若这样的V不存在</span><br><span class="line">            break; // 算法结束</span><br><span class="line">        </span><br><span class="line">        collected[V] = true; // 收录V</span><br><span class="line">        for(W=0; W&lt;Graph-&gt;Nv; W++)&#123; // 对图中的每个顶点W</span><br><span class="line">            // 若W是V的邻接点并且未被收录</span><br><span class="line">            if(collected[W]=false &amp;&amp; Graph-&gt;G[V][W] &lt; INFINITY) &#123;</span><br><span class="line">                if(Graph -&gt; G[V][W] &lt; 0) //  若有负边</span><br><span class="line">                    return false; // 不能正确解决，返回错误标记</span><br><span class="line">                // 若收录V使得dist[W]变小</span><br><span class="line">                if(dist[V] + Graph-&gt;[V][W] &lt; dist[W])&#123;</span><br><span class="line">                    dist[W] = dist[V] + Graph -&gt; G[V][W]; // 更新dist[W]</span><br><span class="line">                    path[W] = V; // 更新S到W的路径</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // while结束</span><br><span class="line">    return true; // 算法执行完毕，返回正确标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h6 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h6><blockquote>
<p>  多源最短路径算法<br>    方法1：直接将单源最短路算法调用|V|遍，  T = O(|V|^3 + |E|*|V|) 对于稀疏图效果好<br>    方法2：Floyd算法 T= O(|V|^3)  对于稠密图效果好</p>
</blockquote>
<pre><code>Floyd算法
    - 用邻接矩阵，二维数组，来记录 D^k[i][j] = 路径{i-&gt; {l&lt;= k}-&gt; j} 的最小长度
    - D^0, D^1,……,D^|V|-1[i][j]即给出了i到j的真正最短距离
    - 最初的D^-1是什么？ 初始的矩阵应该怎么定义？ 自己定义为邻接矩阵，对角元全部为0，i，j有边初始化为权重， i，j之间没有边，定义为∞
    - 如何完成递推？当D^k-1已经完成，递推到D^k时：
        或者k∉最短路径{i-&gt; {l&lt;= k}-&gt;j}, 即收录不会影响最短路径，D^k = D^k-1
        或者新加进去的k， k∈最短路径{i-&gt; {l&lt;= k}-&gt;j}，k一定在最短路径上, 则该路径必定由两段最短路劲组成：D^k[i][j] = D^k-1[i][k] + D^k-1[k][j]
其实这个讲解完了依旧还是晕，没听懂，没搞明白，但是代码还是要写一下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vois Floyd() &#123;</span><br><span class="line">    for( i=0; i&lt;N; i++)</span><br><span class="line">        for(j=0; j&lt;N; j++)&#123;</span><br><span class="line">            D[i][j] = G[i][j]; // 初始化为邻接矩阵</span><br><span class="line">            path[i][j] = -1; // 用另外一个数组记录路径，初始化为-1，表示i j之间没有路径</span><br><span class="line">        &#125;</span><br><span class="line">    for(k=0; k&lt;N; k++) // 上标从0开始</span><br><span class="line">        for(i=0; i&lt;N; i++)</span><br><span class="line">            for(j=0; j&lt;N; j++)</span><br><span class="line">                if(D[i][k] + D[k][j]&lt; D[i][j])&#123;</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印从i到j的最短路径， 递归打印i到k的路径， 打印k的值， 递归打印从k到j的路径</span><br></pre></td></tr></table></figure>

T = O(|V|^3)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 邻接矩阵存储 - 多源最短路径算法</span><br><span class="line">bool Floyd(MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum])&#123;</span><br><span class="line">    Vertex i, j, k; </span><br><span class="line"></span><br><span class="line">    // 初始化</span><br><span class="line">    for(i=0; i&lt;Graph-&gt;Nv; i++)</span><br><span class="line">        for(j=0; j&lt;Graph-&gt;Nv; j++)</span><br><span class="line">            D[i][j] = Graph-&gt;G[i][j];</span><br><span class="line">            path[i][j] = -1;</span><br><span class="line"></span><br><span class="line">    for(k=0; k&lt;Graph-&gt;Nv; k++)</span><br><span class="line">        for(i=0; i&lt;Graph-&gt;Nv; i++)</span><br><span class="line">            for(j=0; j&lt;Graph-&gt;Nv; j++)</span><br><span class="line">                if(D[i][k] + D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">                    if(i == j &amp;&amp; D[i][j]&lt;0) // 若发现负值圈</span><br><span class="line">                        return false; // 不能正确解决，返回错误标记</span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">    return true; // 算法执行完毕，返回正确标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><ul>
<li><p>AOV：Acitivity On Vertex 网络 例：计算机专业排课</p>
</li>
<li><p>DAG：Directed Acyclic Graph 有向无环图</p>
</li>
<li><p>拓扑序：如果图中从v到w有一条有向路径，则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序</p>
</li>
<li><p>获得一个拓扑序的过程就是拓扑排序</p>
</li>
<li><p>AOV如果有合理的拓扑序，则必定是有向无环图Directed Acyclic Graph, DAG</p>
<p>  每次输出没有前驱的结点，入度为零，没有边指向它，从图中删除该点</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void TopSort()</span><br><span class="line">&#123;</span><br><span class="line">    for(cnt=0; cnt&lt;|V|;cont++)&#123;</span><br><span class="line">        V = 未输出的入度为0的顶点;// 时间复杂度取决于这一步怎么找</span><br><span class="line">        // 如果外循环还未结束，这样的V就已经不存在了，意味着图中还剩下好几个顶点没有被输出，但是每一个顶点入度都不是0，说明图中必定是有回路的</span><br><span class="line">        if(这样的V不存在)&#123;</span><br><span class="line">            ERROR(&quot;图中有回路&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        输出v，或者记录v的输出序号</span><br><span class="line">        for(v的每个临界接点W)</span><br><span class="line">            Indegree[w]--; // 遍历每个邻接点，入度减1，即为删除该点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  随时将入度变为0的顶点放到一个容器里</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//改一下算法</span><br><span class="line">void TopSort()</span><br><span class="line">&#123;</span><br><span class="line">    for(图中每个顶点v)</span><br><span class="line">        if(Indegree[v]==0)</span><br><span class="line">            Enqueue(V, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        //输出V，或者记录V的输出序号；</span><br><span class="line">        cnt++</span><br><span class="line">        for(V的每个邻接点W)</span><br><span class="line">            if(--Indegree[W]== 0)</span><br><span class="line">                Enqueue(W, Q);</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt != |V|)</span><br><span class="line">        Error(&quot;图中有回路&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这个算法也可以用来检测有向图是否是DAG 有向无环图</p>
</li>
</ul>
<h3 id="第二部分-软件工程"><a href="#第二部分-软件工程" class="headerlink" title="第二部分 软件工程"></a>第二部分 软件工程</h3><h4 id="一、软件过程"><a href="#一、软件过程" class="headerlink" title="一、软件过程"></a>一、软件过程</h4><h5 id="软件过程的概念；"><a href="#软件过程的概念；" class="headerlink" title="软件过程的概念；"></a>软件过程的概念；</h5><blockquote>
<p>  软件工程过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。<br>    在完成开发任务时必须要进行一些开发活动，并且使用适当的资源（人员、时间、计算机硬件、软件工具等），在过程结束时将输入（如软件需求）转化为输出（如软件产品），因此ISO9000把过程定义为“把输入传化为输出的一组彼此相关的资源和活动”。过程定义了运用方法的顺序、应该交付的文档资料、为保证软件质量和协调变化所需要采取的管理措施，以及标志软件开发各个阶段任务完成的里程碑。为获得高质量的软件产品，软件过程必须科学、合理。</p>
</blockquote>
<pre><code>讲述在软件生命周期的过程中应该完成的基本任务，并介绍各种常用的过程模型。</code></pre><h5 id="经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）"><a href="#经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）" class="headerlink" title="经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）"></a>经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）</h5><h6 id="瀑布模型-waterfull-model"><a href="#瀑布模型-waterfull-model" class="headerlink" title="瀑布模型 waterfull model"></a>瀑布模型 waterfull model</h6><blockquote>
<p>瀑布模型一直是唯一被广泛采用的生命周期模型。现在它仍是软件工程中应用最广泛的过程模型。<br>    收集需求<br>        |<br>        分析<br>            |<br>            设计<br>                |<br>                编码<br>                    |<br>                    测试<br>                        |<br>                        维护<br>    按照传统的瀑布模型来开发软件，有如下几个特点：<br>    1、阶段间具有顺序性和依赖性<br>    这个特点有两重含义：<br>        - 必须等前一阶段的工作完成之后，才能开始后一阶段的工作<br>        - 前一阶段的输出文档就是后一阶段的输入文档。<br>            因此只有前一个阶段的输出文档正确，后一阶段的工作才能获得正确的结果 。<br>            但是，万一在生命周期某一阶段发现了问题，很可能需要追溯到在它之前的一些阶段，必要时还要修改已经完成的文档。<br>            然而，在生命周期后期改正早期阶段造成的问题，需要付出更高的代价，<br>    2、推迟实现的观点<br>        实践表明，对于规模较大的软件项目来说，往往编码开始开始的越早最终完成开发工作所需要的时间反而越长。这是因为，前面阶段的工作没做或做得不扎实，过早地考虑进行程序实现，往往导致大量返工，有时甚至发生无法弥补的问题，带来灾难性后果。<br>        瀑布模型在编码之前设置了系统分析和系统设计的各个阶段，分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现。</p>
</blockquote>
<pre><code>    清楚地区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想。
3、质量保证的观点
    为了保证所开发软件的质量，在瀑布模型的每个阶段都要坚持两个重要做法，
    - 每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。完成准确合格文档不仅是软件开发时期各类人员之间相互通信的媒介，也是运行时期对软件进行 维护的重要依据
    - 每个阶段结束 都要对所完成的 文档进行评审，以便尽早发现问题，改正错误。事实上，越是早期阶段犯下的错误，暴露出来的时间就越晚，排除故障改正 错误所需付出的代价也越高。因此，及时审查，是保证 软件质量，降低软件成本的重要措施。

    传统的瀑布模型过于理想化，事实上人在工作过程中不可能不犯错误。在设计阶段可能发现规格说明文档中的错误，而设计上的缺陷或错误可能在实现过程中显现出来，在综合测试阶段将发现需求分析/设计或编码阶段的许多错误。因此，实际的瀑布模型时带“反馈环”的。

    当在后面阶段发现前面阶段的错误时，需要沿图中左侧的反馈线返回前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务</code></pre><h6 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h6><blockquote>
<p>增量模型也称为渐增模型，使用增量模型开发软件时，把软件产品作为一系列增量构件来设计、编码、集成和测试。<br>    每个构件由多个相互作用的模块构成，并且能够完成特定的功能。<br>        使用增量模型时：<br>            第1个增量构件往往实现软件的基本需求，提供最核心的功能。<br>            （如在使用增量模型开发字处理软件时，第一个增量构件可能提供基本的文件管理、编辑、和文档生成功能）<br>            第2个增量构件提供更完善的编辑和文档生成功能时<br>            第3个增量构件实现拼写和语法检查功能<br>            第4个增量构件完成高级的页面排版功能。<br>        把软件产品分解成增量构件时，应该使构件的规模适中，规模过大或过小都不好。<br>        分解时唯一必须遵守的约束条件是：当把新构件集成到现有软件中时，所形成的产品必须是可测试的。<br>            分析-》设计-》编码 -》测试</p>
</blockquote>
<pre><code>增量模型分批地逐步向用户提交产品，每次提交一个满足用户需求子集的可运行的产品。整个产品被分解成许多个增量构件，开发人员一个构件接一个构件地向用户提交产品。每次用户都得到一个满足部分需求的可运行的产品，直到最后一次得到满足全部需求的完整产品。

优点：
- 能在较短时间内向用户提交完成一些有用的工作的产品
- 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击

使用增量模型的困难时，在把每个新的增量构件集成到现有的软件体系结构中时，必须不破坏原来已经开发出的产品。
此外，必须把软件的体系设计得便于按这种方式进行扩充，向现有产品中加入新构件过程必须简单、方便。
也就是说，软件体系结构必须时开放的。
从长远观点看，具有开发结构的软件拥有真正的优势，这种软件的可维护性明显好于封闭结构的软件。
尽管采用增量模型比采用瀑布模型和快速原型模型需要更精心的设计，但在设计阶段多付出的劳动将在维护阶段获得回报。

事实上，使用增量模型时开发软件和扩充软件功能（完善性维护）并没有本质区别，都是向现有产品加入新构件的过程。
从某种意义上说，增量模型本身时自相矛盾的。它一方面要求开发人员把软件看作一个整体，另一方面又要求开发人员把软件看作构件序列，每个构件本质上都独立与另一个构件。除非开发人员有足够的技术 能力协调好这一明显的矛盾，否则用增量模型开发出的产品可能并不令人满意。</code></pre><h6 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h6><h6 id="统一过程模型"><a href="#统一过程模型" class="headerlink" title="统一过程模型"></a>统一过程模型</h6><h5 id="过程评估与CMM-CMMI的基本概念"><a href="#过程评估与CMM-CMMI的基本概念" class="headerlink" title="过程评估与CMM/CMMI的基本概念"></a>过程评估与CMM/CMMI的基本概念</h5><h5 id="敏捷宣言与敏捷过程的特点"><a href="#敏捷宣言与敏捷过程的特点" class="headerlink" title="敏捷宣言与敏捷过程的特点"></a>敏捷宣言与敏捷过程的特点</h5>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NOTE/" rel="tag"># NOTE</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/13/linux/" rel="next" title="linux$">
                <i class="fa fa-chevron-left"></i> linux$
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/16/python/" rel="prev" title="python">
                python <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/bekjae.jpg" alt="KOKI HOO">
            
              <p class="site-author-name" itemprop="name">KOKI HOO</p>
              <p class="site-description motion-element" itemprop="description">PEACE&LOVE</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一部分-数据结构与算法"><span class="nav-number">1.</span> <span class="nav-text">第一部分 数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、栈-Stack-、队列-Queue-和向量-Vector"><span class="nav-number">1.1.</span> <span class="nav-text">一、栈(Stack)、队列(Queue)和向量(Vector)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单链表-Linked-Lists"><span class="nav-number">1.1.1.</span> <span class="nav-text">单链表 Linked Lists</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双向链表-Doubly-Linked-List"><span class="nav-number">1.1.2.</span> <span class="nav-text">双向链表 Doubly Linked List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#循环-环形-链表-Circular-Linked-List"><span class="nav-number">1.1.3.</span> <span class="nav-text">循环(环形)链表 Circular Linked List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#带哨兵结点的链表"><span class="nav-number">1.1.4.</span> <span class="nav-text">带哨兵结点的链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈的基本概念和性质-栈ADT及其顺序、链表实现"><span class="nav-number">1.1.5.</span> <span class="nav-text">栈的基本概念和性质,栈ADT及其顺序、链表实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#栈的基本概念和性质"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">栈的基本概念和性质</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#栈ADT"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">栈ADT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#栈的顺序存储实现"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">栈的顺序存储实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#栈的链式存储实现"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">栈的链式存储实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈的应用；Stack-Application"><span class="nav-number">1.1.6.</span> <span class="nav-text">栈的应用；Stack Application</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#栈与递归"><span class="nav-number">1.1.7.</span> <span class="nav-text">栈与递归</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#队列的基本概念和性质-队列ADT及其顺序、链表实现"><span class="nav-number">1.1.8.</span> <span class="nav-text">队列的基本概念和性质,队列ADT及其顺序、链表实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#队列的基本概念和性质"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">队列的基本概念和性质</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#队列ADT"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">队列ADT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#队列顺序、链表实现"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">队列顺序、链表实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#队列的应用"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">队列的应用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#向量的基本概念和性质-向量ADT及其数组、链表实现"><span class="nav-number">1.1.9.</span> <span class="nav-text">向量的基本概念和性质,向量ADT及其数组、链表实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、树"><span class="nav-number">1.2.</span> <span class="nav-text">二、树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#树的基本概念和术语"><span class="nav-number">1.2.1.</span> <span class="nav-text">树的基本概念和术语</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的前序、中序、后序、层次遍历"><span class="nav-number">1.2.2.</span> <span class="nav-text">树的前序、中序、后序、层次遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二叉树及其性质"><span class="nav-number">1.2.3.</span> <span class="nav-text">二叉树及其性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#普通树与二叉树的转换"><span class="nav-number">1.2.4.</span> <span class="nav-text">普通树与二叉树的转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的存储结构，标准形式"><span class="nav-number">1.2.5.</span> <span class="nav-text">树的存储结构，标准形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#完全树（complete-tree）的数组形式存储"><span class="nav-number">1.2.6.</span> <span class="nav-text">完全树（complete tree）的数组形式存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#树的应用"><span class="nav-number">1.2.7.</span> <span class="nav-text">树的应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Huffman树的定义与应用"><span class="nav-number">1.2.8.</span> <span class="nav-text">Huffman树的定义与应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Huffman树的定义"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">Huffman树的定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Huffman哈夫曼应用"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">Huffman哈夫曼应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、查找-search"><span class="nav-number">1.3.</span> <span class="nav-text">三、查找(search)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查找的基本概念"><span class="nav-number">1.3.1.</span> <span class="nav-text">查找的基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对线性关系结构的查找"><span class="nav-number">1.3.2.</span> <span class="nav-text">对线性关系结构的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#顺序查找"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#二分查找"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">二分查找</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hash查找法"><span class="nav-number">1.3.3.</span> <span class="nav-text">Hash查找法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#常见的哈希函数-直接定址法、随机数法"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">常见的哈希函数(直接定址法、随机数法)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#hash冲突的概念"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">hash冲突的概念</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#解决冲突的方法-开散列方法-拉链法，闭散列方法-开放定址法"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">解决冲突的方法(开散列方法/拉链法，闭散列方法/开放定址法)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#二次聚集现象"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">二次聚集现象</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BST树-二叉搜索树-Binary-Search-Tree"><span class="nav-number">1.3.4.</span> <span class="nav-text">BST树(二叉搜索树) Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#BST树定义、性质、ADT及其实现"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">BST树定义、性质、ADT及其实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#BST树查找、插入、删除算法"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">BST树查找、插入、删除算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#平衡树AVL"><span class="nav-number">1.3.5.</span> <span class="nav-text">平衡树AVL</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#平衡树-AVL-定义、性质、ADT及其实现"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">平衡树(AVL)定义、性质、ADT及其实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#平衡树-AVL-查找、插入算法"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">平衡树(AVL)查找、插入算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#平衡因子的概念"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">平衡因子的概念</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优先队列与堆"><span class="nav-number">1.3.6.</span> <span class="nav-text">优先队列与堆</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#优先队列与堆的定义"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">优先队列与堆的定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#堆的生成"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">堆的生成</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#调整算法"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">调整算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#范围查询"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">范围查询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、排序"><span class="nav-number">1.4.</span> <span class="nav-text">四、排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#排序基本概念"><span class="nav-number">1.4.1.</span> <span class="nav-text">排序基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#冒泡排序——不要求"><span class="nav-number">1.4.2.</span> <span class="nav-text">冒泡排序——不要求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入排序算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.4.3.</span> <span class="nav-text">插入排序算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#希尔排序算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.4.4.</span> <span class="nav-text">希尔排序算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择排序算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.4.5.</span> <span class="nav-text">选择排序算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#快速排序算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.4.6.</span> <span class="nav-text">快速排序算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#合并排序算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.4.7.</span> <span class="nav-text">合并排序算法基本思想，算法代码及基本的时间复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基数排序算法基本思想，算法代码及基本的时间复杂度分析"><span class="nav-number">1.4.8.</span> <span class="nav-text">基数排序算法基本思想，算法代码及基本的时间复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、图"><span class="nav-number">1.5.</span> <span class="nav-text">五、图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#图的基本概念"><span class="nav-number">1.5.1.</span> <span class="nav-text">图的基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#图的存储结构"><span class="nav-number">1.5.2.</span> <span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#邻接矩阵"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#邻接表"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#图的遍历"><span class="nav-number">1.5.3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#广度优先遍历"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">广度优先遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#深度优先遍历"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">深度优先遍历</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最小生成树-Minimum-Spanning-Tree"><span class="nav-number">1.5.4.</span> <span class="nav-text">最小生成树 (Minimum Spanning Tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#贪心算法"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">贪心算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最短路径问题"><span class="nav-number">1.5.5.</span> <span class="nav-text">最短路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#BFS-广度优先遍历算法"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">BFS 广度优先遍历算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Dijkstra算法"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Floyd算法"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">Floyd算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拓扑排序"><span class="nav-number">1.5.6.</span> <span class="nav-text">拓扑排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二部分-软件工程"><span class="nav-number">2.</span> <span class="nav-text">第二部分 软件工程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、软件过程"><span class="nav-number">2.1.</span> <span class="nav-text">一、软件过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#软件过程的概念；"><span class="nav-number">2.1.1.</span> <span class="nav-text">软件过程的概念；</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）"><span class="nav-number">2.1.2.</span> <span class="nav-text">经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#瀑布模型-waterfull-model"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">瀑布模型 waterfull model</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#增量模型"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">增量模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#演化模型"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">演化模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#统一过程模型"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">统一过程模型</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#过程评估与CMM-CMMI的基本概念"><span class="nav-number">2.1.3.</span> <span class="nav-text">过程评估与CMM/CMMI的基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#敏捷宣言与敏捷过程的特点"><span class="nav-number">2.1.4.</span> <span class="nav-text">敏捷宣言与敏捷过程的特点</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KOKI HOO</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">53.8k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jD3hLxRDgCSdorrir1RFkW3R-gzGzoHsz", "9AOQX6uUKthSSONK5UO95RGd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
