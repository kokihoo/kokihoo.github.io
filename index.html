<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="PEACE&amp;LOVE">
<meta property="og:type" content="website">
<meta property="og:title" content="KOKI">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KOKI">
<meta property="og:description" content="PEACE&amp;LOVE">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KOKI">
<meta name="twitter:description" content="PEACE&amp;LOVE">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>KOKI</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a5ecac7771fad0fda5191a255b9e3f5c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KOKI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/07/Linked List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/07/Linked List/" itemprop="url">链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-07T17:11:20+08:00">
                2020-01-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-01-09T10:44:40+08:00">
                2020-01-09
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2020/01/07/Linked List/" class="leancloud_visitors" data-flag-title="链表">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h6><p>We are going to introduce another data structure - Linked List.</p>
<p>Similar to the array, the linked list is also a linear data structure . Here is an example:<br><img src="/images/linkedlist.png" alt="链表"></p>
<p>AS you can see, each element in the linked list is actually a separate object while all the objects are linked together by the reference field in each element.</p>
<p>There are two types of linked list: singly linked list and doubly linked list. The example above is a singly linked list and here is an example of doubly linked<br><img src="/images/doublyLinkedList.png" alt="双链表"></p>
<p>We will introduce more in later chapters, you wil:<br>    - Understand the structure of singly linked list and doubly linked list<br>    - Implement traversal, insertion, deletion in a singly or doubly linked list<br>    - Analyze the complexity of different operations in a singly or doubly linked list<br>    - Use two-pointer technique (fast-pointers-slow-pointer technique) in the linked list<br>    - Slove classic problems such as reverse a linked list<br>    - Analyze the complexity of the algorithms you designed<br>    - Accumulate experience in designing and debugging</p>
<h6 id="Singly-Linked-List"><a href="#Singly-Linked-List" class="headerlink" title="Singly Linked List"></a>Singly Linked List</h6><p>As we mentioned in the overview, linked list is a linear data structure which link all the sepearated elements together by the reference field. There are two commonly-used linked list: singly-linked list and doubly-linked list.</p>
<p>In this chapter, we will start with the singly-linked list and help you:<br>    - Understand the structure of the singly-linked list;<br>    - Perform traversal, insertion and deletion in a singly-linked list<br>    - Analyze the time complexity of different operations in the singly-linked list</p>
<p>####### Introduction - Singly Linked List<br>Each node in a singly-linked list contains not only the value but also a reference field to link to the next node.<br>By this way, the singly-linked list organizes all the nodes in a sequence.</p>
<p>Here is an example of a singly-linked list:<br><img src="/images/singlyLinkedList.png" alt="单链表"><br>The blue arrows show how nodes in a singly linked list are combined together</p>
<p>Node Structure<br>here is the typical definition of a node in a singly-linked list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// C++</span><br><span class="line">// Definition for singly-linked list</span><br><span class="line">struct SinglyListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    SinglyListNode *next;</span><br><span class="line">    SinglyListNode(int x): val(x), next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Java</span><br><span class="line">// Definition for singly-linked list</span><br><span class="line">public class SinglyListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    SinglyListNode next;</span><br><span class="line">    SinglyListNode(int x) &#123; val = x&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In most cases, we will use the head node(the first node) to represent the whole list.</p>
<p>Operation</p>
<p>Unlike the array, we are not able to access a random element in a singly-linked list in constant time If we want to get the ith element, we have to traverse from the head node one by one. It takes us O(N) time on average to visit an element by index, where N is the length of the linked list.</p>
<p>For instance, in the example above , the head node is node 23. The only way to visit the 3rd node is to use the “next” field of the head node to get to the 2nd node(node 6); Then with the “next” field of node 6, we are able to visit the 3rd node,</p>
<p>You might wonder why the linked list is useful though it has such a bad performance (compared to the array) in accessing data by index. We will inroduce the insert and delete operations in next two articles and you will realize the benefit of the linked list</p>
<p>After that, we provide an exceise for you to design your own singly linked list.</p>
<p>######## Add Operation - Singly Linked List<br>If we want to add a new value after a given node prev, we should:</p>
<ol>
<li>Initialize a new node cur with the given value;<br><img src="/images/addNodeSinglyList.png" alt="单链表添加操作1"></li>
<li>Linke the “next” field of cur to prev’s next node next;<br><img src="/images/addSinglyList2.png" alt="单链表添加操作2"></li>
<li>Link the “next” filed in prev to cur<br><img src="/images/addSinglyLinkList.png" alt="单链表添加操作3"></li>
</ol>
<p>Unlike an array, we don’t need to move all elements past the instead element Therefore, you can insert a new node into a linked list in O(1) time complexity, which is very efficent.</p>
<p>######### Example<br><img src="/images/singlyexample.png" alt="例子"><br>Let’s insert a new value 9 after the second node 6.</p>
<p>We will first initialize a new node with value 9.Then link node 9 to node 15. Finally, link node 6 to node 9.</p>
<p>After insertion, our linked list will look like this:</p>
<p><img src="/images/addSinglyLinkListAfter.png" alt="例子"></p>
<p>######### Add a Node at the beginning<br>As we know, we use the head node head to represent the whole list<br>So it is essential to update head when adding a new node at the beginning of the list.<br>    1. Initialize a new node cur<br>    2. Link the new node to our original head node head<br>    3. Assign cur to head</p>
<p>For example, let’s add a new node 9 at the beginnig of the list.<br>    1.  We initialize a new node 9 and link node 9 to current head node 23<br><img src="/images/addHeadSinglyLinkedList.png" alt="添加头部结点1"><br>    2.  Assign node 9 to be our new head.<br><img src="/images/addHeadSinglyLinkedList2.png" alt="添加头部结点2"></p>
<p>What about adding a new node at the end of the list? Can we still use similar strategy?</p>
<p>######## Delete Operation - Singly Linked List<br>If we want to delete an exsiting node cur from the singly linked list, we can do it in two steps:<br>        1.Find cur’s previous node prev and its next node next;<br><img src="/images/deleteSinglyLinkedList.png" alt="删除单链表结点"><br>        2.Link prev to cur’s next node next.<br><img src="/images/deleteSinglyLinkedList2.png" alt="删除单链表结点2"></p>
<p>In our first step, we need to find out prev and next. It is easy to find out next using th reference filed or cur. However, we have to traverse the linked list from the head node to find out prev which will take O(N) time on average, where N is the length of the linked list. So the time complexity of deleting a node will be O(N).</p>
<p>The space complexity is O(1) because we only need constant space to store our pointers.</p>
<p>######### An Example<br><img src="/images/deleteSinglyListExample.png" alt="删除单链表结点示例"><br>Let’s try to delete node 6 from the singly linked list above.</p>
<ol>
<li>Traverse the linked list from the head until we find the previous node prev which is node 23</li>
<li>Link prev(node 23) with next (node 15)</li>
</ol>
<p><img src="/images/deleteSinglyLinkListExample2.png" alt="删除单链表结点示例2"><br>Node 6 is not in our singly linked list now.</p>
<p>######### Delete the First Node<br>If we want to delete the first node, the strategy will be a little different.</p>
<p>As we mentioned before, we use the head node head to represent a linked list. Our head is the black node 23 in the example below.<br><img src="/images/deleteFirstLinkedList.png" alt="删除首个结点"></p>
<p>If we want to delete the first node, we can simply assin the next node to head. That is to say, our head will be node 6 after deletion</p>
<p><img src="/images/deleteHeadFirstLinkedList2.png" alt="删除首个结点2"></p>
<p>The linked list begins at the head node, so node 23 is no longer in our linked list.</p>
<p>What about deleting the last node? Can we still use similar strategy?</p>
<p>######### Design Linked List</p>
<p>Design your implementation of the linked list, you can choose to use the singly linkd list or the doubly linked list. A node in a singly linked list should have two attributes: [val] and [next]. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute [prev] to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p>
<p>Implement these functions in your linked list class:<br>    - get(index): Get the value of the index-th node in the linked list. If the index  is invalid, return -1.<br>    - addAtHead(val): Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.<br>    - addAtTail(val): Append a node of value val to the last element of linked list</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/961-rjgc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/25/961-rjgc/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-25T18:17:54+08:00">
                2019-11-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-11-25T18:17:57+08:00">
                2019-11-25
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/11/25/961-rjgc/" class="leancloud_visitors" data-flag-title>
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第二部分-软件工程"><a href="#第二部分-软件工程" class="headerlink" title="第二部分 软件工程"></a>第二部分 软件工程</h3><h4 id="一、软件过程"><a href="#一、软件过程" class="headerlink" title="一、软件过程"></a>一、软件过程</h4><h5 id="软件过程的概念；"><a href="#软件过程的概念；" class="headerlink" title="软件过程的概念；"></a>软件过程的概念；</h5><blockquote>
<p>  软件工程过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。<br>    在完成开发任务时必须要进行一些开发活动，并且使用适当的资源（人员、时间、计算机硬件、软件工具等），在过程结束时将输入（如软件需求）转化为输出（如软件产品），因此ISO9000把过程定义为“把输入传化为输出的一组彼此相关的资源和活动”。过程定义了运用方法的顺序、应该交付的文档资料、为保证软件质量和协调变化所需要采取的管理措施，以及标志软件开发各个阶段任务完成的里程碑。为获得高质量的软件产品，软件过程必须科学、合理。</p>
</blockquote>
<pre><code>讲述在软件生命周期的过程中应该完成的基本任务，并介绍各种常用的过程模型。</code></pre><h5 id="经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）"><a href="#经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）" class="headerlink" title="经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）"></a>经典软件过程模型的特点（瀑布模型、增量模型、演化模型、统一过程模型）</h5><h6 id="瀑布模型-waterfull-model"><a href="#瀑布模型-waterfull-model" class="headerlink" title="瀑布模型 waterfull model"></a>瀑布模型 waterfull model</h6><blockquote>
<p>瀑布模型一直是唯一被广泛采用的生命周期模型。现在它仍是软件工程中应用最广泛的过程模型。<br>    收集需求<br>        |<br>        分析<br>            |<br>            设计<br>                |<br>                编码<br>                    |<br>                    测试<br>                        |<br>                        维护<br>    按照传统的瀑布模型来开发软件，有如下几个特点：<br>    1、阶段间具有顺序性和依赖性<br>    这个特点有两重含义：<br>        - 必须等前一阶段的工作完成之后，才能开始后一阶段的工作<br>        - 前一阶段的输出文档就是后一阶段的输入文档。<br>            因此只有前一个阶段的输出文档正确，后一阶段的工作才能获得正确的结果 。<br>            但是，万一在生命周期某一阶段发现了问题，很可能需要追溯到在它之前的一些阶段，必要时还要修改已经完成的文档。<br>            然而，在生命周期后期改正早期阶段造成的问题，需要付出更高的代价，<br>    2、推迟实现的观点<br>        实践表明，对于规模较大的软件项目来说，往往编码开始开始的越早最终完成开发工作所需要的时间反而越长。这是因为，前面阶段的工作没做或做得不扎实，过早地考虑进行程序实现，往往导致大量返工，有时甚至发生无法弥补的问题，带来灾难性后果。<br>        瀑布模型在编码之前设置了系统分析和系统设计的各个阶段，分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现。</p>
</blockquote>
<pre><code>    清楚地区分逻辑设计与物理设计，尽可能推迟程序的物理实现，是按照瀑布模型开发软件的一条重要的指导思想。
3、质量保证的观点
    为了保证所开发软件的质量，在瀑布模型的每个阶段都要坚持两个重要做法，
    - 每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。完成准确合格文档不仅是软件开发时期各类人员之间相互通信的媒介，也是运行时期对软件进行 维护的重要依据
    - 每个阶段结束 都要对所完成的 文档进行评审，以便尽早发现问题，改正错误。事实上，越是早期阶段犯下的错误，暴露出来的时间就越晚，排除故障改正 错误所需付出的代价也越高。因此，及时审查，是保证 软件质量，降低软件成本的重要措施。

    传统的瀑布模型过于理想化，事实上人在工作过程中不可能不犯错误。在设计阶段可能发现规格说明文档中的错误，而设计上的缺陷或错误可能在实现过程中显现出来，在综合测试阶段将发现需求分析/设计或编码阶段的许多错误。因此，实际的瀑布模型时带“反馈环”的。

    当在后面阶段发现前面阶段的错误时，需要沿图中左侧的反馈线返回前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务</code></pre><h6 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h6><blockquote>
<p>增量模型也称为渐增模型，使用增量模型开发软件时，把软件产品作为一系列增量构件来设计、编码、集成和测试。<br>    每个构件由多个相互作用的模块构成，并且能够完成特定的功能。<br>        使用增量模型时：<br>            第1个增量构件往往实现软件的基本需求，提供最核心的功能。<br>            （如在使用增量模型开发字处理软件时，第一个增量构件可能提供基本的文件管理、编辑、和文档生成功能）<br>            第2个增量构件提供更完善的编辑和文档生成功能时<br>            第3个增量构件实现拼写和语法检查功能<br>            第4个增量构件完成高级的页面排版功能。<br>        把软件产品分解成增量构件时，应该使构件的规模适中，规模过大或过小都不好。<br>        分解时唯一必须遵守的约束条件是：当把新构件集成到现有软件中时，所形成的产品必须是可测试的。<br>            分析-》设计-》编码 -》测试</p>
</blockquote>
<pre><code>增量模型分批地逐步向用户提交产品，每次提交一个满足用户需求子集的可运行的产品。整个产品被分解成许多个增量构件，开发人员一个构件接一个构件地向用户提交产品。每次用户都得到一个满足部分需求的可运行的产品，直到最后一次得到满足全部需求的完整产品。

优点：
- 能在较短时间内向用户提交完成一些有用的工作的产品
- 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击

使用增量模型的困难时，在把每个新的增量构件集成到现有的软件体系结构中时，必须不破坏原来已经开发出的产品。
此外，必须把软件的体系设计得便于按这种方式进行扩充，向现有产品中加入新构件过程必须简单、方便。
也就是说，软件体系结构必须时开放的。
从长远观点看，具有开发结构的软件拥有真正的优势，这种软件的可维护性明显好于封闭结构的软件。
尽管采用增量模型比采用瀑布模型和快速原型模型需要更精心的设计，但在设计阶段多付出的劳动将在维护阶段获得回报。

事实上，使用增量模型时开发软件和扩充软件功能（完善性维护）并没有本质区别，都是向现有产品加入新构件的过程。
从某种意义上说，增量模型本身时自相矛盾的。它一方面要求开发人员把软件看作一个整体，另一方面又要求开发人员把软件看作构件序列，每个构件本质上都独立与另一个构件。除非开发人员有足够的技术 能力协调好这一明显的矛盾，否则用增量模型开发出的产品可能并不令人满意。</code></pre><h6 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h6><h6 id="统一过程模型"><a href="#统一过程模型" class="headerlink" title="统一过程模型"></a>统一过程模型</h6><h5 id="过程评估与CMM-CMMI的基本概念"><a href="#过程评估与CMM-CMMI的基本概念" class="headerlink" title="过程评估与CMM/CMMI的基本概念"></a>过程评估与CMM/CMMI的基本概念</h5><h6 id="过程评估"><a href="#过程评估" class="headerlink" title="过程评估"></a>过程评估</h6><blockquote>
<p>  软件过程评估所关注的是软件组织自身内部软件过程的改进问题，目的在于发现缺陷，提出改进的方向。</p>
</blockquote>
<h6 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h6><blockquote>
<pre><code>CMM能力成熟度模型（Capbility maturity model for Software,CMM）,CMM时国际工人的对软件公司进行成熟度等级认证的重要标准，并不是一个软件生命周期模型，而是改进软件过程的一种策略，它与实际使用的过程模型无关。</code></pre></blockquote>
<pre><code>软件能力成熟度模型是一种对软件组织在定义、实施、度量、控制和改善其软件过程的实践中各个发展阶段的描述。CMM的核心是把软件开发视为一个过程，并根据这一原则对软件开发和维护进行过程监控和研究，以使其更加科学化、标准化、使企业能够更好的实现商业目标。

能力成熟度模型的基本思想是，因为问题是由管理软件过程的方法不当引起的，所以新软件技术的运用并不会自动提高生产率和软件质量。能力成熟度模型有助于软件开发组织建立一个有规律的、成熟的软件过程。改进后的过程将开发出质量更好的软件，使更多的软件项目免受时间和费用超出之苦。

CMM的用途主要有两个：
- 软件开发组织用它来改进开发和维护软件的过程
- 政府或商业企业用它来评价一个特定的软件公司签订软件项目合同的风险</code></pre><h6 id="CMMI"><a href="#CMMI" class="headerlink" title="CMMI"></a>CMMI</h6><blockquote>
<pre><code>CMMI（Capability Maturity Model Integration For Software，软件能力成熟度模型集成）将各种能力成熟度模型，即：Software CMM，Systems Eng-CMM、People CMM和Acquisition CMM，整合到同一架构中去，由此建立起包括软件工程、系统工程和软件采购等在内的模型的集成，以解决除软件开发以外的软件系统工程和软件采购工作中的迫切需求。
CMMI的基本思想
1、解决软件项目过程改进难度增大的问题
2、实现软件工程的并行与多学科组合
3、实现过程改进的最佳效益</code></pre></blockquote>
<h5 id="敏捷宣言与敏捷过程的特点"><a href="#敏捷宣言与敏捷过程的特点" class="headerlink" title="敏捷宣言与敏捷过程的特点"></a>敏捷宣言与敏捷过程的特点</h5><h6 id="敏捷宣言的特点"><a href="#敏捷宣言的特点" class="headerlink" title="敏捷宣言的特点"></a>敏捷宣言的特点</h6><h6 id="敏捷过程的特点"><a href="#敏捷过程的特点" class="headerlink" title="敏捷过程的特点"></a>敏捷过程的特点</h6><h4 id="二、软件需求"><a href="#二、软件需求" class="headerlink" title="二、软件需求"></a>二、软件需求</h4><h5 id="软件需求的概念"><a href="#软件需求的概念" class="headerlink" title="软件需求的概念"></a>软件需求的概念</h5><blockquote>
<p>  软件需求<br>    1、用户解决问题或达到目的所需条件或权能Capability<br>    2、系统或系统部件要满足合同、标准、规范、或其他正式规定文档所需具有的条件或权能<br>    3、一种反映上面1、2、所述条件或权能的文档说明。它包括功能性需求及非功能性需求，非功能性需求对设计和实现提出类限制，比如性能要求、质量标准、或者设计限制</p>
</blockquote>
<pre><code>软件需求包括三个不同的层次- 业务需求、用户需求和功能需求，也包括非功能需求

业务需求 Business requirement：反映了组织机构或客户对系统、产品高层次的目标要求，它们在项目试图和范围文档中予以说明
用户需求 User requirement：文档描述用户使用产品必须要完成的任务，这在使用实例（use case）文档或方案脚本（scenario）说明中予以说明
功能需求 Function requirement：定义了开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足类业务需求。所谓特性feature是指逻辑上相关的功能需求的集合，给用户提供处理能力并满足业务需求。
非功能需求：作为不充，软件需求规格说明还应包括非功能需求，它描述类系统展现给用户的行为和执行的操作等。它包括产品必须遵从的标准、规范和合约；外部界面的具体细节；性能要求；设计或实现的约束条件及质量属性。所谓约束是指开发人员在软件产品设计和构造上的限制。质量属性是通过多种角度对产品的特点进行描述，从而反映产品功能。多角度描述产品对用户和开发人员都极为重要。值得注意的一点的是，需求并未包括设计细节、实现细节、项目计划信息或测试信息。需求于这些没有关系，它关注的是充分说明你究竟想开发什么。e</code></pre><h5 id="需求工程的基本过程"><a href="#需求工程的基本过程" class="headerlink" title="需求工程的基本过程"></a>需求工程的基本过程</h5><blockquote>
<p>  需求获取、需求分析于协商、系统建模、需求规约、需求验证、需求管理</p>
</blockquote>
<h5 id="分层数据流模型"><a href="#分层数据流模型" class="headerlink" title="分层数据流模型"></a>分层数据流模型</h5><h5 id="用例和场景建模及其UML表达（用例图、活动图、泳道图、顺序图）"><a href="#用例和场景建模及其UML表达（用例图、活动图、泳道图、顺序图）" class="headerlink" title="用例和场景建模及其UML表达（用例图、活动图、泳道图、顺序图）"></a>用例和场景建模及其UML表达（用例图、活动图、泳道图、顺序图）</h5><h6 id="用例图-use-case-diagram"><a href="#用例图-use-case-diagram" class="headerlink" title="用例图 use-case diagram"></a>用例图 use-case diagram</h6><blockquote>
<p>  用例是对系统提供的功能（即系统的具体方法）的描述。用例图从用户的角度描述系统功能，并指出各个功能的操作者。用例图定义了系统的功能需求。<br>    在UML中，组成用例图的主要元素是系统、用例、行为者以及用例之间的关系</p>
</blockquote>
<h6 id="活动图-activity-diagram"><a href="#活动图-activity-diagram" class="headerlink" title="活动图 activity diagram"></a>活动图 activity diagram</h6><blockquote>
<p>  活动图描述为满足用例要求而进行的动作以及动作间的关系，活动图是状态图的一个变种，它是另一种描述交互的方法</p>
</blockquote>
<h6 id="泳道图-activity-diagram"><a href="#泳道图-activity-diagram" class="headerlink" title="泳道图 activity diagram"></a>泳道图 activity diagram</h6><h6 id="顺序图-sequence-diagram"><a href="#顺序图-sequence-diagram" class="headerlink" title="顺序图 sequence diagram"></a>顺序图 sequence diagram</h6><blockquote>
<p>  顺序图显示若干个对象间的动态协作关系，它强调对象之间发送消息的先后次序，描述对象之间的交互过程。</p>
</blockquote>
<h5 id="数据模型建模及其UML表达（类图）"><a href="#数据模型建模及其UML表达（类图）" class="headerlink" title="数据模型建模及其UML表达（类图）"></a>数据模型建模及其UML表达（类图）</h5><blockquote>
<p>  calss diagram<br>    类图不仅定义系统中的类，表示类与类之间的关系（如关联、依赖、泛化、细化等关系），也表示类的内部结构（类的属性和操作）。类图描述的是一种静态关系，在系统的整个生命周期内都是有效的</p>
</blockquote>
<h5 id="行为模型建模及其UML表达（状态机图）"><a href="#行为模型建模及其UML表达（状态机图）" class="headerlink" title="行为模型建模及其UML表达（状态机图）"></a>行为模型建模及其UML表达（状态机图）</h5><h4 id="三、软件设计与构造"><a href="#三、软件设计与构造" class="headerlink" title="三、软件设计与构造"></a>三、软件设计与构造</h4><h5 id="软件体系结构及体系结构风格的概念"><a href="#软件体系结构及体系结构风格的概念" class="headerlink" title="软件体系结构及体系结构风格的概念"></a>软件体系结构及体系结构风格的概念</h5><h5 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a>设计模式的概念</h5><h5 id="模块化设计的基本思想及概念（抽象、分解、模块化、封装、信息隐藏、功能独立）"><a href="#模块化设计的基本思想及概念（抽象、分解、模块化、封装、信息隐藏、功能独立）" class="headerlink" title="模块化设计的基本思想及概念（抽象、分解、模块化、封装、信息隐藏、功能独立）"></a>模块化设计的基本思想及概念（抽象、分解、模块化、封装、信息隐藏、功能独立）</h5><h5 id="软件重构的概念"><a href="#软件重构的概念" class="headerlink" title="软件重构的概念"></a>软件重构的概念</h5><h5 id="软件体系结构的UML建模（包图、类图、构件图、顺序图、部署图）"><a href="#软件体系结构的UML建模（包图、类图、构件图、顺序图、部署图）" class="headerlink" title="软件体系结构的UML建模（包图、类图、构件图、顺序图、部署图）"></a>软件体系结构的UML建模（包图、类图、构件图、顺序图、部署图）</h5><h5 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h5><h5 id="面向对象设计原则（开闭原则、Liskov替换原则、依赖转置原则、接口隔离原则）"><a href="#面向对象设计原则（开闭原则、Liskov替换原则、依赖转置原则、接口隔离原则）" class="headerlink" title="面向对象设计原则（开闭原则、Liskov替换原则、依赖转置原则、接口隔离原则）"></a>面向对象设计原则（开闭原则、Liskov替换原则、依赖转置原则、接口隔离原则）</h5><h5 id="内聚与耦合的概念、常见的内聚和耦合类型"><a href="#内聚与耦合的概念、常见的内聚和耦合类型" class="headerlink" title="内聚与耦合的概念、常见的内聚和耦合类型"></a>内聚与耦合的概念、常见的内聚和耦合类型</h5><h4 id="四、软件测试"><a href="#四、软件测试" class="headerlink" title="四、软件测试"></a>四、软件测试</h4><h5 id="软件测试及测试用例的概念"><a href="#软件测试及测试用例的概念" class="headerlink" title="软件测试及测试用例的概念"></a>软件测试及测试用例的概念</h5><h5 id="单元测试、集成测试、确认测试、系统测试、回归测试的概念"><a href="#单元测试、集成测试、确认测试、系统测试、回归测试的概念" class="headerlink" title="单元测试、集成测试、确认测试、系统测试、回归测试的概念"></a>单元测试、集成测试、确认测试、系统测试、回归测试的概念</h5><h5 id="调试的概念、调试与测试的关系"><a href="#调试的概念、调试与测试的关系" class="headerlink" title="调试的概念、调试与测试的关系"></a>调试的概念、调试与测试的关系</h5><h5 id="测试覆盖度的概念"><a href="#测试覆盖度的概念" class="headerlink" title="测试覆盖度的概念"></a>测试覆盖度的概念</h5><h5 id="白盒测试、黑盒测试的概念"><a href="#白盒测试、黑盒测试的概念" class="headerlink" title="白盒测试、黑盒测试的概念"></a>白盒测试、黑盒测试的概念</h5><h5 id="代码圈复杂度的计算方法"><a href="#代码圈复杂度的计算方法" class="headerlink" title="代码圈复杂度的计算方法"></a>代码圈复杂度的计算方法</h5><h5 id="白盒测试测试中的基本路径测试方法"><a href="#白盒测试测试中的基本路径测试方法" class="headerlink" title="白盒测试测试中的基本路径测试方法"></a>白盒测试测试中的基本路径测试方法</h5><h5 id="黑盒测试中的等价类划分方法"><a href="#黑盒测试中的等价类划分方法" class="headerlink" title="黑盒测试中的等价类划分方法"></a>黑盒测试中的等价类划分方法</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/23/Tableau/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/Tableau/" itemprop="url">Tableau</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T10:57:58+08:00">
                2019-08-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-11-11T14:38:07+08:00">
                2019-11-11
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BI/" itemprop="url" rel="index">
                    <span itemprop="name">BI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/23/Tableau/" class="leancloud_visitors" data-flag-title="Tableau">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  61
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h5><p>维度与度量<br>    维度是类别字段，切片数值的依据，维度通常是离散的<br>    度量是指标，是希望分析的数字，度量是连续的，连续字段在列表中创建轴</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/23/QueueAndStack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/QueueAndStack/" itemprop="url">队列和栈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T10:57:58+08:00">
                2019-08-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-01-07T17:08:23+08:00">
                2020-01-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/23/QueueAndStack/" class="leancloud_visitors" data-flag-title="队列和栈">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><pre><code>在数组中，我们可以通过索引访问随机元素，但是，在某些情况下，我们可能想要限制处理顺序。

有两种不同的处理顺序，先入先出和后入先出，以及两个相应数据结构：队列和栈

以下将详细介绍每个数据结构的定义、实现以及内置函数，然后将更多地关注两种这两种数据结构的实际应用。

1、了解FIFO和LIFO处理顺序的原理
2、实现这两个数据结构
3、熟悉内置的队列和栈结构
4、解决基本的队列相关问题，尤其是BFS
5、理解当使用DFS和其他递归算法来解决问题时，系统栈是如何帮助实现的</code></pre><h6 id="Queue-First-in-first-out-Data-Structure"><a href="#Queue-First-in-first-out-Data-Structure" class="headerlink" title="Queue - First-in-first-out Data Structure"></a>Queue - First-in-first-out Data Structure</h6><pre><code>先入先出的数据结构
在FIFO数据结构中，将首先处理添加队列中的第一个元素。</code></pre><p><img src="/images/%E9%98%9F%E5%88%97.png" alt="队列"><br>    如上图所示，队列是典型的FIFO数据结。插入insert操作也称作入队enqueue，新元素始终被添加在队列的末尾。删除delete操作也被称作dequeue。只能移除第一个元素</p>
<p>[示例] —— 队列<br>1、入队：Enqueue<br><img src="/images/%E5%85%A5%E9%98%9F%E5%89%8D.png" alt="入队前"> =&gt; <img src="/images/%E5%85%A5%E9%98%9F%E5%90%8E.png" alt="入队后">     </p>
<p>2、出队：Dequeue<br><img src="/images/%E5%87%BA%E9%98%9F%E5%89%8D.png" alt="出队前"> =&gt; <img src="/images/%E5%87%BA%E9%98%9F%E5%90%8E.png" alt="出队后">     </p>
<p>####### Queue-implement</p>
<pre><code>为了实现队列，我们可以使用动态数组和指向队列的头部的索引。
如上所述：队列应支持两种操作: 入队和出队。入队会向队列追加一个新的元素，而出队会删除第一个元素。所以我们需要一个索引来指出起点。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// c++</span><br><span class="line">#include &lt;isostream&gt;</span><br><span class="line">class MyQueue &#123;</span><br><span class="line">    prviate:</span><br><span class="line">        // store elements</span><br><span class="line">        vector&lt;int&gt; data;</span><br><span class="line">        // a pointer to indicate the start position</span><br><span class="line">        int p_start;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        MyQueue() &#123;p_start = 0;&#125;</span><br><span class="line">        // Insert an element into the queue. Return true if the operation is successful</span><br><span class="line">        bool enQueue(int x)&#123;</span><br><span class="line">            data.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        // Delete an element from the queue. Return true if the operation is successful</span><br><span class="line">        bool deQueue()&#123;</span><br><span class="line">            if(isEmpty())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            p_start++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // Get the front item from the queue</span><br><span class="line">        int Front() &#123;</span><br><span class="line">            return data[p_start];</span><br><span class="line">        &#125;</span><br><span class="line">        // checks whether the queue is empty or not</span><br><span class="line">        bool isEmpty()&#123;</span><br><span class="line">            return p_start &gt;= data.size();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Myqueue q;</span><br><span class="line">    q.enQueue(5);</span><br><span class="line">    q.deQueue(3);</span><br><span class="line">    if(!q.isEmpty())&#123;</span><br><span class="line">        cout &lt;&lt; q.Front() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.deQueue();</span><br><span class="line">    if(!q.isEmpty())&#123;</span><br><span class="line">        cout &lt;&lt; q.Front() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.deQueue();</span><br><span class="line">    if (!q.isEmpty()) &#123;</span><br><span class="line">        cout &lt;&lt; q.Front() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// java</span><br><span class="line">// “static void main” must be defined in a public class.</span><br><span class="line">class MyQueue &#123;</span><br><span class="line">    // store elements</span><br><span class="line">    private List&lt;Integer&gt; data;</span><br><span class="line">    // a pointer to indicate the start position</span><br><span class="line">    private int p_start;</span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        data = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        p_start = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // Insert an element into the queue. Return true if the operation is successful</span><br><span class="line">    public boolean enQueue(int x) &#123;</span><br><span class="line">        data.add(x);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // Delete an element from the queue. Return ture if the operation is successful</span><br><span class="line">    public boolean deQueue() &#123;</span><br><span class="line">        if(isEmpty() == true)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Get the front item from the queue</span><br><span class="line">    public int Front() &#123;</span><br><span class="line">        return data.get(p_start);</span><br><span class="line">    &#125;</span><br><span class="line">    // Checks whether the queue is empty or not</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return p_start &gt;= data.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyQueue q = new MyQueue();</span><br><span class="line">        q.enQueue(5);</span><br><span class="line">        q.enQueue(3);</span><br><span class="line">        if(q.isEmpty() == false) &#123;</span><br><span class="line">            System.out.println(q.Front());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        if(q.isEmpty() == false) &#123;</span><br><span class="line">            System.out.println(q.Front());</span><br><span class="line">        &#125;</span><br><span class="line">        q.deQueue();</span><br><span class="line">        if(q.isEmpty() == false) &#123;</span><br><span class="line">            System.out.println(q.Front());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

缺点：上面的实现很简单，但在某些情况下效率很低。随着起始指针的移动，会浪费越来越多的空间。当我们有空间限制时，这将是难以接受的。</code></pre><p><img src="/images/%E5%85%A5%E9%98%9F%E7%BC%BA%E7%82%B9.png" alt="入队缺点"></p>
<pre><code>让我们考虑一种情况，即我们只能分配一个最大长度为5的数组，当我们只添加少于5个元素时，我们的解决方案很有效。例如，如果我们只调用入队函数四次后还想要将元素10入队，那么我们可以成功。

但是我们不能接受更多的入队请求，这是合理的，因为现在队列已经满了，但是如果我们将一个元素出队呢？</code></pre><p><img src="/images/%E5%87%BA%E9%98%9F%E7%BC%BA%E7%82%B9.png" alt="出队缺点"></p>
<pre><code>实际上，在这种情况下，我们应该能够再接受一个元素</code></pre><p>####### Circular Queue<br>    Previously, we have provided a straightforward but inefficient implementation of queue.<br>    此前我们提供了一种简单但低效的队列实现。<br>    A more efficient way is to use a circular queue. Specifically, we may use a fixed-size array and two pointers to indicate the starting position and the ending position. And the goal is to reuse the wasted storage we mentioned previously.<br>    更有效的方式是使用循环队列，具体来说，我们可以使用固定大小的数组和两个指针来指示起始位置和结束位置，目的是重用我们之前提到的被浪费的存储<br>    Let’s take a look at an example to see how a circular queue works. You should pay attention to the strategy we use to enqueue and dequeue an element.<br>    让我们来看个示例查看循环队列的工作原理。你应该注意我们入队和出队元素时使用的策略。</p>
<pre><code>Review the animation carefully to figure out the strategy we use to check if a queue is empty or full .
仔细检查动画，找出我们用来检查队列是空还是满的策略
For the next exercise, we will let you try to implement the circular queue by yourself and provide a solution later.
下一个练习，我们将让你自己尝试实现循环队列，之后会提供给你一个解决方案。</code></pre><p>####### Design Circular Queue<br>    Design your implementation of circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO(First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called “Ring Buffer”<br>    设计你的循环队列的实现。循环队列是一种线性数据结构，其操作表现基于FIFO（先进先出）原则并且队尾被连接在队首之后形成一个循环。它也被称为“环形缓冲器”</p>
<pre><code>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.
循环队列的一个好处是我们可以利用跟这个队列之前用过的空间，在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列的前面仍有空间，但是使用循环队列，我们能使用这些空间去存储新的值

Your implementation should support following operations:
-   MycircularQueue(k)：Construtor, set the size of the queue to be k. 构造器，设置队列长度为k
-   Front: Get the front item from the queue, If the queue is empty, retur -1. 从队首获取元素。如果队列为空，返回-1
-   Rear: Get the last item from the queue. If the queue is empty, return -1. 获取队尾元素，如果队列为空，返回-1
-   enQueue(value): Insert an element into the circular queue. Return true if the operation is successful. 向循环队列插入一个元素，如果成功插入则返回真
-   deQueue(): Delete an elements from the circular queue. Return true if the operation is successful. 从循环队列中删除一个元素。如果成功删除则返回真
-   isEmpty(): Checks whether the circular queue is empty or not. 检查循环队列是否为空
-   isFull(): Checks whether the circular queue is full or not. 检查循环队列是否已满

Example:
    MyCircularQueue circularQueue = new MycircularQueue(3); // set the size to be 3
    circularQueue.enQueue(1); // return true
    circularQueue.enQueue(2); // return true
    circularQueue.enQueue(3); // return ture
    circularQueue.enQueue(4); // return false, the queue is full
    circularQueue.Rear(); // return 3
    circularQueue.isFull(); // return true
    circularQueue.deQueue(); // return true
    circularQueue.enQueue(4); // return true
    circularQueue.Rear(); // return 4</code></pre><p>####### Circular Queue - Implementation</p>
<pre><code>In a circular queue, we use an array and two pointers, head and tail. head indicates the start position of the queue while tail indicates the ending position of the queue

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// C++</span><br><span class="line">class MyCircularQueue &#123;</span><br><span class="line">    private:</span><br><span class="line">        vector&lt;int&gt; data:</span><br><span class="line">        int head;</span><br><span class="line">        int tail;</span><br><span class="line">        int size;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        // initialize your data structure here. Set the size of the queue to be k</span><br><span class="line">        MyCircularQueue(int k)&#123;</span><br><span class="line">            data.resize(k);</span><br><span class="line">            head = -1;</span><br><span class="line">            tail = -1;</span><br><span class="line">            size = k;</span><br><span class="line">        &#125;</span><br><span class="line">        // Insert an element into the circular queue. Return true if the operation is successful</span><br><span class="line">        bool enQueue(int value) &#123;</span><br><span class="line">            if(isFull()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(isEmpty()) &#123;</span><br><span class="line">                head = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = (tail + 1)%size;</span><br><span class="line">            data[tail] = value;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // Delete an element from the circular queue. Return true if the operation is successful</span><br><span class="line">        bool deQueue() &#123;</span><br><span class="line">            if(isEmpty()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(head == tail) &#123;</span><br><span class="line">                head = -1;</span><br><span class="line">                tail = -1;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            head = (head + 1) % size;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // Get the front item from the queue</span><br><span class="line">        int Front() &#123;</span><br><span class="line">            if(isEmpty())&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            return data[head];</span><br><span class="line">        &#125;</span><br><span class="line">        // Get the last item from the queue</span><br><span class="line">        int Rear() &#123;</span><br><span class="line">            if(isEmpty()) &#123;</span><br><span class="line">                return -1</span><br><span class="line">            &#125;</span><br><span class="line">            return data[tail]</span><br><span class="line">        &#125;</span><br><span class="line">        // Checks whether the circular queue is empty or not</span><br><span class="line">        bool isEmpty() &#123;</span><br><span class="line">            return head == -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // Checks whether the circular queue is full or not</span><br><span class="line">        bool isFull() &#123;</span><br><span class="line">            return ((tail + 1) % size) == head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &lt;!-- MyCircularQueue object will be instantiated and called as such:</span><br><span class="line">        MyCircularQueue obj = new MyCircularQueue(k);</span><br><span class="line">        bool param_1 = obj.enQueue(value);</span><br><span class="line">        bool param_2 = obj.deQueue()</span><br><span class="line">        int param_3 = obj.Front();</span><br><span class="line">        int param_4 = obj.Rear();</span><br><span class="line">        bool param_5 = obj.isEmpty();</span><br><span class="line">        bool param_6 = obj.isFull();  --&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

//java
class MyCircularQueue{
    private int[] data;
    private int head;
    private int tail;
    private int size;

    // Initialize your data structure here, Set size of the queue to be k
    public MyCircularQueue(int k) {
        data = new int[k];
        head = -1;
        tail = -1;
        size = k;
    }

    // Insert an element into the circular queue. Return true if the operation is successful
    public boolean enQueue(int value) {
        if(isFull() == true) {
            return false;
        }
        if(isEmpty() == true) {
            head = 0
        }
        tail = (tail + 1) % size;
        data[tail] = value;
        return true;
    }
    // Detele an element from the circular queue. Return true if the operation is successful
    public boolean deQueue() {
        if(isEmpty() == true) {
            return false;
        }
        if(head == tail) {
            head = -1;
            tail = -1;
            return true;
        }
    }
    // Get the front item from the queue
    public int Front() {
        if(isEmpty() ==  true) {
            return -1;
        }
        return data[head];
    }
    // Get the last item from the queue
    public int Rear() {
        if(isEmpty() == true) {
            return -1;
        }
        return data[tail];
    }
    // check whether the circular queue is full or not
    public boolean isFull() {
        return ((tail + 1) % size ) == head; 
    }
}

// MyCircularQueue object will be isntianted and called as such
// MyCircularQueue obj = new MycircularQueue(k);
// boolean param_1 = obj.enQueue(value);
// boolean param_2 = obj.deQueue();
// int param_3 = obj.Front();
// int param_4 = obj.Rear();
// boolean param_5 = obj.isEmpty();
// boolean param_6 = obj.isFull();
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####### Queue - Usage</span><br><span class="line">Most popular languages provide built-in Queue library so you don&apos;t have to reinvent the wheel.</span><br><span class="line"></span><br><span class="line">As mentioned before, the queue has two important operations, enqueue and dequeue. Besides, we should be able to get the first element in a queue since the first element should be processed first.</span><br><span class="line"></span><br><span class="line">Below are some examples of using the built-in Queue library and its common operations:</span><br></pre></td></tr></table></figure>

// C++
#include &lt;iostream&gt;

int main() {
    // 1. Initialize a queue.
    queue&lt;int&gt; q:
    // 2. Push new element.
    q.push(5);
    q.push(13);
    q.push(8);
    q.push(6);
    // 3. Check if queue is empty
    if(q.empty()){
        cout &lt;&lt; &quot;Queue is empty!&quot;&lt;&lt; endl;
        return 0;
    }
    // 4. Pop an element
    q.pop();
    // 5. Get the first element
    cout &lt;&lt;&quot;The first element is:&quot;&lt;&lt; q.front() &lt;&lt; endl;
    // 6. Get the last element
    cout &lt;&lt; &quot;The last element is:&quot; &lt;&lt; q.back() &lt;&lt;  endl;
    // 7. Get the size of the queue
    cout &lt;&lt; &quot;The size is: &quot;&lt;&lt;q.size() &lt;&lt; endl;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

// Java
public class Main{
    public static void main(String[], args){
        // 1. Intiallize a queue
        Queue&lt;Integer&gt; q = new LinkedList();
        // 2. Get the first element - return null if queue is empty
        System.out.println(&quot;The first element is:&quot; + q.peek());
        // 3. Push new element
        q.offer(5);
        q.offer(13);
        q.offer(8);
        q.offer(6);
        // 4. Pop an element
        q.poll()
        // 5. Get the first element
        System.out.println(&quot;The first element is: &quot; + q.peek());
        // 7. Get the size of the queue
        System.out.println(&quot;The size is: &quot; + q.size());

    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    We provide exercise after this article to help you familiarize with these operations. And remember when you want to process the elements in order, using a queue might be a good choice.</span><br><span class="line">    当你想要按顺序处理元素时，使用队列可能是一个很好的选择</span><br><span class="line"></span><br><span class="line">    Moving Average from Data Stream</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####### Queue and BFS</span><br><span class="line"></span><br><span class="line">One common application of Breadth-first Search(BFD) is to find the shortest path from the root node to the target node. In this article, we provide an example to explain how queue is applied in a BFS algorithm step by step.</span><br><span class="line"></span><br><span class="line">An Example</span><br><span class="line">Here we provide an example to show how BFS is used to find the shortest path between the root node A and the target node G</span><br><span class="line"></span><br><span class="line">[BFS动画演示](https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/)</span><br><span class="line"></span><br><span class="line">Insights</span><br><span class="line">After watching the animation above, let&apos;s answer the following questions:</span><br><span class="line"></span><br><span class="line">1、What is the processing order of the nodes?</span><br><span class="line"></span><br><span class="line">In the first round, we process the root node. In the second round, we process the nodes next to the root node; in third round, we process the nodes which are two steps from the root node; so on and so forth.</span><br><span class="line"></span><br><span class="line">Similar to tree&apos;s level-order traversl, the nodes closer to the root node will be traversed earlier.</span><br><span class="line"></span><br><span class="line">If a node x is added to the queue in the kth round, the length of the shortest path between the root node and x is exactly k, That is to say, you are already in the shortest path the first time you find the target node.</span><br><span class="line"></span><br><span class="line">2、What is the enqueue and dequeue order of the queue?</span><br><span class="line">As shown in the animation above, we first enqueue the root node. Then in each round ,we process the nodes which are already in the queue one by one and add all their neighbors to the queue. It is worth nothing that the newly-added nodes will not be traversed immediately but will be processed in the next round.</span><br><span class="line"></span><br><span class="line">The processing order of the nodes is the exact same order as how they were added to the queue, which is First-in-First-out (FIFO). That&apos;s why we use a queue in BFS.</span><br><span class="line"></span><br><span class="line">####### BFS- template</span><br><span class="line"></span><br><span class="line">    Previously, we have already introduced two ain scenarios of using BFS: do traversal or find the shortest path. Typically, it happends in a tree or a graph. As we mentioned in the chapter description,BFS can also be used in more abstract scenarios.</span><br><span class="line"></span><br><span class="line">    In this article, we will provide you with a tempalte. Then , we provide some exercise after this article for practices.</span><br><span class="line"></span><br><span class="line">    It will be important to determined the nodes and the edges before doing BFS in a specfic question.Typically, the node will be an actual node or a status while the edge will be an actual edge or a possible transition.</span><br><span class="line"></span><br><span class="line">    tempate I</span><br><span class="line">    Here we provide a pseudocode for you as a template</span><br></pre></td></tr></table></figure>

/**
* Return the length of the shortest path between root and target node.
*/
int BFS(Node root, Node target) {
    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i &lt; size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    1、 As shown in the code, in each round, the nodes in the queue are the nodes which are waiting to be processed.</span><br><span class="line">    2、 After each outer while loop, we are one step farther from the root node. The variable step indicates the distance from the root node and the current node we are visiting.</span><br><span class="line"></span><br><span class="line">    Tempate II </span><br><span class="line">    Sometimes, it is important to make sure that we never visit a node twice. Otherwise, we might get stuck in an infinite loop e.g. in graph with cycle. If so , we can add a hash set to the code above to solve this problem. Here is the pseudocode after modification.</span><br><span class="line"></span><br><span class="line">    // Return the length of the shortest path between root and target node.</span><br><span class="line">    int BFS(Node root, Node target)&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed</span><br><span class="line">        Set&lt;Node&gt; visited; // store all the nodes that we&apos;ve visited</span><br><span class="line">        int step = 0; // number of steps needed from root to current node</span><br><span class="line">        // initialize</span><br><span class="line">        add root to queue;</span><br><span class="line">        add root to visited;</span><br><span class="line">        // BFS</span><br><span class="line">        while (queue is not empty) &#123;</span><br><span class="line">            step = step + 1;</span><br><span class="line">            // iterate the nodes which are already in the queue</span><br><span class="line">            int size = queue.size();</span><br><span class="line"></span><br><span class="line">            for(int i=0; i&lt;size; i++)&#123;</span><br><span class="line">                Node cur = the first node in queuel</span><br><span class="line">                return step if cur is target;</span><br><span class="line">                for (Node next: the neighbours of cur) &#123;</span><br><span class="line">                    if(next is no in visited) &#123;</span><br><span class="line">                        add next to queue;</span><br><span class="line">                        add next to visited;</span><br><span class="line">                    &#125;</span><br><span class="line">                    remove the first node from queue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return -1; // there is no path from root to target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    There are some cases where one does not need keep the visited hash set:</span><br><span class="line">        1. You are absolutely sure there is no cycle, form example, in tree traversal;</span><br><span class="line">        2. You do want to add the node to the queue multiple times.</span><br><span class="line"></span><br><span class="line">    Walls and Gates</span><br><span class="line">    Number of Islands</span><br><span class="line">    Open the Lock</span><br><span class="line">    Perfect Squares</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### Stack - Last-in-first-out Data Structure</span><br><span class="line"></span><br><span class="line">![栈](/images/栈.png)</span><br><span class="line"></span><br><span class="line">    In a LIFO data structure, the newest element added to the queue will be processed first.</span><br><span class="line">    Different from the queue, the stack is a LIFO data structure. Typically, the insert operation is called push in a stack. Similar to the queue, a new element is always added at the end of the stack. However, the delete operation, pop will always remove the last element which is opposite from the queue.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####### Example - Stack</span><br><span class="line"></span><br><span class="line">    1.Push: you can click Push button blow to see how a new element 6 is added to the stack</span><br><span class="line">    2.Pop: you can click Pop button below to see which element will be removed when you pop an element from the stack.</span><br><span class="line"></span><br><span class="line">![push前](/images/push前.png)  -&gt;  ![push后](/images/push后.png) </span><br><span class="line">![pop前](/images/pop前.png)  -&gt;  ![pop后](/images/pop后.png) </span><br><span class="line"></span><br><span class="line">####### Implementation - Stack</span><br><span class="line"></span><br><span class="line">The implementation of a Stack is eaiser than a queue. A dynamic array is sufficient to implement a stack structure. Here we provide a simple implementation for your reference:</span><br></pre></td></tr></table></figure></code></pre><p>// C++<br>class MyStack {<br>    private:<br>        vector<int> data; // store elements<br>    public:<br>        // Insert an element into the stack<br>        void push(int x){<br>            data.push_back(x);<br>        }</int></p>
<pre><code>//  Checks whether the stack is empty or not
bool isEmpty() {
    return data.empty();
}

// get the top item from the queue
int top() {
    return data.back();
}

// Delete an element from the stack, Return true if the operation is successful
bool pop() {
    if (isEmpty()){
        return false;
    }
    data.pop_back();
    return true;
}</code></pre><p>};</p>
<p>int main() {<br>    MyStack s;<br>    s.push(1);<br>    s.push(2);<br>    s.push(3);<br>    for(int i=0; i&lt;4; ++i) {<br>        if(!s.isEmpty()){<br>            cout &lt;&lt; s.top() &lt;&lt; endl;<br>        }<br>        cout &lt;&lt; (s.pop() ? “true” : “false”) &lt;&lt; endl;<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>// Java</p>
<p>// static void main must be defined in a public class<br>class MyStack{<br>    private List<integer> data;  // store elments<br>    public MyStack() {<br>        data = new ArrayList&lt;&gt;();<br>    }</integer></p>
<pre><code>// Insert an element into the stack
public void push(int x) {
    data.add(x);
}

// Checks whether the stack is empty or not
public boolean isEmpty(){
    return data.isEmpty();
}

// Get the top item from the stack
public int top(){
    return data.get(data.size() - 1);
}

// Delete an element from the stack. Return true if the operation is successful.
public boolean pop(){
    if(isEmpty()){
        return false;
    }
    data.remove(data.size() - 1);
    return true;
}</code></pre><p>}</p>
<p>public class Main{<br>    public static void main(String[] args) {<br>        MyStack s = new MyStack();<br>        s.push(1);<br>        s.push(2);<br>        s.push(3);<br>        for(int i = 0; i&lt;4; ++i) {<br>            if(!s.isEmpty()){<br>                System.out.printIn(s.top());<br>            }<br>            System.out.println(s.pop());<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####### Stack - Usage</span><br><span class="line">Most popular languages provide built-in stack libaray so you don&apos;t have ro reinvent the wheel. Besides initialization, we need to know how to use the two most important </span><br><span class="line">operations, pop and push. Also, you should be able to get the top element  from the stack . Below are some code examples for your reference:</span><br></pre></td></tr></table></figure>

<p>// C++<br>int main() {<br>    // 1. Initialize a stack<br>    stack<int> s;<br>    // 2. Push new element<br>    s.push(5);<br>    s.push(13);<br>    s.push(8);<br>    s.push(6);</int></p>
<pre><code>// 3. Check if stack is empty
if(s.empty()){
    cout &lt;&lt; &quot;Stack is empty!&quot; &lt;&lt; endl;
    return 0;
}
// 4. Pop an element
s.pop();
// 5. Get the top element
cout &lt;&lt; &quot;The top element is: &quot; &lt;&lt; s.top() &lt;&lt; endl;
// 6. Get the size of the stack.
cout &lt;&lt; &quot;The size is: &quot; &lt;&lt; s.size() &lt;&lt; endl;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>// Java<br>// “static void main” must be defined in a public class<br>public class Main {<br>    public static void main(String[] args) {<br>        // 1. Initialize a stack<br>        Stack<integer> s = new Stack&lt;&gt;();<br>        // 2. Push new element<br>        s.push(5)<br>        s.push(13);<br>        s.push(8);<br>        s.push(6);<br>        // 3. Check if the stack is empty<br>        if(s.empty() == true) {<br>            System.out.println(“Stack is empty!”);<br>            return;<br>        }<br>        // 4. Pop an elements<br>        s.pop();<br>        // 5. Get the top element<br>        System.out.println(“The top element is: “ + s.peek());<br>        // 6. Get the size of the stack<br>        System.out.println(“The size is: “ + s.size());<br>    }<br>}</integer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">From now on, we are able to use the built-in stack library to solve problems more conveniently. Let&apos;s start with an interesting problem(Min Stack) to help you review the useful operations. Then we will</span><br><span class="line">take a look at some classic Stack problems. When you want to process the last element first, the stack will be the most appropriate data structure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">######## Min Stack</span><br><span class="line">Design a stack that support push, pop, top, and retrieving the minimum element in constant time.</span><br><span class="line">    - push(x) -- Push element x onto stack</span><br><span class="line">    - pop(x) -- Removes the element on top of the stack</span><br><span class="line">    - top() -- Get the top element</span><br><span class="line">    - getMin() -- Retrieve the minimum element in the stack</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top(); --&gt; Returns 0</span><br><span class="line">minStack.getMin(); --&gt; Returns -2</span><br><span class="line"></span><br><span class="line">######## Valid Parentheses</span><br><span class="line">Given a string containing just the characters &apos;(&apos;, &apos;)&apos;,&apos;&#123;&apos;, &apos;&#125;&apos;, &apos;[&apos; and &apos;]&apos;, determine if the input string is valid.</span><br><span class="line"></span><br><span class="line">An input string is valid if:</span><br><span class="line">    1. Open brackets must be closed by the same type of brackets</span><br><span class="line">    2. Open brackets must be closed in the correct order.</span><br><span class="line"></span><br><span class="line">######## Daily Temperatures</span><br><span class="line">Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.</span><br><span class="line"></span><br><span class="line">For example, given the list or temperature T = [73, 74, 74, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0]</span><br><span class="line">Note: The length of temperatures will be in the range[1, 30000]. Each temperature will be an integer in the range [30, 100]</span><br><span class="line"></span><br><span class="line">######## Evaluate Reverse Polish Notation</span><br><span class="line">Evaluate the value of an arthmetic expression in Reverse Polish Notation</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">    - Division between two integers should truncate toward zero</span><br><span class="line">    - The given RPN expression is always valid. That means the expression would always evaluate to result and there won&apos;t be any divide by zero operation.</span><br><span class="line"></span><br><span class="line">####### Stack and DFS</span><br><span class="line">Prerequisite: Tree Traversal</span><br><span class="line"></span><br><span class="line">Smilar to BFS, Depth-First Search(DFS) can also be used to find the path from the root node to the target node. In this article, we provide an example to explain how DFS works and how a stack helps with DFS step by step.</span><br><span class="line"></span><br><span class="line">######## An Example</span><br><span class="line">Let&apos;s take a look at an example. We want to find a path from the root node A to the target node G by DFS</span><br><span class="line">[DFS](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1377/)</span><br><span class="line"></span><br><span class="line">Insights</span><br><span class="line">After watching the animation above, let&apos;s answer the following qestions:</span><br><span class="line">1. What is the processing order of the nodes?</span><br><span class="line">In the example above, we start from the root node A. First, we choose the path to the node B and trace-back til we reach the node E where we have no way to do deeper. Then we backtrack to A and choose the second path to the node C.From C, we try the first path to E but E has been visited. So we go back to C and ty another path to F. Finally, we find G.</span><br><span class="line"></span><br><span class="line">Overall, we only trace-back and try another path after we reach the deepest node.</span><br><span class="line"></span><br><span class="line">As a result, the first path you found in DFS is not always the shortest path. For instance, in the example above, we successfully found a path A-&gt;C-&gt;F-&gt;G and stop the DFS. But this is not the shortest path from A to G</span><br><span class="line"></span><br><span class="line">2. What is the push and pop order of teh stack?</span><br><span class="line"></span><br><span class="line">As shown in the animation above, we first push the root node to the stack; then we try the first neighbor B and push node B to the stack; so on and so forth. when we reach the deepest node E, we need to track back. And when we trace back, we will pop the deepest node from tha stack which is actually the last one pushed to the stack.</span><br><span class="line"></span><br><span class="line">The processing order of the nodes is the exact opposite order as how they were added to the stack, which is Last-in-First-out(LIFO). That&apos;s why we use a stack in DFS.</span><br><span class="line"></span><br><span class="line">######## DFS- Template I</span><br><span class="line">As we mentioned in the chapter&apos;s description, in most cases, we can also use DFS when using BFS . But there is an important difference: the traveral order.</span><br><span class="line"></span><br><span class="line">Different from BFS, the nodes you visit earlier might not be the nodes which are closer to the root node. As result, the first path you found in DFS might not be the shortest path.</span><br><span class="line"></span><br><span class="line">In this article, we will provie you a recursion template of DFS and show you how the stack helps with this process. And then we provide some exercise after this article for you to practice.</span><br><span class="line"></span><br><span class="line">Tempalte - Recursion</span><br><span class="line">There are two ways to implement DFS. The first one is to do recursion which you might already be familiar with. Here we provide a template as reference:</span><br></pre></td></tr></table></figure>

<p>// java<br>// return true if there is a path from cur to target<br>boolean DFS(Node cur, Node target, Set<node> visited){<br>    return true if cur is target;<br>    for (next:each neighbor of cur){<br>        if(next is not in visited){<br>            add next to visitde;<br>            return true if DFS(next, target, visited) == true;<br>        }<br>    }<br>    return false;<br>}</node></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">It seems like we don&apos;t have to use any stacks when we implement DFS recursively. But actually, we are using the implict stack provided by the system, also know as the Call Stack.</span><br><span class="line">当我们递归地实现DFS时，似乎不需要使用任何栈，但实际上，我们使用的是系统栈，也称为为调用栈</span><br><span class="line"></span><br><span class="line">An example</span><br><span class="line">Let&apos;s take a look at an example. We want to find a path between node 0 and node 3 in the graph below. We also show you the stack&apos;s status during each call.</span><br><span class="line"></span><br><span class="line">![stack](/images/stackcall.png)</span><br><span class="line"></span><br><span class="line">In each stack element, there is an integer cur, an integer target, a reference to array visited and a reference to array edges, which are exactly the parameters we have in the DFS function.</span><br><span class="line">We only show cur in the stack above.</span><br><span class="line"></span><br><span class="line">Each element costs constant space. And the size of the stack is exactly the depth of DFS, So in the worst case, it costs O(h) to maintain the system stack, where h is the maximum depth of DFS. </span><br><span class="line">You should never forget to take the system stack into consideration when calculating the space complexity.</span><br><span class="line"></span><br><span class="line">In the template above, we stop when we find the first path.</span><br><span class="line">What if you want to find the shortest path?</span><br><span class="line">Hint: Add one more parameter to indicate the shortest path you have already found. </span><br><span class="line"></span><br><span class="line">######### Number of Islands</span><br><span class="line">######### Clone Graph</span><br><span class="line">######### Target Sum</span><br><span class="line"></span><br><span class="line">######## DFS- Template II</span><br><span class="line">The advantage of the recursion solution is that it is easier to implement. However, there is a huge disadvantage: if the depth of recursion is to high, you will suffer from stack overflow. In that case, you might want to use BFS instead or implement DFS using an explicit stack.</span><br><span class="line"></span><br><span class="line">Here are provide a template using an explicit stack</span><br></pre></td></tr></table></figure>

<p>// Java<br>// Return true if there is a path from cur to target<br>boolean DFS(int root, int target) {<br>    Set<node> visited;<br>    Stack<node> stack;<br>    add root to stack;<br>    while (s is not empty) {<br>        Node cur = the top element in stack;<br>        remove the cur from the stack;<br>        return true if cur is target;<br>        for(Node next: the neighbours of cur) {<br>            if( next is not in visited) {<br>                add next to visited;<br>                add next to stack;<br>            }<br>        }<br>    }<br>    return false;<br>}<br>```</node></node></p>
<p>The logic is exactly the same with the recursion solution, But we use while loop and stack to simulate the sytem call stack during recursion. Running through several examples manuallt will definitely help you understand it better.<br>使用while循环和栈来模拟递归期间的系统调用栈</p>
<p>######### Binary Tree Inorder Traversal</p>
<p>######## Conclusion<br>In previous chapters, we have introduced two data structure: Queue and Stack</p>
<ol>
<li>Queue<br>Queue is a FIFO data structure: the first element will be processed first. There are two important operations:enqueue and dequeue. We can use a dynamic array with two pointers to implement a queue.</li>
</ol>
<p>We can use queue to implement Breath-first Search(BFS)</p>
<p>There are also some important extension of the queue. For example<br>    - Dequeue<br>    - Priority Queue<br>We will inroduce these structures in later cards.</p>
<ol start="2">
<li>Stack </li>
</ol>
<p>Stack is a LIFO data structure: the last element will be processed first. There are two important operations: push and pop. The implementation of stack is quite simple. A dynamic array will be enough to implement a stack.</p>
<p>We use stack when LIFO principle is satisfied. Depth-first Search(DFS) is an important applicaitons of stack.</p>
<ol start="3">
<li>Summary<br>To summarize, you should be able to understand and compare the following concepts:<ul>
<li>FIFO and LIFO</li>
<li>Queue and Stack</li>
<li>BFS and DFS</li>
</ul>
</li>
</ol>
<p>The best way to be comfortable with this topic is to pratice. We provide some more exercise for you in this chapter.</p>
<p>######### implement Queue using Stacks</p>
<p>######### implement Stack using Queues</p>
<p>######### Decode String</p>
<p>######### Flood Fill</p>
<p>######### 01 Matrix </p>
<p>######### Keys and Rooms</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/16/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/python/" itemprop="url">python</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T15:35:10+08:00">
                2019-08-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-25T10:26:46+08:00">
                2019-09-25
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/16/python/" class="leancloud_visitors" data-flag-title="python">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  64
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于计算机来说，二进制在物理器件上来说是最容易实现的（高压电表示1 ， 低压电表示0 ），于是冯 诺依曼结构的计算机都使用了二进制</p>
<p>量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息</p>
<h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><p>在程序设计中，变量时一种存储数据的载体，计算机中的变量时实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多类型，除了数值外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型，Python中的数据类型很多，而且也允许我们自定义新的数据类型,以下为几种常见的数据类型。</p>
<ul>
<li>整型： Python中可以处理任意大小的整数(Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此Python3.x中整数就只有int这一种了)，而且支持二进制、八进制、十进制、和十六进制的表示法</li>
<li>浮点型： 浮点数也就是小数，之所以称为浮点数，也是因为科学计数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法(123.456)之外还支持科学计数法(如1.2346e2)</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如’hello’和“hello”,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式(用三个单引号或三个双引号开头，是三个单引号三个双引号结尾)</li>
<li>布尔型：布尔值只有True,False两种值，在Python中，可以直接用True、False表示布尔值(请注意大小写)，也可以通过布尔运算计算出来（例如3&lt;5 会产生布尔值True，而 2==1 会产生布尔值False）。</li>
<li>复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部i换成了j</li>
</ul>
<p>数字：int和float，Python要支持其他类型的数字，例如Decimal或者Fraction。Python也内置对复数的支持，使用后缀j和J就可以表示虚数的部分（例：3+5j）<br>字符串：</p>
<ul>
<li>可以使用单引号(‘……’)，双引号(“……”)</li>
<li>反斜杠\可以用来转义，如果不希望前置\的字符转义成特殊字符，可以使用原始字符串方式，在引号前添加r即可</li>
<li>字符串字面值可以跨行连续输入，一种方式是用三重引号：”””……”””或’’’……’’’.字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个\即可。</li>
<li>字符串可以用+进行连接（粘到一起），也可以用*进行重复</li>
<li>相邻的两个或多个字符串字面值(引号引起来的字符)将会自动连接到一起，把很长的字符串拆开分别输入的时候尤其有用：只能对两个字面值这样操作，变量或者表达式不行，如果想连接变量，或者连接变量和字面值，可以用+号</li>
<li>字符串是可以被索引(下标访问)的，第一个字符索引是0，单个字符并没有特殊的类型，只是一个长度为一的字符串：</li>
<li>索引也可以是负数，这种会从右边开始数，-0和0是一样的，所以负数索引从-1开始</li>
<li>除了索引，字符春还支持切片，索引可以得到单个字符，而切片可以获取子字符串</li>
</ul>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>对于每个变量我们需要给它取一个名字，在Python中，变量命名需要遵循以下这些必须遵守的硬性规则：</p>
<p>硬性规则：</p>
<ul>
<li>变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头</li>
<li>大小写敏感（大写的A和小写的a是两个不同的变量）</li>
<li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突</li>
</ul>
<p>PEP 8 要求;</p>
<ul>
<li>用小写字母拼写，多个单词用下划线连接</li>
<li>受保护的实例属性用单个下划线开头</li>
<li>私有的实例属性用两个下划线开头</li>
</ul>
<p>作为一个专业的程序员，给变量事实上是所有的标识符命名时做到见名知意也是非常重要的。</p>
<h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><p>使用input()函数获取键盘输入<br>使用int()进行类型转换<br>用占位符格式化输出的字符串<br>用type()检查变量的类型<br>在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是我们后面要讲的创建对象的构造方法）</p>
<ul>
<li>int(): 将一个数值或字符串转换成整数，可以指定进制</li>
<li>float(): 讲一个字符串转换成浮点数</li>
<li>str(): 将指定的对象转换成字符串形式，可以指定编码</li>
<li>chr(): 将整数转换成改编码对应的字符串(一个字符)</li>
<li>ord(): 将字符串（一个字符）转换成对应的编码(整数)</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[] [:]</td>
<td>下标 切片</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
</tr>
<tr>
<td>~ + -</td>
<td>按位取反,正负号</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘 除 模 整除</td>
</tr>
<tr>
<td>+ -</td>
<td>加 减</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>右移 左移</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>^</td>
<td></td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>小于等于 小于 大于 大于等于</td>
</tr>
<tr>
<td>== !=</td>
<td>等于， 不等于</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>in not in</td>
<td>成分运算符</td>
</tr>
<tr>
<td>not or and</td>
<td>逻辑运算符</td>
</tr>
<tr>
<td>= += -= <em>= /= %= //= *</em>= &amp;= `</td>
<td>= ^= &gt;&gt;= &lt;&lt;= `</td>
</tr>
</tbody></table>
<p>== 说实话表格的最后一个我没看懂 = = </p>
<blockquote>
<p>说明：在实际开发中，如果搞不懂运算符的优先级，可以使用括号来确保运算的执行顺序</p>
</blockquote>
<p>和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于一个执行的整体。</p>
<h4 id="构造程序逻辑"><a href="#构造程序逻辑" class="headerlink" title="构造程序逻辑"></a>构造程序逻辑</h4><p>分支和循环结构会帮助我们将程序中逻辑建立起来，将来我们的程序无论简单复杂，都是由顺序结构、分支结构、循环结构构成的</p>
<h4 id="函数和模块的使用"><a href="#函数和模块的使用" class="headerlink" title="函数和模块的使用"></a>函数和模块的使用</h4><p>写出高质量的代码首先要解决的就是重复代码的问题。</p>
<p>X1+X2+X3+X4 = 8<br>这个问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。</p>
<p><img src="/images/Cmn.png" alt="求"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入M和N的计算C(M,N)</span><br><span class="line"></span><br><span class="line">m = int(input(&apos;m = &apos;))</span><br><span class="line">n = int(input(&apos;m = &apos;))</span><br><span class="line">fm = 1</span><br><span class="line">for num in range(1, m+1):</span><br><span class="line">    fm* = num //求m的阶乘</span><br><span class="line"></span><br><span class="line">fn = 1</span><br><span class="line">for num in range(1, n+1):</span><br><span class="line">    fn *= num // 求n的阶乘</span><br><span class="line"></span><br><span class="line">fmn = 1</span><br><span class="line">for num in range(1, m-n+1):</span><br><span class="line">    fmn *= num // 求m-n的阶乘</span><br><span class="line"></span><br><span class="line">print(fm//fn/fmn)</span><br></pre></td></tr></table></figure>

<p>定义函数<br>在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上的函数的因变量</p>
<p>重构之后的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def factorial(num):</span><br><span class="line">    求阶乘</span><br><span class="line">    ：param num：非负整数</span><br><span class="line">    ：return：num 的阶乘</span><br><span class="line"></span><br><span class="line">    result = 1</span><br><span class="line">    for n range(1, num+1):</span><br><span class="line">        result *= n</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">    m = int(input(&apos;m= &apos;))</span><br><span class="line">    n = int(input(&apos;n= &apos;))</span><br><span class="line"></span><br><span class="line">    # 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数</span><br><span class="line"></span><br><span class="line">    print(factrial(m)//factrial(n)//factrial(m-n))</span><br></pre></td></tr></table></figure>

<p>说明：python的math模块中其实已经有一个factorial函数，事实上要计算阶乘可以直接会用这个现成的函数而不用自已定义。</p>
<p>函数的参数</p>
<p>函数是绝大多数编程语言中都支持的一个代码的构建块，但是python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是python对函数参数的处理，在python中，函数的参数可以有默认值，也支持可变参数，所以Python并不需要像其他语言一直支持函数的重载，因为我们在定义一个函数的时候可以让它有不同的使用方式</p>
<p><strong>重载</strong>: 就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数或者方法之间，相互称之为重载函数或方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from random import radiant</span><br><span class="line"></span><br><span class="line">def roll_dice(n = 2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    摇筛子</span><br><span class="line"></span><br><span class="line">    :param n :筛子的个数</span><br><span class="line">    :return: n颗筛子点数之和</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    total = 0</span><br><span class="line">    for _ in range(n):</span><br><span class="line">        total += randiant(1, 6)</span><br><span class="line">    return total</span><br><span class="line"></span><br><span class="line">def add(a=0, b=0, c=0):</span><br><span class="line">    return a+b+c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果没有指定参数那么使用默认值摇两颗筛子 n=2</span><br><span class="line">print(roll_dice())</span><br><span class="line"></span><br><span class="line">#摇三颗筛子</span><br><span class="line">print(roll_dice(3))</span><br><span class="line">print(add())</span><br><span class="line">print(add(1))</span><br><span class="line">print(add(1,2))</span><br><span class="line">print(add(1,2,3))</span><br><span class="line"></span><br><span class="line">#传递参数时可以不按照设定的顺序进行传递</span><br><span class="line">print(add(c=50,a=100,b=200))</span><br></pre></td></tr></table></figure>

<p>我们在给上面两个函数的参数都设定了默认值，这也就意味着如果在调用的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。</p>
<p>其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定的，我们作为函数的设计对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下：</p>
<h1 id="在参数名前面的-表示args是一个可变参数"><a href="#在参数名前面的-表示args是一个可变参数" class="headerlink" title="在参数名前面的*表示args是一个可变参数"></a>在参数名前面的*表示args是一个可变参数</h1><h1 id="即在调用add函数时可以传入0个或多个参数"><a href="#即在调用add函数时可以传入0个或多个参数" class="headerlink" title="即在调用add函数时可以传入0个或多个参数"></a>即在调用add函数时可以传入0个或多个参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def add(*args):</span><br><span class="line">    total = 0</span><br><span class="line">    for val in args:</span><br><span class="line">        total += val</span><br><span class="line">    return total</span><br><span class="line"></span><br><span class="line">print(add())</span><br><span class="line">print(add(1))</span><br><span class="line">print(add(1, 2))</span><br><span class="line">print(add(1, 2, 3))</span><br><span class="line">print(add(1, 3, 5, 7, 9))</span><br></pre></td></tr></table></figure>

<p>用模块管理函数</p>
<p>对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么就意味两个函数同名函数实际上只有一个是存在的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&apos;hello, world!&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&apos;goodbye, world!&apos;)</span><br></pre></td></tr></table></figure>

<p>当然上面的情况很容易就能避免，但是如果项目是由多人呢协作进行团队开发的时候，团队中可能有多个程序都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案很简单，Python中每个文件就代表了衣蛾模块module，我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。</p>
<p>module1.py</p>
<p>def foo():<br>    print(‘hello world!’)</p>
<p>module2.py</p>
<p>def foo():<br>    print(‘goodbye, world’)</p>
<p>test.py<br>    from module1 import foo<br>    # 输出hello, world！<br>    foo()<br><br>    from module2 import foo<br>    #输出”goodbye world!”<br>    foo()</p>
<p>也可以按照如下所示的方式来区分到底要使用哪一个foo函数</p>
<p>test.py<br>import module1 as m1<br>import module2 as m2</p>
<p>m1.foo()<br>m2.foo()</p>
<p>但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。</p>
<p>test.py</p>
<p>from module1 import foo<br>from module2 import foo</p>
<h1 id="输出goodbye，world！"><a href="#输出goodbye，world！" class="headerlink" title="输出goodbye，world！"></a>输出goodbye，world！</h1><p>foo()</p>
<p>test.py</p>
<p>from module2 import foo<br>from module1 import foo</p>
<h1 id="输出hello-world"><a href="#输出hello-world" class="headerlink" title="输出hello world"></a>输出hello world</h1><p>foo()</p>
<p>需要说明的是如果我们导入的模块除了定义函数之外还可以有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“_main_”</p>
<p>module3.py</p>
<p>def foo():<br>    pass</p>
<p>def bar():<br>    pass</p>
<h1 id="name-是Python中一个隐含的变量它代表了模块的名字"><a href="#name-是Python中一个隐含的变量它代表了模块的名字" class="headerlink" title="_name_是Python中一个隐含的变量它代表了模块的名字"></a>_name_是Python中一个隐含的变量它代表了模块的名字</h1><h1 id="只有被Python解释器执行的模块的名字才是main"><a href="#只有被Python解释器执行的模块的名字才是main" class="headerlink" title="只有被Python解释器执行的模块的名字才是main"></a>只有被Python解释器执行的模块的名字才是<em>main</em></h1><p>if <em>_name == ‘_main</em>‘:<br>    print(‘call foo()’)<br>    foo()<br>    print(‘call bar()’)<br>    bar()</p>
<p>test.py</p>
<pre><code>import module3

# 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是_main_</code></pre><p>当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们要定义和使用函数的一个非常重要的原因</p>
<h5 id="Python中有关变量作用域的问题"><a href="#Python中有关变量作用域的问题" class="headerlink" title="Python中有关变量作用域的问题"></a>Python中有关变量作用域的问题</h5><p>def foo():<br>    b = ‘Hello’</p>
<pre><code>def bar(): #Python中可以在函数内部再定义函数
    c = True
    print(a)
    print(b)
    print(c)

bar()
# print(c) NameError:name c is not defined</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    a = 100<br>    # print(b) #NameError: name ‘b’ is not defined<br>    foo()</p>
<p>上面的代码能够顺利的执行并且打印出100和‘Hello’，但我们注意到了在bar的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量(global variable),属于全局作用域，因为它没有定义在任何一个函数中，在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它。但是对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的，bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的，事实上，Python查找一个变量会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码已经看到了，所谓的内置作用域就是Python内置的那些隐含标识符min 、len等都属于内置作用域</p>
<p>下面的代码，希望通过函数调用修改全局变量a的值，但是实际上下面的代码是做不到的。<br>def foo():<br>    a = 200<br>    print(a)  # 200</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    a = 100<br>    foo()<br>    print(a) # 100</p>
<p>在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因为foo函数不在搜索全局作用域的中a，如果我们希望在foo函数中修改全局作用域中的a，代码如下所示：<br>    def foo():<br>        global a<br>        a = 200<br>        print(a)  # 200</p>
<pre><code>if __name__ == &apos;__main__&apos;:
    a = 100
    foo()
    print(a) # 200</code></pre><p>我们在使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域。</p>
<p>在实际开发中，我们应该应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能会导致对象占用内存长时间无法被垃圾回收。事实上减少对全局变量的使用，也是减低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其函数调用结束后依然可以访问，这时候就需要使用闭包。</p>
<p>我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。</p>
<p>def mian():<br>    # Todo: Add your code here<br>    # 局部作用域<br>    pass</p>
<p>if <strong>name</strong> = ‘<strong>main</strong>‘<br>    #全局作用域<br>    main()</p>
<h4 id="字符串和常用数据结构"><a href="#字符串和常用数据结构" class="headerlink" title="字符串和常用数据结构"></a>字符串和常用数据结构</h4><h5 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h5><p>今天的计算机更多的时间需要处理的数据可能都是以文本的方式存在的，如果我们希望通过Python程序操作这些文本信息，就必须要先了解字符串类型以及与它相关的知识。</p>
<p>所谓字符串，就是由零个或多个字符组成的有限序列，一般记为s = a1a2a3……an(0&lt;=n&lt;=∞)</p>
<p>我们可以通过下面的代码来了解字符串的使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    str1 = &apos;hello world!&apos;</span><br><span class="line">    # 通过len函数计算字符串的长度</span><br><span class="line">    print(len(str1))  # 13</span><br><span class="line">    # 获得字符串首字母大写的拷贝</span><br><span class="line">    print(str1.capitalize()) # Hello, world!</span><br><span class="line">    # 获得字符串变大写后的拷贝</span><br><span class="line">    print(str1.upper())  # HELLO, WORLD!</span><br><span class="line">    # 从字符串中查找子串所在位置</span><br><span class="line">    print(str1.find(&apos;or)) # 8</span><br><span class="line">    print(str1.find(&apos;shit&apos;)) # -1</span><br><span class="line">    # 与find类似但找不到子串时会引发异常</span><br><span class="line">    # print(str1.index(&apos;or&apos;))</span><br><span class="line">    # print(str1.index(&apos;shit&apos;))</span><br><span class="line">    # 检查字符串是否以指定的字符串开头</span><br><span class="line">    print(str1.startwith(&apos;He&apos;))  # False</span><br><span class="line">    print(str1.startwith(&apos;hel&apos;)) # True</span><br><span class="line">    # 检查字符串是否以指定的字符串结尾</span><br><span class="line">    print(str1.endswith(&apos;!&apos;)) # True</span><br><span class="line">    # 将字符串以指定的宽度居中并在两侧填充指定的字符</span><br><span class="line">    print(str1.center(50, &apos;*&apos;))</span><br><span class="line">    # 将字符串以指定的宽度靠右并在左侧填充指定的字符</span><br><span class="line">    print(str1.rjust(50, &apos;*&apos;))</span><br><span class="line">    str2 = &apos;abc123456&apos;</span><br><span class="line">    # 从字符串中取出指定位置的字符(下标计算)</span><br><span class="line">    print(str2[2])  # c</span><br><span class="line">    # 字符串切片(从指定的开始索引到指定的结束索引)</span><br><span class="line">    print(str2[2:5]) # c12</span><br><span class="line">    print(str2[2:])  # c123456</span><br><span class="line">    print(str2[2::2]) # c246</span><br><span class="line">    print(str2[::2]) # ac246</span><br><span class="line">    print(str2[::-1]) # 654321cba</span><br><span class="line">    print(str2[-3:-1]) # 45</span><br><span class="line">    # 检查字符串是否由数字构成</span><br><span class="line">    print(str2.isdigit()) # False</span><br><span class="line">    # 检查字符串是否以字母构成</span><br><span class="line">    print(str2.isalpha) # False</span><br><span class="line">    # 检查字符串是否是以数字和字母构成</span><br><span class="line">    print(str2.isalnum()) # True</span><br><span class="line">    str3 = &apos;  jackfrued@126.com&apos;</span><br><span class="line">    print(str3)</span><br><span class="line">    # 获得字符串修剪左右两侧空格的拷贝</span><br><span class="line">    print(str3.strip())</span><br><span class="line"></span><br><span class="line">    if __name__ == &apos;__main__&apos;:</span><br><span class="line">        main()</span><br><span class="line"></span><br><span class="line">    除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数的时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。</span><br><span class="line"></span><br><span class="line">##### 使用列表</span><br><span class="line">    下面的列表演示了如何定义列表，使用下标访问列表元素以及添加和删除元素的操作</span><br><span class="line">    def main()</span><br><span class="line">        list1 = [1,3,5,7,100]</span><br><span class="line">        print(list1)</span><br><span class="line">        list2 = [&apos;hello&apos;] * 5</span><br><span class="line">        print(list2)</span><br><span class="line">        # 计算列表长度元素个数</span><br><span class="line">        print(len(list1))</span><br><span class="line">        # 下标(索引)运算</span><br><span class="line">        print(list1[0])</span><br><span class="line">        print(list1[4])</span><br><span class="line">        # print(list1[5]) # IndexError: list index out of range</span><br><span class="line">        print(list1[-1])</span><br><span class="line">        print(list1[-3])</span><br><span class="line">        list1[2] = 300</span><br><span class="line">        print(list1)</span><br><span class="line">        # 添加元素</span><br><span class="line">        list1.append(200)</span><br><span class="line">        list1.insert(1, 400)</span><br><span class="line">        list1 += [1000, 2000]</span><br><span class="line">        print(list1)</span><br><span class="line">        print(len(list1))</span><br><span class="line">        # 删除元素</span><br><span class="line">        list1.remove(3)</span><br><span class="line">        if 1234 in list1:</span><br><span class="line">            list1.remove(1234)</span><br><span class="line">        del list1[0]</span><br><span class="line">        print(list1)</span><br><span class="line">        # 清空列表元素</span><br><span class="line">        list1.clear()</span><br><span class="line">        print(list1)</span><br><span class="line"></span><br><span class="line">        if __name__ == &apos;__main__&apos;</span><br><span class="line">            main()</span><br></pre></td></tr></table></figure>

<p>和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示：<br>def main():<br>    fruits = [‘grape’, ‘apple’, ‘strawberry’, ‘waxberry’]<br>    fruits += [‘pitaya’, ‘pear’, ‘mango’]<br>    # 循环遍历列表元素<br>    for fruit in fruits:<br>        print(fruit.title(), end=’ ‘)<br>    print()<br>    # 列表切片<br>    fruits2 = fruits[1:4]<br>    print(fruits2)<br>    # fruits3 = fruits # 没有复制列表只是创建了新的引用<br>    # 可以通过完整切片操作来复制列表<br>    fruits3 = fruits[:]<br>    print(fruits3)<br>    fruits4 = fruits[-3:-1]<br>    print(fruits4)<br>    # 可以通过反向切片操作来获得倒转后的列表的拷贝<br>    fruits5 = fruits[::-1]<br>    print(fruits5)</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p>
<p>下面的代码实现了对列表的排序操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    list1 = [&apos;orange&apos;, &apos;apple&apos;, &apos;zoo&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;]</span><br><span class="line">    list2 = sorted(list1)</span><br><span class="line">    # sorted函数返回列表排序后的拷贝不会修改传入的列表</span><br><span class="line">    # 函数的设计就应该像sorted函数一样尽可能不产生副作用</span><br><span class="line">    list3 = sorted(list1, reverse=True)</span><br><span class="line">    # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序</span><br><span class="line">    list4 = sorted(list1, key=len)</span><br><span class="line">    print(list1) # [&apos;orange&apos;, &apos;apple&apos;, &apos;zoo&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;]</span><br><span class="line">    print(list2) # [&apos;apple&apos;, &apos;blueberry&apos;, &apos;internationalization&apos;, &apos;orange&apos;, &apos;zoo&apos;]</span><br><span class="line">    print(list3) # [&apos;zoo&apos;, &apos;orange&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;, &apos;apple&apos;]</span><br><span class="line">    print(list4) # [&apos;zoo&apos;, &apos;apple&apos;, &apos;orange&apos;, &apos;blueberry&apos;, &apos;internationalization&apos;]</span><br><span class="line">    # 给列表对象发出排序消息直接在列表对象上进行排序</span><br><span class="line">    list1.sort(reverse=True)</span><br><span class="line">    print(list1) # [&apos;zoo&apos;, &apos;orange&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;, &apos;apple&apos;]</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__mian__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>还可以使用列表的生成式语法来创建列表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    f = [x for x in range(1, 10)] </span><br><span class="line">    print(f) # [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">    f = [x + y for x in &apos;ABCD&apos; for y in &apos;1234567&apos;]</span><br><span class="line">    print(f) </span><br><span class="line">    # [&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;A4&apos;, &apos;A5&apos;, &apos;A6&apos;, &apos;A7&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;B4&apos;, &apos;B5&apos;, &apos;B6&apos;, &apos;B7&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;, &apos;C4&apos;, &apos;C5&apos;, &apos;C6&apos;, &apos;C7&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;, &apos;D4&apos;, &apos;D5&apos;, &apos;D6&apos;, &apos;D7&apos;]</span><br><span class="line">    # 用列表的生成表达式语法创建列表容器</span><br><span class="line">    # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间</span><br><span class="line">    f = [x ** 2 for x in range(1, 1000)]</span><br><span class="line">    print(sys.getsizeof(f)) # 查看对象占用内存的字节数</span><br><span class="line">    # 9024</span><br><span class="line">    print(f)</span><br><span class="line">    # [1,4,9,16,25……,998001]</span><br><span class="line">    # 请注意下面的代码创建的不是一个列表而是一个生成器对象</span><br><span class="line">    # 通过生成器可以获取到数据但它不占用额外的空间存储数据</span><br><span class="line">    # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)</span><br><span class="line">    f = (x ** 2 for x in range(1, 1000))</span><br><span class="line">    print(sys.getsizeof(f)) # 相比生成式生成器不占存储数据的空间</span><br><span class="line">    # 120</span><br><span class="line">    print(f)</span><br><span class="line">    # 1</span><br><span class="line">    # 4</span><br><span class="line">    # ...</span><br><span class="line">    # 998001</span><br><span class="line">    for val in f:</span><br><span class="line">        print(val)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现衣蛾生成斐波那契数列的生成器。所谓的斐波那契数列可以通过下面的递归的方法来进行定义：<br>F0 = 0；<br>F1 = 1；<br>Fn = Fn-1 + Fn-2(n &gt;= 2)</p>
<h5 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h5><p>Python的元组与列表类似，不同之处在于元组的元素不能修改，在前面的d代码中我们已经不止一次使用过元组了，顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    # 定义元组</span><br><span class="line">    t = (&apos;张三&apos;, &apos;24&apos;, True, &apos;上海&apos;)</span><br><span class="line">    print(t)</span><br><span class="line">    # 获取元组中的元素</span><br><span class="line">    print(t[0])</span><br><span class="line">    print(t[3])</span><br><span class="line">    # 遍历元组中的值</span><br><span class="line">    for member in t:</span><br><span class="line">        print(member)</span><br><span class="line">    # 重新给元组赋值</span><br><span class="line">    # t[0] = &apos;王大锤&apos; # typeError</span><br><span class="line">    # 变量t重新引用了新的元组原来的元组将被辣鸡回收</span><br><span class="line">    t = (&apos;王大锤&apos;, 20, True, &apos;云南昆明&apos;)</span><br><span class="line">    print(t)</span><br><span class="line">    # 将元组转换成列表</span><br><span class="line">    person = list(t)</span><br><span class="line">    print(person)</span><br><span class="line">    # 列表是可以修改它的元素</span><br><span class="line">    person[0] = &apos;李四&apos;</span><br><span class="line">    person[1] = &apos;25&apos;</span><br><span class="line">    print(person)</span><br><span class="line"></span><br><span class="line">    # 将列表转换成元组</span><br><span class="line">    fruits_list = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;]</span><br><span class="line">    fruits_tuple = tuple(fruits_list)</span><br><span class="line">    print(fruits_tuple)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？<br>1、元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境中可能会更喜欢使用的是那些不变对象(一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护，另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销，一个不变对象可以方便的被共享访问)。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。<br>2、元组在创建时间和占用空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间</p>
<h5 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h5><p>Python中的集合跟数学上的集合是一致的，<strong>不允许有重复元素</strong>，而且可以进行交集、并集、差集等运算</p>
<p>##<br>Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以两个下划线作为开头，</p>
<p>Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对他们的访问，事实上你知道更换名字的规则仍然可以访问到他们，所以更多的时候它是一种暗示或隐喻</p>
<h1 id="面向对象的支柱"><a href="#面向对象的支柱" class="headerlink" title="面向对象的支柱"></a>面向对象的支柱</h1><p>面向对象有三大支柱：封装 继承 多态。<br>封装：隐藏一切可以隐藏的实现细节，只向外界暴露提供简单的变成接口。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的视图）。而不需要知道方法内部实现细节</p>
<p>@property装饰器<br>之前我们讨论过python中的属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将<br>属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter访问器，和setter修改器方法进行对应的操作。如果要做到这点，就可以考虑使用<br>@property包装getter和setter方法，使得对属性的访问即安全又方便。</p>
<p>class Person(object):<br>    def <strong>init</strong>(self, name, age):<br>        self._name = name<br>        self._age = age</p>
<pre><code># 访问器 - getter方法
@property
def name(self):
    return self._name

# 访问器 - getter方法
@property
def age(self):
    return self._age

# 修改器 - setter方法
@age.setter
def age(self, age):
    self._age = age

def play(self):
    if self._age &lt;= 16:
        print(&apos;%s正在玩飞行棋&apos; % self._name)
    else:
        print(&apos;%s正在斗地主&apos; % self._name)</code></pre><p>def main():<br>    person = Person(‘王法’, 12)<br>    person.play()<br>    person.age() = 22<br>    person.paly()<br>    # person.name = ‘sss’ Error: can’t set attribute</p>
<p>if <strong>name</strong> == ‘<strong>mian</strong>‘:<br>    main()</p>
<h5 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="slots 魔法"></a><strong>slots</strong> 魔法</h5><p>Python是一门动态语言，动态语言允许我们在程序运行时给对象绑定新的属性和方法，当然也可以对已经绑定的属性和方法进行解绑定，但是如果我们需要限定自定义类型<br>的对象只能绑定某些属性，可以通过类中定义<strong>slots</strong>变量来进行限定。需要注意的是<strong>slots</strong>的限定只对当前类的对象生效，对子类并不起任何作用。<br>class Person(object)<br>    # 限定Person对象只能绑定<em>name,<em>age和 _gender属性<br>    __slots</em></em> = (‘<em>name’, ‘<em>age’, ‘_gender’)<br><br>    def __init</em></em>(self, name, age):<br>        self._name = name<br>        self._age = age<br><br>    @property<br>    def name(self):<br>        return self._name<br><br>    @property<br>    def age(self):<br>        return self._age<br><br>    @age.setter<br>    def age(self, age):<br>        self._age = age<br><br>    def play(self):<br>        if self._age &lt;= 16:<br>            print(‘%s正在玩飞行棋’ % self._name)<br>        else:<br>            print(‘%s正在斗地主’ % self._name)</p>
<p>def main():<br>    person = Person(‘王大锤’, 22)<br>    person.play()<br>    person._gender = ‘男’</p>
<h5 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h5><p>之前我们在类中定音的方法都是对象方法，也就是说这些方法都是发送给对象的消息，实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义<br>一个三角形类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边未必能构造出三角形对象，因此我们可以先写一个方法<br>来验证三条边是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来， 因为不知道三条边能不能构成三角形，所以这个方法是属于三角形类而不属于三角形对象的。我们可以使用静态方法来解决这类问题。</p>
<p>和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象，类本身也是一个对象，有的地方也称之为类的元数据对象，通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象</p>
<h5 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h5><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系</p>
<ul>
<li>is-a关系也叫继承或泛化，比如学生和人的关系。手机和电子产品的关系都属于继承关系</li>
<li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系，关联关系如果是整体和部分的关联，那么我们称为聚合关系，如果整体进一步负责了部分的生命周期，整体和部分是不可分割的，同时同在也同时消亡，那么这种就是最强的关联关系，我们称之为合成关系</li>
<li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中的参数使用到了汽车，那么司机和汽车的关系就是依赖关系</li>
</ul>
<p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段<br>复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常生活中都会使用到的技术手段</p>
<p>继承和多态<br>可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写，提供继承信息的我们称之为父类，也叫超类或基类，得到继承信息的我们称为子类，也叫派生类或衍生类，子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称为里氏替换原则</p>
<p>‘’’<br>继承<br>‘’’</p>
<p>class Person(object):<br>    “”” 人 “””<br>    def <strong>init</strong>(self, name, age)；<br>        self._name = name<br>        self._age = age</p>
<pre><code>@property
def name(self):
    return self._name

@property
def age(self):
    return self._age

@age.setter
def age(self, age):
    self._age = age

def play(self):
    print(&apos;%s正在愉快的玩耍&apos; % self._name)

def watch_av(self):
    if self._age &gt;= 18:
        print(&apos;%s正在看枪战&apos; % self._name)
    else:
        print(&apos;%s只能观看熊出没&apos; % self._name)</code></pre><p>class Student(Person):<br>    “”””学生”””<br>    def <strong>init</strong>(self, name, age, grade):<br>        super().<strong>init</strong>(name, age)<br>        self._grade = grade</p>
<pre><code>@property
def grade(self):
    return self._grade

@grade.setter
def grade(self, grade):
    self._grade = grade

def study(self, course):
    print(&apos;%s的%s正在学习%s。&apos; %(self._grade, self._name, course))</code></pre><p>class Teacher(Person):<br>    “”””老师”””</p>
<pre><code>def __init__(self, name, age, title):
    super().__init__(name, age)
    self._title = title

@property
def title(self):
    return self._title

@title.setter
def title(self, title):
    self._title = title

def teach(self, course):
    print(&apos;%s%s正在讲%s&apos; % (self._name, self._title, course))</code></pre><p>def mian():<br>    stu = Student(‘王大锤’, 15, ‘初三’)<br>    stu.study(‘数学’)<br>    stu.watch_av()<br>    t = Teacher(‘李四’, 24, ‘教授’)<br>    t.teach(‘Python程序设计’)<br>    t.watch_av()</p>
<p>if name == ‘<strong>main</strong>‘:<br>    main()    </p>
<p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写override。通过方法重写我们可以让父类的同一个行为在不同的子类中有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态poly-morphism</p>
<p>from abc import ABCMeta, abstractmethod</p>
<p>class Pet(object, metaclass=ABCMeta):<br>    “””宠物”””<br>    def <strong>init</strong>(self, nickname):<br>        self._nickname = nickname</p>
<pre><code>@abstractmethod
def make_voice(self):
    &quot;&quot;&quot;&quot;发出声音&quot;&quot;&quot;
    pass</code></pre><p>calss Dog(Pet):<br>    “””狗”””</p>
<pre><code>def make_voice(self):
    print(&apos;%s: 汪汪汪……&apos; % self._nickname)</code></pre><p>class Cat(Pet):<br>    “””猫”””</p>
<pre><code>def make_voice(self):
    print(&apos;%s: 喵……喵&apos; % self._nickname)</code></pre><p>def main():<br>    pets = [Dog(‘旺福’), Cat(‘凯蒂’), Dog(‘大黄’)]<br>    for pet in pets:<br>        pet.make_voice()</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p>
<p>在上面的代码上，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它，Python从语法层面并没有像Java和C#那样<br>提供对抽象类的支持，但是我们通过abc模块额ABCMeta元类和abstractmethod包装器来达到抽象类的效果如果一个类中存在抽象方法那么这个类就不能被实例化（创建对象），上面的代码中<br>Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事）</p>
<p>图形用户界面的游戏开发<br>基于tkinter模块的GUI</p>
<p>GUI是图形用户界面的缩写，图形化的用户界面面对使用过计算机的人来说并不陌生，Python默认的GUI开发模块时tkinter（在Python 3以前的版本中名为Tkinter），提供了跨平台的GUI控件</p>
<p>基本上使用tkinter开发GUI应用需要以下5个步骤:<br>    1、导入tkinter模块中我们需要的东西<br>    2、创建一个顶层窗口对象并用它来承载整个GUI应用<br>    3、在顶层窗口对象上添加GUI组件<br>    4、通过代码将这些GUI组件的功能组织起来<br>    5、进入主事件循环 main loop</p>
<p>需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标，键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环<br>一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer开发者提供空间的大小和摆放位置、<br>Packer自动将控件填充到合适的位置和Grid基于网格坐标来摆放控件</p>
<p>使用Pygame进行游戏开发<br>Pygame是一个开源的Python模块，专门用于多媒体应用如电子游戏的开发，其中包含对图像、声音、视频、事件、碰撞等的支持，Pygame建立在SDL的基础上，SDL是一套跨平台的多媒体开发库，用C<br>语言实现，被广泛应用于游戏、模拟器、播放器等的开发，而Pygame让游戏开发者不在被底层语言束缚，可以更多的关注游戏的功能和逻辑。</p>
<p>体会如何使用面向对象程序设计，学会用这种编程思想去解决现实中的问题</p>
<p>在窗口中绘图</p>
<p>可以通过pygame中draw模块的函数在窗口上绘图，可以绘制的图形包括：线条 矩形 多边形 圆 椭圆 圆弧 等，需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点(0, 0)<br>,向右是x轴的正向，向下是y轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是像素。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将将图片放大若干倍<br>就可以看到这些点，pygame中表示颜色用的是色光三原色表示法，即通过一个元组或列表来指定颜色的RGB值，每个值都在0~255之间，因为是每个原色都用一个8位bit的值来表示<br>三种颜色相当于一共由24位构成，这也就是常说的24位颜色表示法</p>
<p>加载图像</p>
<p>如果需要直接加载图像到窗口上，可以使用pygame中image模块的函数来加载图像，再通过之前获得的窗口对象的blit方法渲染图像，代码如下所示：</p>
<p>实现动画效果</p>
<p>就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果，如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在<br>循环中修改小球的位置在刷新整个窗口即可</p>
<p>碰撞检测</p>
<p>通常一个游戏中会有很多对象出现，而这些对象之间的碰撞在所难免，比如炮弹击中了飞机，箱子撞击了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame<br>的sprite动画精灵，模块就提供了对碰撞检测的支持，这里我们暂不介绍sprite模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查<br>球心距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球</p>
<p>事件处理</p>
<p>可以在事件循环中对鼠标事件进行处理，通过事件对象的type属性可以判定事件类型，再通过pos属性就可以获得鼠标点击的位置，如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似</p>
<p>刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程知识后，用一个后台线程来处理这些是更好的选择，希望获得更好的用户体验，可以在游戏红加入背景音乐<br>以及在球与球碰撞时播放音效，利用pygame的mixer和music模块，我们可以很容易做到这一点，3D游戏，pygame就显得力不从心了，对3D游戏开发如果有兴趣的读者可以看看Panda3D</p>
<p>pygame官方网站：<a href="https://www.pygame.org/news" target="_blank" rel="noopener">https://www.pygame.org/news</a><br>Panda3D官方网站：<a href="https://www.panda3d.org/" target="_blank" rel="noopener">https://www.panda3d.org/</a></p>
<h6 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h6><p>实际开发中尝尝会遇到对数据进行持久化操作的场景，而实现数据持久化最直接简单的方式就是将数据保存在文件中。说到文件这个词，要先讨论下文件系统</p>
<p>在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名，操作模式，编码信息等来获得操作文件的对象，接下来就可以对文件进行<br>读写操作了，这里说的操作模式是指要打开什么的文件，字符文件还是二进制文件以及做什么样的操作，读、写还是追加，具体如下：</p>
<p>操作模式 | 具体含义<br>        | </p>
<p>‘r’| 读取(默认)<br>‘w’| 写入(会先截断之前的内容)<br>‘x’| 写入，如果文件已经存在会产生异常<br>‘a’| 追加， 将内容写入到已有文件的末尾<br>‘b’| 二进制模式<br>‘t’| 文本模式(默认)<br>‘+’| 更新(既可以读又可以写)</p>
<p>读写文本文件</p>
<pre><code>读取文本文件时，需要在使用open函数时指定好带路径的文件名，可以使用相对路径或绝对路径，并将文件模式设置为&apos;r&apos;，如果不指定默认也是&apos;r&apos;,然后通过encoding</code></pre><p>参数指定编码如果不指定，默认值是Node，那么在读取文件时使用的是操作系统默认的编码，如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的<br>那么可能因为无法解码字符而导致读取失败</p>
<p>如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况异常状况导致程序崩溃，为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生<br>状况的代码进行适当的处理</p>
<p>在Python中，我们可以将那些在运行时可能会出现的状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。<br>文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError,而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try<br>后面跟了三个except分别处理这三种不同的异常。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块代码不论程序正常还是异常都会执行<br>到甚至是调用了sys模块的exit函数退出python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常，因此我们通常把finally块称为总是执行代码块，它最适合用来<br>做释放外部资源的操作，如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境是自动释放文件资源。</p>
<p>除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用realines方法将文件按行读取到一个列表容器中</p>
<p>要将文本信息写入文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为’w’即可，注意如果需要对文本内容进行追加式写入，应该将模式设置为’a’。如果要写入的文件不存在<br>会自动创建文件而不是引发异常。</p>
<p>读写二进制文件<br>    知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能</p>
<p>读写JSON文件<br>    如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是JavaScript Object Notation的缩写，它本来是JavaScript语言中<br>创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的，目前JSON基本上已经<br>取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的参考JSON官方网站：<a href="http://json.org/，可参考每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个" target="_blank" rel="noopener">http://json.org/，可参考每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个</a><br>JSON的简单例子</p>
<p>{<br>    “name”: “骆昊”,<br>    “age”: 38,<br>    “qq”: 957658,<br>    “friends”: [“王大锤”, “白元芳”],<br>    “cars”: [<br>        {“brand”: “BYD”, “max_speed”: 180},<br>        {“brand”: “Audi”, “max_speed”: 280},<br>        {“brand”: “Benz”, “max_speed”: 320}<br>    ]<br>}</p>
<p>JSON和Python中的字典其实是一样的，JSON的数据类型和Python的数据类型是很容易找到对应关系。</p>
<p>JSON | Python<br>object | dict<br>array | list, tuple<br>string | str<br>number(int/real)  int/float<br>true/false | True/False<br>null | None</p>
<p>json模块主要有四个比较重要的函数：<br>dump - 将Python对象按照JSON格式序列化到文件中<br>dumps - 将Python对象处理成JSON格式的字符串<br>load - 将文件中的JSON数据反序列化成对象<br>loads -将字符串的内容反序列化成Python对象</p>
<p>这里出现了两个概念，一个叫序列化，一个叫反序列化，“序列化”serialization在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式<br>这样在需要的时候能够恢复到原本的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一<br>系列字节中提取数据结构的操作，就是反序列化（deserialization）</p>
<p>目前绝大多数网络数据服务，或者网络api都是基于HTTP协议提供JSON格式的数据，<br>HTTP协议入门：<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a><br>了解国内的网络数据服务： 聚合数据： <a href="https://www.juhe.cn/" target="_blank" rel="noopener">https://www.juhe.cn/</a>  阿凡达数据：<a href="https://www.avatardata.cn/" target="_blank" rel="noopener">https://www.avatardata.cn/</a>  <a href="http://apis.io/" target="_blank" rel="noopener">http://apis.io/</a></p>
<p>如何使用requests模块，封装的足够好的第三方网络访问模块，访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题<br>天行数据：<a href="https://www.tianapi.com/" target="_blank" rel="noopener">https://www.tianapi.com/</a> 提供国内新闻数据接口，其中的APIKey需要自己到网站申请</p>
<p>Python中的异常处理总结：<br><a href="https://segmentfault.com/a/1190000007736783" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007736783</a></p>
<p>在Python中要实现序列化和反序列化除了使用json模块，还可以使用pickle和shelve模块，但是这两个模块时使用特有的序列化协议来序列化数据，序列化后的数据只能被Python识别，关于这两个模块<br>可以自己看网络上的资料</p>
<h5 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h5><pre><code>正则表达式相关知识

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的复杂规则的字符串的需要，正则表达式就是用于描述规则的工具，换句话说正则表达式是一种工具
它定义了字符串的匹配模式，如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉。如果你在windows操作系统中
使用过文件查找并且在指定文件名时使用过通配符（*和？），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述
你的需求，当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是代价的，就如同学习一门编程语言一样，比如你可以编写正则表达式
，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号&apos;-&apos;，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这就是国内的座机号码，最初计算机是为了做
数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要
今天几乎所有编程语言都提供了对正则表达式操作的支持。Python通过标准库中的re模块来支持正则表达式操作

我们从某个地方可能是一个文本，也可能是网络是一则新闻，获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位数字，注意并不是随机的11位数字，因

正则入门：https://deerchao.cn/tutorials/regex/regex.htm

Python对正则表达式的支持
Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数

函数 | 说明
compile(pattern, flags=0) | 编译正则表达式返回正则表达式对象
match(pattern, string, flags=0) | 用正则表达式匹配字符串 成功返回匹配对象 否则返回None
search(pattern, string, flags = 0) | 搜索字符串中第一次出现正则表达式的模式，成功返回匹配对象 否则返回None
split(pattern, string, maxsplit = 0, flags= 0) | 用正则表达式指定的模式分隔符拆分字符串 返回列表
sub(pattern, repl, string, count=0, flags=0) | 用指定的字符串替换原字符串中与正则表达式匹配的模式，可以用count指定替换的次数
fullmatch(pattern, string, flags=0) | match函数的完全匹配从字符串开头到结尾版本
findall(pattern, string, flags=0) | 查找字符串所有与正则表达式匹配的模式 返回字符串的列表
finditer(pattern, string, flags=0) | 查找字符串所有与正则表达式匹配的模式 返回一个迭代器
purge() | 清除隐式编译的正则表达式的缓存
re.I /re.IGNORECASE | 忽略大小写匹配标记
re.M /re.MULTILINE | 多行匹配标记

说明：上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么通过compile
函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</code></pre><p>提示：上面在书写正则表达式时使用了原始字符串的写法，在字符串前面加上r，所谓原始字符串就是字符串中的每个字符就是它原始意义，说的更直接一点就是字符串中没有所谓的转义字符。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\，例如表示数字的\d要书写成\d，这样不仅写起来方便，阅读的时候也会很吃力</p>
<p>说明：re模块的正则表达式相关函数红都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写，是否进行多行匹配，是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M</p>
<p>如果要从事爬虫类应用的开发，那么正则表达式是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，在实际开发爬虫应用的时候，有很多人会选择BeautifulSoup和Lxml来进行匹配和信息的提取，前者简单方便但是性能差，后者既好用性能也好，但是安装稍显麻烦</p>
<h5 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h5><p>今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持多任务的操作系统，这使得我们可以同时运行多个程序，也可以将程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验，因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的并发编程，应该是程序员必备技能之一。</p>
<p>概念<br>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配空间，每个进程都有自己的地址空间，数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为他们合理的分配资源，进程可以通过fork或spaw的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制IPC Interprocess Communication来实现数据共享，具体的方式包括管道，信号。套接字、共享内存区等</p>
<p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，他们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易，当然在单核CPU系统下，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具如macOS中的活动监视器，Windows中的任务管理器里看。</p>
<p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的cpu执行时间，导致其他程序无法获得足够的CPU执行时间，另一方面站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对初学者更加的困难</p>
<p>Python既支持多进程又支持多线程，因此使用Pyhton实现并发编程主要有三种方式：多线程、多进程、多进程+多线程</p>
<p>Python中的多进程<br>Unix和Linux操作系统上提供了fork()系统来调用创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID，fork()函数非常特殊它会返回两次，父进程中可以通过<br>fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0,。Python的OS模块体统了fork()函数，由于windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process<br>类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池Pool，用于进程间通信的队列Queue的管道Pipe等</p>
<p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，<br>如何实现两个进程间通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个</p>
<p>当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知<br>要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共性的队列，底层是通过管道和信号量semaphore机制来实现的</p>
<p>可以直接使用Threading模块的Thread类来创建线程，但是我们之前讲过一个重要的概念继承，我们可以从已有的类创建新类，因此也通过成Thread类的方式来创建自定义的线程类<br>然后在创建线程对象并启动线程</p>
<p>因为多个进程可以共享进程内的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可，但是当多个线程共享同一个变量<br>(我们通常称之为资源)的时候，很有可能产生不可控的结果从而导致程序失控甚至崩溃。如果一个资源被多个线程竞争使用，我们通常称之为临界资源<br>对临界资源的访问需要加上保护，否则资源会处于“混乱”的状态，下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的<br>情况下我们很有可能会得到错误的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">因为多个进程可以共享进程内的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可，但是当多个线程共享同一个变量</span><br><span class="line">(我们通常称之为资源)的时候，很有可能产生不可控的结果从而导致程序失控甚至崩溃。如果一个资源被多个线程竞争使用，我们通常称之为临界资源</span><br><span class="line">对临界资源的访问需要加上保护，否则资源会处于“混乱”的状态，下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的</span><br><span class="line">情况下我们很有可能会得到错误的结果</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from time import sleep</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">class Account(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._balance = 0</span><br><span class="line"></span><br><span class="line">    def deposit(self, money):</span><br><span class="line">        # 计算存款后的余额</span><br><span class="line">        new_balance = self._balance + money</span><br><span class="line">        # 模拟受理存款业务需要0.01秒的时间</span><br><span class="line">        sleep(0.01)</span><br><span class="line">        # 修改账户余额</span><br><span class="line">        self._balance = new_balance</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def balance(self):</span><br><span class="line">        return self._balance</span><br><span class="line"></span><br><span class="line">class AddMoneyThread(Thread):</span><br><span class="line">    def __init__(self, account, money):</span><br><span class="line">        super().__init__() </span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    # 创建100个存款的线程向同一个账户中存钱</span><br><span class="line">    for _ in range(100):</span><br><span class="line">        t = AddMoneyThread(account, 1)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    # 等所有存款的线程都执行完毕</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(&apos;账户余额为：￥%d元&apos; % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果远远小于100，之所以出现这种情况是因为我们没有对银行账户这个临界资源加以保护，多个线程同时<br>向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果<br>。在这种情况下，锁就可以排上用场了，我们可以通过锁来保护临界资源，只有获得锁的线程才能访问临界资源，而其他没有得到锁的线程只能被阻塞起来，知道获得锁的线程释放了锁，<br>其他线程才有机会获得锁，进而访问被保护的临界资源，</p>
<p>下面的代码演示了如何使用锁，来保护对银行账户的操作，从而获得正确的结果</p>
<p>多进程还是多线程<br>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢，假设正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先<br>花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5个小时，这种方式称为单任务模型。如果你打算切换到所任务模型，可以先1分钟语文，在切换到数学作业，<br>做1分钟，在切换到英语，以此类推，只要切换速度快，这种方式就和单核CPU执行所任务是一样的。以旁观者来看，你就是正在同时写5科作业</p>
<p>但是切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的 语文书本，钢笔（这叫保存现场），然后打开数学课本，找出圆规直尺，这叫（准备新环境，），这才能开始做数学作业。<br>操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态， 内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等）<br>，才能开始执行，这个切换过程虽然很快，但是也需要耗费时间，如果有几千个任务同时进行，操作系统可能主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响<br>，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会是的系统性能急剧下降，最终导致所有任务都做不好</p>
<p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型，计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等<br>，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。。计算密集型任务由于要消耗CPU资源，这类任务用Python<br>这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前有提到Python中有嵌入C/C++代码的机制</p>
<p>除了计算密集型任务，其他的涉及到网络，存储介质I/O的任务，这类任务的特点是CPU消耗很少，任务的大部分时间都是在等待I/O操作完成，因为I/O的速度远远低于CPU和内存的速度，对于<br>I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率运转，有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用</p>
<h5 id="单线程和异步I-O"><a href="#单线程和异步I-O" class="headerlink" title="单线程和异步I/O"></a>单线程和异步I/O</h5><p>现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O.如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程来执行多任务，这种全新的模型称为事件驱动模型。Ngnix就是至此异步I/O<br>d的web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程，数量与CPU核心数相同，充分利用多核CPU，用Node.js开发的服务器端程序也使用了这种工作模式，<br>可获得极高的性能</p>
<p>应用案例，见Python的应用案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import tkinter</span><br><span class="line">import tkinter.messagebox</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    class DownloadTaskHandler(Thread):</span><br><span class="line"></span><br><span class="line">        def run(self):</span><br><span class="line">            time.sleep(10)</span><br><span class="line">            tkinter.messagebox.showinfo(&apos;提示&apos;, &apos;下载完成&apos;)</span><br><span class="line">            # 启用下载按钮</span><br><span class="line">            button1.config(state=tkinter.NORMAL)</span><br><span class="line"></span><br><span class="line">    def download():</span><br><span class="line">        # 禁用下载按钮</span><br><span class="line">        button1.config(state=tkinter.DISABLED)</span><br><span class="line">        # 通过daemon参数将线程设置为守护进程(主程序退出就不再保留执行)</span><br><span class="line">        # 在线程中处理耗时间的下载任务</span><br><span class="line">        DownloadTaskHandler(daemon=True).start()</span><br><span class="line"></span><br><span class="line">    def show_about():</span><br><span class="line">        tkinter.messagebox.showinfo(&apos;关于&apos;, &apos;作者：闸门&apos;)</span><br><span class="line">    </span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.title(&apos;单线程&apos;)</span><br><span class="line">    top.geometry(&apos;200x150&apos;)</span><br><span class="line">    top.wm_attributes(&apos;-topmost&apos;, 1)</span><br><span class="line"></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    button1 = tkinter.Button(panel, text=&apos;下载&apos;, command=download)</span><br><span class="line">    button1.pack(side=&apos;left&apos;)</span><br><span class="line">    button2= tkinter.Button(panel, text=&apos;关于&apos;, command=show_about)</span><br><span class="line">    button2.pack(side=&apos;right&apos;)</span><br><span class="line">    panel.pack(side=&apos;bottom&apos;)</span><br><span class="line"></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">使用多进程对复杂任务进行分而治之</span><br><span class="line">我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from time import time</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    total = 0</span><br><span class="line">    number_list = [x for x in range(1, 100000001)]</span><br><span class="line">    start = time()</span><br><span class="line">    for number in number_list:</span><br><span class="line">        total += number</span><br><span class="line">    print(total)</span><br><span class="line">    end = time()</span><br><span class="line">    print(&apos;Execution time:%.3fs&apos; % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/961/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/961/" itemprop="url">NINESIXONE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T17:51:53+08:00">
                2019-08-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-12-26T10:52:03+08:00">
                2019-12-26
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/15/961/" class="leancloud_visitors" data-flag-title="NINESIXONE">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  30.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  129
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一部分-数据结构与算法"><a href="#第一部分-数据结构与算法" class="headerlink" title="第一部分 数据结构与算法"></a>第一部分 数据结构与算法</h3><p>The ADT defines the logical form of the data type.The data structure implements  the physical form of the data type.</p>
<h4 id="一、栈-Stack-、队列-Queue-和向量-Vector"><a href="#一、栈-Stack-、队列-Queue-和向量-Vector" class="headerlink" title="一、栈(Stack)、队列(Queue)和向量(Vector)"></a>一、栈(Stack)、队列(Queue)和向量(Vector)</h4><blockquote>
<p>  内容：<br>        单链表，<br>        双向链表，<br>        环形链表，<br>        带哨兵节点的链表；<br>        栈的基本概念和性质，<br>        栈ADT及其顺序，<br>        链表实现；<br>        栈的应用；<br>        栈与递归；<br>        队列的基本概念和性质，<br>        队列ADT及其顺序、<br>        链表实现；<br>        队列的应用；<br>        向量基本概念和性质；<br>        向量ADT及其数组、链表实现；</p>
</blockquote>
<pre><code>顺序表的基本概念和实现
    线性表的存储结构有顺序存储和链式存储结构两种，前者被称为顺序表，后者被称为链表

顺序表
    顺序表就是把线性表中的所有的元素按照其逻辑顺序，依次存储到从指定的存储位置开始的一块连续的存储空间，这样的线性表的第一个元素的存储位置就是指定的存储位置，第i+1的存储位置紧跟着第i个元素的位置

链表
    在链表存储中，每个结点不仅包含所存元素的信息，还包含元素之间的逻辑关系的信息，如单链表中前驱结点包含后继结点的地址信息，这样就可以通过前驱结点的位置找到后继结点位置

    链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每个节点里存到到下一个结点的指针。由于不需要按顺序存储。链表在插入的时候可以达到O(1)的复杂度，比顺序表O(logn)快的多，但是查找一个节点或者访问特定关键字的节点则需要O(n)的时间，而顺序表的时间复杂度是O(1)。

    链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理，但是链表失去了数组随机读取的优点，同时链表由于增加了节点的指针域，空间开销比较大。

    链表又一连串的节点组成，每个节点包含任意的实例数据data fileds和一个或两个用来指向上一个或下一个节点的位置的链接指针links。链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表又很多不同的类型：单向链表，双向链表以及循环链表

单链表

两种存储结构的比较
    顺序表
        - 随机访问特性，位置是固定的
        - 要求占用连续的存储空间，存储分配只能预先进行，即静态分配
        - 插入操作要移动多个元素
    链表
        - 不支持随机访问
        - 结点用的存储精简利用率稍定
        - 支持存储空间的动态分配
        - 插入操作无需移动元素</code></pre><h5 id="单链表-Linked-Lists"><a href="#单链表-Linked-Lists" class="headerlink" title="单链表 Linked Lists"></a>单链表 Linked Lists</h5><h6 id="带头结点的单链表"><a href="#带头结点的单链表" class="headerlink" title="带头结点的单链表"></a>带头结点的单链表</h6><blockquote>
<p>  头指针head指向头结点，头指针值域不包含任何信息，从头结点的后继结点开始存储信息，头指针始终不为null，当head-&gt;next等于NULL的时候，链表为空</p>
</blockquote>
<h6 id="不带头结点的单链表"><a href="#不带头结点的单链表" class="headerlink" title="不带头结点的单链表"></a>不带头结点的单链表</h6><blockquote>
<p>  头指针head直接指向开始结点，当head为NULL的时候，链表为空</p>
</blockquote>
<pre><code>注意: 不论是带有头结点的链表还是不带头结点的链表，头指针都指向链表中的第一个结点，而头结点是带头结点的链表中的第一个结点，只作为链表存在的标志</code></pre><h5 id="双向链表-Doubly-Linked-List"><a href="#双向链表-Doubly-Linked-List" class="headerlink" title="双向链表 Doubly Linked List"></a>双向链表 Doubly Linked List</h5><p><img src="/images/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p>
<pre><code>双链表就是在单链表的结点上增添一个指针域，指向当前结点的前趋
同样 双链表也分带头结点和不带头结点的双链表</code></pre><h5 id="循环-环形-链表-Circular-Linked-List"><a href="#循环-环形-链表-Circular-Linked-List" class="headerlink" title="循环(环形)链表 Circular Linked List"></a>循环(环形)链表 Circular Linked List</h5><h6 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h6><blockquote>
<p>  将单链表的最后一个指针域指向链表中的第一个结点即可</p>
</blockquote>
<h6 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h6><p><img src="/images/%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8.png" alt="循环双链表"></p>
<blockquote>
<p>  循环双链表的构造源自双链表，即将终端结点的next指针指向链表中的第一个结点，将链表中第一个结点的prior指针指向终端结点   </p>
</blockquote>
<pre><code>带头结点的循环双链表当head-&gt;next和head-&gt;prior两个指针都等于head时链表为空
不带头结点的循环双链表当head等于null的时候为空</code></pre><h5 id="带哨兵结点的链表"><a href="#带哨兵结点的链表" class="headerlink" title="带哨兵结点的链表"></a>带哨兵结点的链表</h5><blockquote>
<p>  哨兵顾名思义就是有巡逻检查的功能，在我们的程序中通过增加哨兵结点往往能够简化边界，从而防止对特殊条件的判断，是代码更为简便优雅，在链表的中的应用最为典型</p>
</blockquote>
<h6 id="单链表中的哨兵结点"><a href="#单链表中的哨兵结点" class="headerlink" title="单链表中的哨兵结点"></a>单链表中的哨兵结点</h6><pre><code>首先讨论哨兵结点在单链表中的运用，如果不加哨兵结点在进行头尾删除和插入时需要进行特殊判断
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void addList(int x)&#123;</span><br><span class="line">    if(first == null)&#123;</span><br><span class="line">        first = new Node(x, null);</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    Node p = frist;</span><br><span class="line">    while(p.next != null)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = new Node(x, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

如上所示需要对结点为空的特殊情况进行判断，头部加了一个哨兵结点后就可以不需要判断了，不会为空</code></pre><p><img src="/images/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%93%A8%E5%85%B5%E7%BB%93%E7%82%B9.png" alt="单链表中的哨兵结点"></p>
<h6 id="双链表中的哨兵结点"><a href="#双链表中的哨兵结点" class="headerlink" title="双链表中的哨兵结点"></a>双链表中的哨兵结点</h6><p>####### Version 1: 双哨兵</p>
<pre><code>在双链表中需要能够在头部和尾部分别进行插入删除操作（可以实现双端队列），为了能快速在尾部进行插入删除，需要引入指向尾部的指针</code></pre><p><img src="/images/%E5%8F%8C%E5%93%A8%E5%85%B501.png" alt="双哨兵01"></p>
<pre><code>上述增加了一个指向尾部的last结点，从上图可以看出一个问题，last结点有时指向哨兵结点，有时指向实际结点。这会导致特殊情况的出现，比如在进行addFirst操作时，last指向哨兵结点时插入后需要将last往后移动一个，而第二张图指向实际结点时在头部插入结点后并不需要改变last指针。这时需要在尾部后也引入一个哨兵结点，以使其一致。相应示意图如下：</code></pre><p><img src="/images/%E5%8F%8C%E5%93%A8%E5%85%B502.png" alt="双哨兵02"></p>
<p>####### Version 2: 循环双链表</p>
<pre><code>上述Version1需要两个哨兵结点，可以对其进行改进。可以使用头部结点的prev指针指向尾部，尾部结点的next指针指向哨兵，这样就只需要一个哨兵结点，使链表变成循环链表，比Version1更为简洁优雅。</code></pre><p><img src="/images/%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%93%A8%E5%85%B5.png" alt="循环双链表哨兵"></p>
<pre><code>在对如上所示进行插入和删除操作时一定要格外注意，自己在写的时候很容易就漏掉某个指针的关系设置，最好在纸上自己画一遍。（对于要改变的连接可能会影响其他的，这时可将其暂存或最好设置）

在头部插入的代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void addFirst(Item item) &#123;</span><br><span class="line">    Node node = new Node(item);</span><br><span class="line">    node.prev = sentinel;</span><br><span class="line">    node.next = sentinel.next;</span><br><span class="line">    sentinel.next.prev = node;</span><br><span class="line">    sentinel.next = node;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

尾部插入代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void addLast(Item item) &#123;</span><br><span class="line">    Node node = new Node(item);</span><br><span class="line">    node.prev = sentinel.prev;</span><br><span class="line">    node.next = sentinel;</span><br><span class="line">    sentinel.prev.next = node;</span><br><span class="line">    sentinel.prev = node;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

头部删除代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Item removeFirst() &#123;</span><br><span class="line">    Item item = sentinel.next.item;</span><br><span class="line">    sentinel.next = sentinel.next.next;</span><br><span class="line">    sentinel.next.prev = sentinel;</span><br><span class="line">    size--;</span><br><span class="line">    return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

尾部删除代码如下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Item removeLast() &#123;</span><br><span class="line">    Item item = sentinel.prev.item;</span><br><span class="line">    Node sl = sentinel.prev.prev;</span><br><span class="line">    sl.next = sl.next.next;</span><br><span class="line">    sl.next.prev = sl;</span><br><span class="line">    size--;</span><br><span class="line">    return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="栈的基本概念和性质-栈ADT及其顺序、链表实现"><a href="#栈的基本概念和性质-栈ADT及其顺序、链表实现" class="headerlink" title="栈的基本概念和性质,栈ADT及其顺序、链表实现"></a>栈的基本概念和性质,栈ADT及其顺序、链表实现</h5><h6 id="栈的基本概念和性质"><a href="#栈的基本概念和性质" class="headerlink" title="栈的基本概念和性质"></a>栈的基本概念和性质</h6><blockquote>
<p>堆栈: 具有一定操作约束的线性表，只在一端(栈顶，top)做插入，删除<br>    插入数据：入栈（Push）<br>    删除数据：出栈（Pop）<br>    后入先出：Last In First Out（LIFO）</p>
</blockquote>
<h6 id="栈ADT"><a href="#栈ADT" class="headerlink" title="栈ADT"></a>栈ADT</h6><pre><code>类型名称：Stack 栈
数据对象集：一个有0个或多个元素的有穷线性表
操作集：长度为MaxSize的堆栈S∈Stack，堆栈元素item∈ElementType
1、Stack CreateStack(int MaxSize): 生成空堆栈，其最大长度为MaxSize
2、int IsFull(Stack S, ElementType item): 判断堆栈S是否已满
3、void Push(Stack S, ElementType item): 将元素item压入堆栈
4、int IsEmpty(Stack S): 判断堆栈S是否为空；
5、ElementType Pop(Stack S): 删除并返回栈顶元素</code></pre><h6 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h6><blockquote>
<p>  栈的顺序存储结构通常是由一个<strong>一维数组</strong>和一个记录<strong>栈顶</strong>元素位置的变量组成</p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">typedef int Position</span><br><span class="line">struct SNode &#123;</span><br><span class="line">    ElementType *Data; // 存储元素的数组</span><br><span class="line">    Position Top; // 栈顶指针</span><br><span class="line">    int MaxSize; // 堆栈的最大容量</span><br><span class="line">&#125;</span><br><span class="line">typedef struct SNode *Stack;</span><br><span class="line"></span><br><span class="line">// 生成空堆栈</span><br><span class="line">Stack CreateStack(int MaxSize) &#123;</span><br><span class="line">    Stack S = (Stack)malloc(sizeof(struct SNode));</span><br><span class="line">    S-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));</span><br><span class="line">    S-&gt;Top = -1;</span><br><span class="line">    S-&gt; MaxSize = MaxSize;</span><br><span class="line">    return S</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断堆栈S是否已满</span><br><span class="line">bool IsFull(Stack S)&#123;</span><br><span class="line">    return (S-&gt;Top == S-&gt;MaxSize - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 入栈</span><br><span class="line">bool Push(Stack S, ElmentType X)&#123;</span><br><span class="line">    if (IsFull(S))&#123;</span><br><span class="line">        printf(&apos;堆栈已满&apos;);</span><br><span class="line">        return False;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        S-&gt;Data[++(S-&gt;Top)] = X;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断堆栈为空</span><br><span class="line">bool IsEmpty(Stack S)&#123;</span><br><span class="line">    return (S-&gt;Top == -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">ElementType Pop(Stack S)&#123;</span><br><span class="line">    if(IsEmpty(S))&#123;</span><br><span class="line">        printf(&apos;堆栈空&apos;);</span><br><span class="line">        return ERROR; // ERROR是ElementType的特殊值，标志错误</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return S-&gt;Data((S-&gt;Top)--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

顺序栈的特殊状态和操作
1、栈空状态
    st.top==-1 有的书上规定st.top ==0为栈空条件
2、栈满状态
    st.top==maxSize-1 maxSize为栈中最大元素的个数，则maxSize-1 为栈满时栈顶元素在树组中的位置
3、非法状态（上溢和下溢）栈满继续进入栈就会出现上溢状态，栈空继续出栈就会出现下溢状态
4、进栈操作 ++(st.top); st.data[st.top]=x;
5、出栈操作 x=st.data[st.top]; --(st.top);</code></pre><h6 id="栈的链式存储实现"><a href="#栈的链式存储实现" class="headerlink" title="栈的链式存储实现"></a>栈的链式存储实现</h6><blockquote>
<p>栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行。栈顶指针Top应该在链表的哪一头？</p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">typedef struct  SNode *PtrToSNode;</span><br><span class="line">struct SNode &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToSNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToSNode Stack;</span><br><span class="line"></span><br><span class="line">// 1、堆栈初始化</span><br><span class="line">// 2、判断堆栈S是否为空</span><br><span class="line"></span><br><span class="line">Stack CreateStack()&#123;</span><br><span class="line">    // 构建一个堆栈的头结点，返回指针</span><br><span class="line">    Stack S;</span><br><span class="line">    S = (Stack) malloc(sizeof(struct SNode));</span><br><span class="line">    S-&gt;Next = NULL;</span><br><span class="line">    retrun S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(Stack S)&#123;</span><br><span class="line">    // 判断堆栈S是否为空，若为空函数则返回true，否则返回false</span><br><span class="line">    return (S-&gt;Next == NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Push(Stack S, ElemenType X)&#123;</span><br><span class="line">    // 将元素item压入堆栈S</span><br><span class="line">    PtrToSNode TmpCell;</span><br><span class="line">    &lt;!-- TmpCell = (struct SNode *)malloc(sizeof(struct SNode)); --&gt;</span><br><span class="line">    TmpCell = (PtrToSNode)malloc(sizeof(struct SNode));</span><br><span class="line">    TmpCell-&gt; Data = X;</span><br><span class="line">    TmpCell-&gt; Next = S-&gt;next;</span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType Pop(Stack S)&#123;</span><br><span class="line">    // 删除并返回堆栈S的栈顶元素</span><br><span class="line">    &lt;!-- struct SNode *FirstCell; --&gt;</span><br><span class="line">    PtrToSNode FirstCell;</span><br><span class="line">    ElmentType TopElem;</span><br><span class="line">    if(IsEmpty(S))&#123;</span><br><span class="line">        printf(&apos;堆栈空&apos;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        TopElem = FirstCell-&gt;Element;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">        free(FirstCell);</span><br><span class="line">        return TopElem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

链栈的特殊状态和操作
1、栈空状态 lst-&gt;next==NULL
2、栈满状态 不存在栈满的情况
3、元素进栈操作 p-&gt;next=lst-&gt;next; lst-&gt;next=p
4、p=lst-&gt;next; x=p-&gt;data; lst-&gt;next=p-&gt;next; free(p)</code></pre><h5 id="栈的应用；Stack-Application"><a href="#栈的应用；Stack-Application" class="headerlink" title="栈的应用；Stack Application"></a>栈的应用；Stack Application</h5><pre><code>【表达式求值】</code></pre><h5 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h5><h5 id="队列的基本概念和性质-队列ADT及其顺序、链表实现"><a href="#队列的基本概念和性质-队列ADT及其顺序、链表实现" class="headerlink" title="队列的基本概念和性质,队列ADT及其顺序、链表实现"></a>队列的基本概念和性质,队列ADT及其顺序、链表实现</h5><h6 id="队列的基本概念和性质"><a href="#队列的基本概念和性质" class="headerlink" title="队列的基本概念和性质"></a>队列的基本概念和性质</h6><blockquote>
<p>队列Queue: 具有一定操作约束的线性表<br>    插入和删除操作：只能在一端插入，而在另一端删除</p>
</blockquote>
<pre><code>数据插入：入队列(AddQ)
数据删除：出队列(DeleteQ)
先来先服务
先进先出： FIFO


先入先出的数据结构
在FIFO数据结构中，将首先处理添加队列中的第一个元素。</code></pre><p><img src="/images/%E9%98%9F%E5%88%97.png" alt="队列"><br>    如上图所示，队列是典型的FIFO数据结。插入insert操作也称作入队enqueue，新元素始终被添加在队列的末尾。删除delete操作也被称作dequeue。只能移除第一个元素</p>
<p>[示例] —— 队列<br>1、入队：Enqueue<br><img src="/images/%E5%85%A5%E9%98%9F%E5%89%8D.png" alt="入队前"> =&gt; <img src="/images/%E5%85%A5%E9%98%9F%E5%90%8E.png" alt="入队后">     </p>
<p>2、出队：Dequeue<br><img src="/images/%E5%87%BA%E9%98%9F%E5%89%8D.png" alt="出队前"> =&gt; <img src="/images/%E5%87%BA%E9%98%9F%E5%90%8E.png" alt="出队后">     </p>
<h6 id="队列ADT"><a href="#队列ADT" class="headerlink" title="队列ADT"></a>队列ADT</h6><blockquote>
</blockquote>
<pre><code>类型名称： 队列(Queue)
数据对象集：一个有0个或多个元素的有穷线性表
操作集：长度为MaxSize的队列Q∈Queue,队列元素item ∈ EelmentType
1、Queue CreateQueue(int MaxSize)：生成长度为MaxSize的空队列
2、int IsFull(Queue Q, int MaxSize): 判断队列Q是否已满
3、void AddQ(Queuq Q, ElementType item): 将数据元素item插入队列Q中
4、int IsEmptyQ(Queue Q): 判断队列Q是否为空
5、ElementType DeleteQ(Queue Q): 将对头数据元素从队列中删除并返回</code></pre><h6 id="队列顺序、链表实现"><a href="#队列顺序、链表实现" class="headerlink" title="队列顺序、链表实现"></a>队列顺序、链表实现</h6><blockquote>
<p>  队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素的变量rear组成<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">typedef int Position</span><br><span class="line">struct QNode &#123;</span><br><span class="line">    ElementType *Data; // 存储元素的数组</span><br><span class="line">    Position Front,Rear; // 队列的头，尾指针</span><br><span class="line">    int MaxSize;</span><br><span class="line">&#125;</span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line"></span><br><span class="line">Queue CreateQueue(int MaxSize)&#123;</span><br><span class="line">    Queue Q = (Queue) malloc (sizeof(struct QNode));</span><br><span class="line">    Q-&gt;Data = (ElementType *) malloc (MaxSize * sizeof(ElementType));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = 0;</span><br><span class="line">    Q-&gt;MaxSize = MaxSize;</span><br><span class="line">    return Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsFull(Queue Q)&#123;</span><br><span class="line">    return ((Q-&gt;Rear+1)%Q-&gt;MaxSize == Q-&gt;Front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool AddQ(Queue Q, ElementType X)&#123;</span><br><span class="line">    if(IsFull()) &#123;</span><br><span class="line">        printf(&quot;队列满&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Q-&gt;Rear = (Q-&gt;Rear + 1)%Q -&gt; MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = X;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(Queue Q)&#123;</span><br><span class="line">    return (Q-&gt;Front == Q-&gt;Rear);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType DeleteQ(Queue Q)&#123;</span><br><span class="line">    if(IsEmpty(Q))&#123;</span><br><span class="line">        printf(&apos;队列空&apos;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tmp = Q-&gt;Data(Q-&gt;Front)</span><br><span class="line">        Q-&gt;Front = (Q-&gt;Front +1 )%Q-&gt;MaxSiz;</span><br><span class="line">        &lt;!-- return Q-&gt;Data(Q-&gt;Front) // 这里不对 --&gt;</span><br><span class="line">        return tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>循环队列的特殊状态和操作
1、队空状态 qu.rear=qu.front
2、队满状态 （qu.rear+1）%maxSize == qr.front
3、元素x进队操作（移动队尾指针）
4、qu.rear =(qu.rear+1) %maxSize;qu.date[qu.rear]=x;
5、元素x出队操作（移动队首指针）
6、qu.front =(qu.front+1)%maxSize;x=qu.data[qu.front];</code></pre><blockquote>
<p>  队列的链式存储结构也可以用一个单链表实现，插入和删除操作分别再链表的两头进行。队列指针front和rear应该分别指向链表的哪一头？<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    // 队列中的结点</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode Position;</span><br><span class="line"></span><br><span class="line">struct QNode &#123;</span><br><span class="line">    Position Front, Rear;// 队列的头，尾指针</span><br><span class="line">    int MaxSize; // 队列最大容量</span><br><span class="line">&#125;</span><br><span class="line">typedef struct QNode *Queue;</span><br><span class="line"></span><br><span class="line">bool IsEmpty(Queue Q)&#123;</span><br><span class="line">    return (Q-&gt;Front == NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType DeleteQ(Queue Q)&#123;</span><br><span class="line">    Position FrontCell;</span><br><span class="line">    ElementType FrontElem;</span><br><span class="line"></span><br><span class="line">    if(IsEmpty(Q))&#123;</span><br><span class="line">        printf(&quot;队列为空&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        FrontCell = Q-&gt;Front;</span><br><span class="line">        if(Q-&gt;Front == Q-&gt;Rear) // 若队列只有一个元素</span><br><span class="line">            Q-&gt;Front = Q-&gt;Rear = NULL; // 删除后队列置为空</span><br><span class="line">        else</span><br><span class="line">            Q-&gt;Front = Q-&gt;Front-&gt;Next;</span><br><span class="line">        FrontElem = FrontCell-&gt;Data;</span><br><span class="line">        free(FrontCell); // 释放被删除结点的空间</span><br><span class="line">        return FrontElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>链队的特殊状态和操作
1、队空状态 lqu-&gt;rear=NULL 或者 lqu-&gt;front=NULL
2、队满状态 不存在队满状态 （假设内存无限大的情况下）
3、元素进队操作 lqu-&gt;rear-&gt;next-&gt;p;lqu-&gt;rear=p;
4、元素出队操作 p=lqu-&gt;front;lqu-&gt;front=p-&gt;next;x=p-&gt;data;free(p)</code></pre><h6 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h6><h5 id="向量的基本概念和性质-向量ADT及其数组、链表实现"><a href="#向量的基本概念和性质-向量ADT及其数组、链表实现" class="headerlink" title="向量的基本概念和性质,向量ADT及其数组、链表实现"></a>向量的基本概念和性质,向量ADT及其数组、链表实现</h5><h6 id="向量的基本概念和性质"><a href="#向量的基本概念和性质" class="headerlink" title="向量的基本概念和性质"></a>向量的基本概念和性质</h6><blockquote>
<pre><code>向量Vector是一个封装了动态大小数组的顺序容器(Sequence Container).跟任意其他类型容器一样，他能够存放各种类型的对象，可以简单的认为，向量是一个能够存放任意类型的动态数组。</code></pre></blockquote>
<pre><code>顺序序列
    顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。
动态数组
    支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。
能够感知内存分配器的（Allocator-aware）
    容器使用一个内存分配器对象来动态地处理它的存储需求。

vector的扩充机制：按照容器现在容量的一倍进行增长。vector容器分配的是一块连续的内存空间，每次容器的增长，并不是在原有连续的内存空间后再进行简单的叠加，而是重新申请一块更大的新内存，并把现有容器中的元素逐个复制过去，然后销毁旧的内存。这时原有指向旧内存空间的迭代器已经失效，所以当操作容器时，迭代器要及时更新。</code></pre><h6 id="向量ADT"><a href="#向量ADT" class="headerlink" title="向量ADT"></a>向量ADT</h6><h6 id="向量数组、链表实现"><a href="#向量数组、链表实现" class="headerlink" title="向量数组、链表实现"></a>向量数组、链表实现</h6><h4 id="二、树"><a href="#二、树" class="headerlink" title="二、树"></a>二、树</h4><blockquote>
<p>内容： 树的基本概念和术语；树的前序，中序，后序，层次序遍历；二叉树及其性质；普通树与二叉树的转换；树的存储结构，标准形式；完全树(complete tree)的数组形式存储；树的应用，Huffman树的定义与应用。</p>
</blockquote>
<h5 id="树的基本概念和术语"><a href="#树的基本概念和术语" class="headerlink" title="树的基本概念和术语"></a>树的基本概念和术语</h5><blockquote>
<p>树(Tree): n(n&gt;=0)个结点构成的有限集合。n=0时，称为空树，对于任一颗非空树(n&gt;0),它具备以下性质：</p>
</blockquote>
<pre><code>树中有一个称为“根Root”的特殊结点，用r表示
其余结点可分为m(m&gt;0)个互不相交的有限集T1，T2...Tm, 其中每个集合本身又是一颗树，称为原来的子树

子树是不相交的
除了根结点外，每个结点有且仅有一个父结点
一颗N个结点的树有N-1条边

**树的一些基本术语**
1、结点的度Degree：结点的子树个数
2、树的度：树的所有结点中最大的度数
3、叶结点Leaf：度为0的结点
4、父结点Parent：有子树的结点是其子树根结点的父结点
5、子结点（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点，子结点也称孩子结点
6、兄弟节点Sibling：具有同一父结点的各节点彼此是兄弟节点
7、路径与路径长度：从结点n1到nk的路径为一个结点序列n1，n2……nk，ni是ni+1的父结点，路径所包含边的个数为路径的长度
8、祖先结点Ancestor：沿树根到某一结点路径上所有结点都是这个结点的祖先结点
9、子孙结点Descendant：某一结点的子树中的所有结点是这个节点的子孙
10、结点的层次Level：规定跟结点在1层，其他任一结点的层数是其父结点的层数加1
11、树的深度Depth：树中所有结点中的最大层次是这棵树的深度</code></pre><h5 id="树的前序、中序、后序、层次遍历"><a href="#树的前序、中序、后序、层次遍历" class="headerlink" title="树的前序、中序、后序、层次遍历"></a>树的前序、中序、后序、层次遍历</h5><pre><code>(1) 先序遍历
    遍历过程为：
        1、访问根结点
        2、先序遍历左子树
        3、先序遍历右子树</code></pre><p><img src="/images/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="先序遍历"><br>        A(BDFE)(CGHI)<br>        先序遍历=&gt; A B D F E C G H I</p>
<pre><code>    void PreOrderTraversal(BinTree BT){
        if(BT){
            printf(&apos;%d&apos;, BT-&gt;Data);
            PreOrderTraversal(BT-&gt;Left);
            PreOrderTraversal(BT-&gt;Right);
        }
    }

    第一次碰到的时候弹出:
    void PreOrderTraversal(BinTree BT){
        BinTree T BT;
        Stack S = CreatStack(MaxSize) ;// 创建并初始化堆栈S
        while( T || !IsEmpty(S)){
            while(t){ // 一直向左并将沿途结点压入堆栈
                Push(S, T);
                T = Pop(S); // 结点弹出堆栈
                printf(&quot;%5d&quot;, T-&gt;Data);
                T = T-&gt;Left;

                if(!IsEmpty(S)){
                    T = T-&gt;Right; // 转向右子树
                }

            }
        }
    }


(2) 中序遍历
    遍历过程为：
        1、中序遍历其左子树;
        2、访问根结点
        3、中序遍历其右子树</code></pre><p><img src="/images/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="中序遍历"><br>        (DBEF) A (GHCI)<br>        中序遍历=&gt; DBEFAGHCI</p>
<pre><code>    void InOrderTraversal(BinTree BT){
        if(BT){
            InOrderTraversal(BT-&gt;Left);
            printf(&apos;%d&apos;, BT-&gt;Data);
            InOrderTraversal(BT-&gt;Right);
        }
    }

    中序遍历非递归遍历算法：
        非递归算法实现的基本思路：使用堆栈
        - 遇到一个结点，就把它压栈，并去遍历它的左子树；
        - 当左子树遍历结束后，从栈顶弹出这个结点并访问它
        - 然后按其右指针再去中序遍历该结点的右子树
    第二次碰到的时候弹出

    void InOrderTraversal(BinTree BT) {
        BinTree T = BT;
        Stack S = CreatStack(MaxSize); // 创建并初始化堆栈S
        while( T || !IsEmpty(S)) { // 树不空或者堆栈不空
            while(T) {
                Push(S, T);
                T = T -&gt; Left;
            }
            if(!IsEmpty(S)){
                T = Pop(S); // 结点弹出堆栈
                printf(&quot;%5d&quot;, T-&gt;Data); // 访问打印结点
                T = T-&gt;Right; // 转向右子树
            }
        }
    }


(3) 后序遍历
    遍历过程为：
        1、后序遍历左子树
        2、后序遍历右子树
        3、访问根结点</code></pre><p><img src="/images/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="后序遍历"><br>        (DEFB)(HGIC)A<br>        后序遍历=&gt; D E F B H G I C A<br>        void PostOrderTraversal(BinTree BT){<br>            if(BT){<br>                PostOrderTraversal(BT-&gt;Left);<br>                PostOrderTraversal(BT-&gt;Right);<br>                printf(“%d”, BT-&gt;Data);<br>            }<br>        }</p>
<pre><code>(4) 层序遍历
    二叉树遍历的核心问题：二维结构的线性化
        - 从结点访问其左右儿子结点
        - 访问左儿子后，右儿子结点怎么办？
            需要一个存储结构保存暂不访问的结点
            存储结构：堆栈、队列
    队列实现： 遍历从根结点开始，首先将根结点入队，然后开始执行循环，结点出队，访问该结点，其左右儿子入队。</code></pre><p><img src="/images/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="层序遍历"></p>
<pre><code> A B C D F G I E H
 层序遍历： A B C D F G I E H

层序基本过程： 先跟结点入队，然后：
1、从队列中取出一个元素；
2、访问该元素所指结点
3、若该元素所指结点的左右孩子结点非空，则将其左右孩子的指针顺粗入队

void LevelOrderTraversal(BinTree BT){
    Queue Q;
    BinTree T;
    if(!BT) return; // 若是空树返回
    Q = CreateQueue(MaxSize); // 创建并初始化队列Q
    AddQ(Q, BT);
    while(!IsEmptyQ(Q)){
        T = DeleteQ(Q);
        printf(&apos;%d\n&apos;, T-&gt;Data); // 访问取出队列的结点
        if(T-&gt;left) AddQ(Q, T-&gt;Left);
        if(T-&gt;right) AddQ(Q, T -&gt; Right);
    }
}</code></pre><h5 id="二叉树及其性质"><a href="#二叉树及其性质" class="headerlink" title="二叉树及其性质"></a>二叉树及其性质</h5><blockquote>
<p>二叉树的定义;<br>    二叉树T：一个有穷的结点集合<br>            这个集合可以为空<br>            若不为空，则它是由根结点和称为其左子树Tl和右子树Tr的两个不想交的二叉树组成</p>
</blockquote>
<pre><code>二叉树具体五种基本形态：

 空      O           O           O             O
                 Tl                 Tr     Tl     Tr

(a)     (b)         (c)          (d)           (e)


二叉树的子树有左右顺序之分
   A                    A
B                          B
(左子树)                (右子树)


特殊二叉树：
    * 斜二叉树 Skewed Binary Tree
    A
       B
          C 
             D
完美二叉树 Perfact Binary Tree 满二叉树 Full Binary Tree
                    A
            B                     C
        D     E              F        G
    H   I J   K          L   M    N    O

完全二叉树 Complete Binary Tree
    有n个结点的二叉树，对树中结点按从上到下，从左到右顺序进行编号，编号为i(1&lt;=i&lt;=n)结点与满二叉树中编号为i结点在二叉树中位置相同。

二叉树几个重要性质：
1、一个二叉树第i层的最大结点数为2^i-1, i&gt;=1
2、深度为k的二叉树有最大结点总数为：2^k - 1, k&gt;= 1
3、对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶子结点个数，那么满足关系n0 = n2 + 1
     A
  B     C
D   E  F
  J  K   H   

  n0 ：D J K H 4
  N1：C F 2
  N2：A B E 3

  No=N2 + 1 叶子结点个数为度为2的非叶子结点个数+1</code></pre><h5 id="普通树与二叉树的转换"><a href="#普通树与二叉树的转换" class="headerlink" title="普通树与二叉树的转换"></a>普通树与二叉树的转换</h5><pre><code>树转换为二叉树：
  1、加线：在兄弟之间加一条线
  2、抹线：对每个结点，除了其左孩子外，抹掉其与其余孩子之间的连线
  3、旋转：将树作适当的旋转即可

二叉树转换成树：
  1、逆旋转：把二叉树从左上到右下分为若干层，然后调整为水平方向
  2、加线：找到每一层结点在其上层的父结点，将每层的结点和其父结点相连
  3、抹线：删掉每一层结点之间的连接</code></pre><h5 id="树的存储结构，标准形式"><a href="#树的存储结构，标准形式" class="headerlink" title="树的存储结构，标准形式"></a>树的存储结构，标准形式</h5><blockquote>
<p>二叉树的存储结构<br>    1、顺序存储结构<br>    完全二叉树：按从上到下，从左到右顺序存储n个结点的完全二叉树的结点父子关系<br>                    A<br>         B                   O<br>      C    S              M     Q<br>    W   K</p>
</blockquote>
<pre><code>非根结点(序号i&gt;1)的父结点的序号是i/2
结点(序号为i)的左孩子结点的序号是2i，若2i&lt;= n，否则没有左孩子
结点(序号为i)的右孩子结点的序号是2i+1，若2i+1在&lt;= n,否则没有右孩子

结点   A    B   O   C   S    M    Q    W    K
序号   1    2   3   4   5    6    7    8    9

一般二叉树也可以采用这种结构，但会造成空间浪费


2、链表存储
typedef struct TreeNode *BinTree;
typedef BinTree Position; // 二叉树类型
struct TreeNode {
    ElementType data;
    BinTree Left;s
    BinTree Right;
}

Left Data Right

![二叉树链表存储](/images/二叉树链表存储.png)</code></pre><h5 id="完全树（complete-tree）的数组形式存储"><a href="#完全树（complete-tree）的数组形式存储" class="headerlink" title="完全树（complete tree）的数组形式存储"></a>完全树（complete tree）的数组形式存储</h5><pre><code>完全二叉树：按从上到下，从左到右顺序存储n个结点的完全二叉树的结点父子关系
                A
    B                   O
C    S              M     Q
W   K

非根结点(序号i&gt;1)的父结点的序号是i/2
结点(序号为i)的左孩子结点的序号是2i，若2i&lt;= n，否则没有左孩子
结点(序号为i)的右孩子结点的序号是2i+1，若2i+1在&lt;= n,否则没有右孩子

结点   A    B   O   C   S    M    Q    W    K
序号   1    2   3   4   5    6    7    8    9

一般二叉树也可以采用这种结构，但会造成空间浪费</code></pre><h5 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h5><blockquote>
<pre><code>一、遍历二叉树的应用：输出二叉树中的叶子结点
在二叉树的遍历算法中增加检测结点的&quot;左右子树是否都为空&quot;
void PreOrderPrintLeaves(BinTree BT){
    if(BT){
        if(!BT-&gt;Left &amp;&amp; !BT-&gt;Right)
            printf(&quot;%d&quot;, BT-&gt;Data);
        PreOrderPrintLeaves(BT-&gt;Left);
        PreOrderPrintLeaves(BT-&gt;Right);
    }
}</code></pre></blockquote>
<pre><code>二、求二叉树的高度]
            O

左子树(Hl)      右子树(HR)
Height = max(HL, HR) + 1;

// 这个算法好像是有问题 如果是伪码的话好像也差点意思
int PostOrderGetHeight(BinTree BT){
    int HL, HR, MaxH;
    if(BT) {
        HL = PostOrderGetHeight(BT-&gt;Left); // 求左子树的深度
        HR = PostOrderGetHeight(BT-&gt;Right); // 求右子树的深度
        MaxH = （HL &gt; HR) ? HL : HR; // 取左右子树较大的深度
        return (MaxH + 1); // 返回树的深度
    }
    else return 0; // 空树深度为0
}

三、二元运算表达式及其遍历
                 +

            +                         *
      a          *                  +        g
               b    c            *    f
                             d      e



    三种遍历可以得到三种不同的访问结果：
    先序遍历得到前缀表达式： + + a * b c * + * d e f g
    中序遍历得到中缀表达式：a + b * c + d * e + f * g
    后序遍历得到后缀表达式：a b c * + d e * f + g * +

四、由两种遍历序列确定二叉树
    问：已知三种遍历中的任意两种遍历序列能否唯一确定一颗二叉树呢？
    答案：必须要有中序遍历

    先序和中序遍历序列来确定一颗二叉树
    分析：
    - 根据先序遍历序列第一个结点确定根结点
    - 根据根结点在中序遍历序列中分割出左右两个子序列
    - 对左子树和右子树分别递归使用相同的方法继续分解

    先序序列：根结点 左子树 右子树
    中序序列：左子树 根结点 右子树

    类似的，后序和中序遍历序列也可以确定一颗二叉树</code></pre><h5 id="Huffman树的定义与应用"><a href="#Huffman树的定义与应用" class="headerlink" title="Huffman树的定义与应用"></a>Huffman树的定义与应用</h5><h6 id="Huffman树的定义"><a href="#Huffman树的定义" class="headerlink" title="Huffman树的定义"></a>Huffman树的定义</h6><blockquote>
<p><strong>带权路径长度</strong>WPL：设二叉树有n个叶子结点，每个叶子结点带有权值Wk。从根结点到每个叶子结点的长度为Lk，则每个叶子结点的带权路径长度之和就是：WPL = ∑(n, k=1)WkLk<br>  最优二叉树或哈夫曼树：<strong>WPL最小的二叉树</strong></p>
</blockquote>
<p>  判定树 查找效率 找出最优二叉树 最优判别树 提高查找效率<br>  比率*比较次数</p>
<p>  <strong>根据结点不同的查找效率构造更有效的搜索树–这就是哈夫曼树要解决的问题</strong></p>
<p>  哈夫曼树的构造<br>    1、每次把权值最小的两颗二叉树合并<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int Weight;</span><br><span class="line">    HuffmanTree Left, Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuffmanTree Huffman(MinHeap H)&#123;</span><br><span class="line">    // 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里</span><br><span class="line">    int i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H); // 将H-&gt;Elements[]按权值调整为最小堆</span><br><span class="line">    for(i=1; i&lt;H-&gt;Size; i++) &#123;</span><br><span class="line">        // 做H-&gt;Size -1次合并</span><br><span class="line">        T = malloc(sizeof(struct TreeNode)); // 建立新结点</span><br><span class="line">        T-&gt;Left = DeleteMin(H); // 从最小堆中删除一个结点，作为新T的左结点</span><br><span class="line">        T-&gt;Right = DeleteMin(H); // 从最小堆中删除一个结点，作为新T的右结点</span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight;</span><br><span class="line">        Insert(H, T); // 将T插入到最小堆</span><br><span class="line">    &#125;</span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>整体时间复杂度为O(NlogN)
如何选取两个最小的？ 利用堆！排序方法效率不如堆！


哈夫曼树的特点：
1、没有度为1的结点
2、n个叶子结点的哈夫曼树共有2n-1个结点
3、哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树

    n0：叶结点总数
    n1：只有一个儿子的结点总数
    n2：有2个儿子的结点总数

    n2 = n0 -1
？对同一组权值{w1, w2, …… wn},是否存在不同构的两颗哈夫曼树呢？
对一组权值，不同构的两棵哈夫曼树WPL相同</code></pre><h6 id="Huffman哈夫曼应用"><a href="#Huffman哈夫曼应用" class="headerlink" title="Huffman哈夫曼应用"></a>Huffman哈夫曼应用</h6><pre><code>哈夫曼编码：
给定一段字符串，如何对字符进行编码，可以使得该字符串的编码存储空间最小？
[例]假设有一段文本，包含58个字符，并由一下7个字符构成：a，e，i，s，t，空格（sp），换行（nl）；这7个字符出现的次数不同。如何对这7个字符进行编码，使得总编码空间最少？
【分析】：
(1) 用等长ASCII编码：58*8 = 464位
(2) 用等长3位编码：58*3 = 174位
(3) 不等长编码：出现频率高的字符用的编码短些，出现频率低的字符则编码可以长些
怎么进行不等长编码?
如何避免二义性?
前缀码prefix code：任何字符的编码都不是另一个字符编码的前缀
    - 可以无二义地解码
二叉树用于编码：
    用二叉树进行编码：
    1、左右分支：0、1
    2、字符只在叶结点上

四个字符的频率：a：4， u：1， x：2， z: 1

       0|1
    0|1     0|1
 |a   u| |x   z|

a: 00
u: 01
x: 10
z: 11
当所有字符在叶结点上时，不会出现一个字符的编码是另一个字符的前缀码

Cost(aaaxuaxz-&gt;0000001001001011) = 2*4 + 2*1 + 2*2 + 2*1 = 16

然后哈夫曼树构造一颗编码代价最小的二叉树
    0|1
a|     0|1
     x|  0|1
       u|   z|
a: 0
u: 110
x: 10
z: 111
Cost(aaaxuaxz-&gt;00010110010111) = 1*4 + 3*1 + 2*2 + 3*1 = 14

怎么构造一颗编码代价最小的二叉树？
哈夫曼编码：
Ci a  e  i  s  t  sp  nl
fi 10 15 12 3  4  13  1

构造哈夫曼树：
               0|58|1
        0|25|1            0|33|1
    12i      sp13      e15       0|18|1
                             0|8|1      0|10a|1
                           4t   0|4|1
                              1nl   3s
然后哈夫曼编码就出来了
a：111
e: 10
i: 00
s: 11011
t: 1100
sp: 01
nl: 11010</code></pre><h4 id="三、查找-search"><a href="#三、查找-search" class="headerlink" title="三、查找(search)"></a>三、查找(search)</h4><blockquote>
<p>内容：<br>    查找的基本概念；<br>    对线性关系结构的查找；<br>    顺序查找；<br>    二分查找；<br>    Hash查找法；<br>    常见的Hash函数（直接定址法，随机数法）<br>    hash冲突的概念<br>    解决冲突的方法(开散列方法/拉链法，闭散列方法/开址定址法)<br>    二次聚集现象；<br>    BST树定义，性质，ADT及其实现，BST树查找，插入，删除算法；平<br>    衡树(AVL)的定义，性质，ADT及其实现，平衡树查找，插入算法，平衡因子的概念；<br>    优先队列与堆，堆的定义，堆的生成，调整算法；<br>    范围查询；</p>
</blockquote>
<h5 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h5><blockquote>
<p>  查找(Searching)<br>    查找：根据某个给定关键字K，从集合R中找出关键字与K相同的记录</p>
</blockquote>
<pre><code>静态查找：集合中记录是固定的
    - 没有插入和删除操作，只有查找
动态查找：集合中记录是动态变化的
    - 除了查找，还可能发生插入和删除</code></pre><h5 id="对线性关系结构的查找"><a href="#对线性关系结构的查找" class="headerlink" title="对线性关系结构的查找"></a>对线性关系结构的查找</h5><h6 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h6><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int SequentialSearch (StaticTable *Tb1, ElementType K)&#123;</span><br><span class="line">    // 在表Tbl[1] ~ Tbl[n]中查找关键字为K的数据元素</span><br><span class="line">    int i;</span><br><span class="line">    Tbl-&gt;Element[0] = K; // 建立哨兵</span><br><span class="line">    for(i=Tbl-Length; Tbl-&gt;Element[i]!=K; i--);</span><br><span class="line">    return i; // 查找成功返回所在单元下标，不成功返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

顺序查找算法的时间复杂度为O(n)</code></pre><h6 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h6><blockquote>
<p>  假设n个数据元素的关键字满足有序(比如：从小到大)<br>    K1 &lt; K2 &lt;……&lt; Kn<br>    并且是连续存放(数组),那么可以进行二分查找</p>
</blockquote>
<pre><code>【例】假设有13个数据元素，按关键字由小到大顺序存放。二分查找关键字为444的数据元素过程如下：—— 找得到情况

    5   16   39   45   51   98   100   202   226   321   368   444   501
    1    2    3    4    5    6    7     8     9     10    11    12    13
    left                          mid                                     right

    1、left = 1 ， right=13； mid = (1+13)/2 = 7; 100&lt;444;
    2、left = mid + 1 = 8, right = 13; mid = (8+13)/2 = 10;  321 &lt; 444
    3、 left = mid +1 = 11, right = 13, mid = (11+13)/2 = 12; 查找结束

【例】 仍然以上面13个数据元素构成的有序线性表为例二分查找关键字为43的数据元素如下: —— 找不到的情况

    5   16   39   45   51   98   100   202   226   321   368   444   501
    1    2    3    4    5    6    7     8     9     10    11    12    13
    left                          mid                                 right

    1、left=1, right=13; mid=(1+13)/2=7;  100&gt;43
    2、left=1, right=mid-1=6; mid=(1+6)/2=3;  39&lt;43
    3、left=mid+1=4, right=6; mid=(4+6)/2=5;  51&gt;43
    4、left=4, right=mid-1=4; mid=(4+4)/2=4;  45&gt;43
    5、left=4, right=mid-2=3; left&gt;right?  查找失败，结束；

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 二分查找算法</span><br><span class="line">int BinarySearch(StaticTable *Tbl, ElementType K)</span><br><span class="line">&#123;// 在表Tbl中查找关键字为K的数据元素</span><br><span class="line">    int left, right, mid, NoFound=-1;</span><br><span class="line"></span><br><span class="line">    left=1; // 初始左边界</span><br><span class="line">    right = Tbl-&gt;Length; // 初始右边界</span><br><span class="line">    while(left&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left+right)/2; // 计算中间元素坐标</span><br><span class="line">        if(K &lt; Tbl-&gt;Element[mid]) right = mid - 1; // 调整右边界</span><br><span class="line">        else if(K &gt; Tbl-&gt;Element[mid]) left = mid + 1;//  调整左边界</span><br><span class="line">        else return mid; // 查找成功，返回数据元素的下标</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NotFound; // 查找不成功，返回-1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    二分查找法具有对数的时间复杂度O(logN)

    这里还可以引申一个二分查找判定树，东西太多了，这个就不多说了，增加负担，后面的知识会涉及，到时候仔细</code></pre><h5 id="Hash查找法"><a href="#Hash查找法" class="headerlink" title="Hash查找法"></a>Hash查找法</h5><blockquote>
<p>  查找的本质: 已知对象找位置<br>        - 有序安排对象：全序、半序<br>        - 直接“算出”对象位置：散列</p>
</blockquote>
<pre><code>散列(哈希)查找法的两项基本工作：
    - 计算位置：构造散列(哈希)函数确定关键字存储位置
    - 解决冲突：应用某种策略解决多个关键词位置相同的问题

时间复杂度几乎是常量：O(1)，即查找时间与问题规模无关！

“散列(Hashing)”的基本思想是：
    1、以关键字key为自变量，通过一个确定的函数h(散列函数),计算出对应的函数值h(key),作为数据对象的存储地址
    2、可能不同的关键字会映射到同一个散列地址上，
        即h(keyi) = h(keyj)(当keyi不等于keyj)，称为“冲突(Collision)”。-- 需要某种冲突解决策略

装填因子(Loading Factor)：设散列表空间大小为m，填入表中元素个数是n，则称α = n/m为散列表的装填因子</code></pre><h6 id="常见的哈希函数-直接定址法、随机数法"><a href="#常见的哈希函数-直接定址法、随机数法" class="headerlink" title="常见的哈希函数(直接定址法、随机数法)"></a>常见的哈希函数(直接定址法、随机数法)</h6><blockquote>
<p>  一个“好”的散列函数一般应考虑下列两个因素：<br>    1、计算简单，以便提高转换速度<br>    2、关键词对应的地址空间分布不均，以尽量减少冲突</p>
</blockquote>
<pre><code>直接定址法、除留余数法(h(key) = key mod p)、数字分析法、折叠法(56793542，h(56793542)=542+793+056=391)、平方取中法(56793542，56793542*56793542= 3225506412905764，h(56793542)=641)、随机数法</code></pre><p>####### 直接定址法<br>    取关键词的某个线性函数值为散列地址，即h(key) = a*key + b (a、b为常数)</p>
<p><img src="/images/%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95.png" alt="直接定址法"></p>
<pre><code>h(key) = key - 1990</code></pre><p>####### 随机数法<br>    选择一个随机函数，取关键字的随机函数值为它的哈希地址，即h(key) = random(key),其中random为随机函数，通常，当关键字长度不等时采用此法构造哈希函数较恰当。</p>
<h6 id="hash冲突的概念"><a href="#hash冲突的概念" class="headerlink" title="hash冲突的概念"></a>hash冲突的概念</h6><blockquote>
<p>  不同的关键字会映射到同一个散列地址上，<br>            即h(keyi) = h(keyj)(当keyi不等于keyj)，称为“冲突(Collision)”。– 需要某种冲突解决策略</p>
</blockquote>
<h6 id="解决冲突的方法-开散列方法-拉链法，闭散列方法-开放定址法"><a href="#解决冲突的方法-开散列方法-拉链法，闭散列方法-开放定址法" class="headerlink" title="解决冲突的方法(开散列方法/拉链法，闭散列方法/开放定址法)"></a>解决冲突的方法(开散列方法/拉链法，闭散列方法/开放定址法)</h6><blockquote>
<p>  常用处理冲突的思路：<br>    - 换个位置：开放地址法<br>    - 同一个位置的冲突对象组织在一起：链地址法(拉链法)</p>
</blockquote>
<p>####### 开散列方法/拉链法</p>
<blockquote>
<p>  Separate Chaining 分离链接法：将相应位置上冲突的所有关键词存储在同一个单链表中</p>
</blockquote>
<pre><code>把一个位置上的所有有冲突的元素全部串在一起

【例】设关键字序列为47, 7, 29, 11, 16, 92, 22, 8, 3, 50, 37, 89, 94, 21;
散列函数取为：h(key) = key mod 11;
用分离链接法(链地址法)处理冲突.</code></pre><p><img src="/images/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png" alt="链地址法"></p>
<pre><code>表中有9个结点只需1次查找
5个结点需要2次查找
查找成功的平均查找次数：
ASL s=(9+5*2) / 14 ≈ 1.36

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#define KEYLENGTH 15                   /* 关键词字符串的最大长度 */</span><br><span class="line">typedef char ElementType[KEYLENGTH+1]; /* 关键词类型用字符串 */</span><br><span class="line">typedef int Index;                     /* 散列地址类型 */</span><br><span class="line">/******** 以下是单链表的定义 ********/</span><br><span class="line">typedef struct LNode *PtrToLNode;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToLNode Position;</span><br><span class="line">typedef PtrToLNode List;</span><br><span class="line">/******** 以上是单链表的定义 ********/</span><br><span class="line"></span><br><span class="line">typedef struct TblNode *HashTable; /* 散列表类型 */</span><br><span class="line">struct TblNode &#123;   /* 散列表结点定义 */</span><br><span class="line">    int TableSize; /* 表的最大长度 */</span><br><span class="line">    List Heads;    /* 指向链表头结点的数组 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HashTable CreateTable( int TableSize )</span><br><span class="line">&#123;</span><br><span class="line">    HashTable H;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    H = (HashTable)malloc(sizeof(struct TblNode));</span><br><span class="line">    /* 保证散列表最大长度是素数，具体见代码5.3 */</span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line"></span><br><span class="line">    /* 以下分配链表头结点数组 */</span><br><span class="line">    H-&gt;Heads = (List)malloc(H-&gt;TableSize*sizeof(struct LNode));</span><br><span class="line">    /* 初始化表头结点 */</span><br><span class="line">    for( i=0; i&lt;H-&gt;TableSize; i++ ) &#123;</span><br><span class="line">        H-&gt;Heads[i].Data[0] = &apos;\0&apos;;</span><br><span class="line">        H-&gt;Heads[i].Next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Position Find( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position P;</span><br><span class="line">    Index Pos;</span><br><span class="line">    </span><br><span class="line">    Pos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */</span><br><span class="line">    P = H-&gt;Heads[Pos].Next; /* 从该链表的第1个结点开始 */</span><br><span class="line">    /* 当未到表尾，并且Key未找到时 */ // 遍历单向链表的循环</span><br><span class="line">    while( P &amp;&amp; strcmp(P-&gt;Data, Key) )</span><br><span class="line">        P = P-&gt;Next;</span><br><span class="line"></span><br><span class="line">    return P; /* 此时P或者指向找到的结点，或者为NULL */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Insert( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position P, NewCell;</span><br><span class="line">    Index Pos;</span><br><span class="line">    </span><br><span class="line">    P = Find( H, Key );</span><br><span class="line">    if ( !P ) &#123; /* 关键词未找到，可以插入 */</span><br><span class="line">        NewCell = (Position)malloc(sizeof(struct LNode));</span><br><span class="line">        strcpy(NewCell-&gt;Data, Key);</span><br><span class="line">        Pos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */</span><br><span class="line">        /* 将NewCell插入为H-&gt;Heads[Pos]链表的第1个结点 */</span><br><span class="line">        NewCell-&gt;Next = H-&gt;Heads[Pos].Next;</span><br><span class="line">        H-&gt;Heads[Pos].Next = NewCell; </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; /* 关键词已存在 */</span><br><span class="line">        printf(&quot;键值已存在&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DestroyTable( HashTable H )</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    Position P, Tmp;</span><br><span class="line">    </span><br><span class="line">    /* 释放每个链表的结点 */</span><br><span class="line">    for( i=0; i&lt;H-&gt;TableSize; i++ ) &#123;</span><br><span class="line">        P = H-&gt;Heads[i].Next;</span><br><span class="line">        while( P ) &#123;</span><br><span class="line">            Tmp = P-&gt;Next;</span><br><span class="line">            free( P );</span><br><span class="line">            P = Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free( H-&gt;Heads ); /* 释放头结点数组 */</span><br><span class="line">    free( H );        /* 释放散列表结点 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>####### 闭散列方法/开放定址法</p>
<blockquote>
<p>  开放地址法 Open Addressing<br>    一旦产生了冲突(该地址已有其他元素)，就按某种规则去寻找另一空地址</p>
</blockquote>
<pre><code>若发生了第i次冲突，试探的下一个地址将增加di，基本公式是：hi(key) = (h(key) + di) mod TableSize (1&lt;=i&lt;TableSize)
偏移量di决定了不同的解决冲突方案：线性探测(di = i)、平方探测(di = +-i^2)、双散列(di = i*h2(key))


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 创建开放定址法的散列法</span><br><span class="line">#define MAXTABLESIZE 100000 /* 允许开辟的最大散列表长度 */</span><br><span class="line">typedef int ElementType;    /* 关键词类型用整型 */</span><br><span class="line">typedef int Index;          /* 散列地址类型 */</span><br><span class="line">typedef Index Position;     /* 数据所在位置与散列地址是同一类型 */</span><br><span class="line">/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */</span><br><span class="line">typedef enum &#123; Legitimate, Empty, Deleted &#125; EntryType;</span><br><span class="line"></span><br><span class="line">typedef struct HashEntry Cell; /* 散列表单元类型 */</span><br><span class="line">struct HashEntry&#123;</span><br><span class="line">    ElementType Data; /* 存放元素 */</span><br><span class="line">    EntryType Info;   /* 单元状态 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct TblNode *HashTable; /* 散列表类型 */</span><br><span class="line">struct TblNode &#123;   /* 散列表结点定义 */</span><br><span class="line">    int TableSize; /* 表的最大长度 */</span><br><span class="line">    Cell *Cells;   /* 存放散列单元数据的数组 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int NextPrime( int N )</span><br><span class="line">&#123; /* 返回大于N且不超过MAXTABLESIZE的最小素数 */</span><br><span class="line">    int i, p = (N%2)? N+2 : N+1; /*从大于N的下一个奇数开始 */</span><br><span class="line"></span><br><span class="line">    while( p &lt;= MAXTABLESIZE ) &#123;</span><br><span class="line">        for( i=(int)sqrt(p); i&gt;2; i-- )</span><br><span class="line">            if ( !(p%i) ) break; /* p不是素数 */</span><br><span class="line">        if ( i==2 ) break; /* for正常结束，说明p是素数 */</span><br><span class="line">        else  p += 2; /* 否则试探下一个奇数 */</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashTable CreateTable( int TableSize )</span><br><span class="line">&#123;</span><br><span class="line">    HashTable H;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    H = (HashTable)malloc(sizeof(struct TblNode));</span><br><span class="line">    /* 保证散列表最大长度是素数 */</span><br><span class="line">    H-&gt;TableSize = NextPrime(TableSize);</span><br><span class="line">    /* 声明单元数组 */</span><br><span class="line">    H-&gt;Cells = (Cell *)malloc(H-&gt;TableSize*sizeof(Cell));</span><br><span class="line">    /* 初始化单元状态为“空单元” */</span><br><span class="line">    for( i=0; i&lt;H-&gt;TableSize; i++ )</span><br><span class="line">        H-&gt;Cells[i].Info = Empty;</span><br><span class="line"></span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>######## 线性探测法 Linear Probing</p>
<blockquote>
<p>  线性探测法：以增量序列1， 2， ……，(TableSize-1),循环试探下一个存储地址</p>
</blockquote>
<pre><code>【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，
    散列表表厂TableSize=13 (装填因子α=9/13≈0.69)；
    散列函数为：h(key)=key mod 11
    用线性探测法处理冲突，列出依次插入后的散列表，并估算查找性能

    关键字(key) | 47 |  7  |  29  |  11  |  9  |  84  |  54  |  20  |  30  |
    -|-|-|-|-|-|-|-|-|-
    散列地址h(key) | 3 | 7 | 7 | 0 | 9 | 7 | 10 | 9 | 8 |
    冲突次数 | 0 | 0 | 1 | 0 | 0 | 3 | 1 | 3 | 6 |</code></pre><p><img src="/images/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.png" alt="线性探测法"></p>
<pre><code>散列表查找性能分析：平均查找次数/平均查找长度
成功平均查找长度ASLs
不成功平均查找长度ASLu

散列表：
H(key) | 0 |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  10  |  11  |  12  
    -|-|-|-|-|-|-|-|-|-
    key | 11 | 30 |  | 47 |  |  |  | 7 | 29 | 9 | 84 | 54 | 20 |
    冲突次数 | 0 | 6 |  | 0 |  |  |  | 0 | 1 | 0 | 3 | 1 | 3 |

【分析】
ASLs： 查找表中关键字的平均查找比较次数(其冲突次数加1)
ASLs = (1 + 7 + 1 + 1 + 2 + 1 + 4 + 2 + 4)/9 = 23/9 ≈ 2.56
ASLu： 不在散列表中的关键词的平均查找次数(不成功)
    一般方法：将不在散列表中的关键词分若干类
        如：根据H(key)值分类 // 额这个我没看懂
    ASLu = (3 + 2 + 1 + 2 + 1 + 1 + 1 + 9 + 8 + 7 + 6) / 11 = 41/11 ≈ 3.73</code></pre><p>######## 平方探测法 Quadratic Probing – 二次探测</p>
<blockquote>
<p>  平方探测法：以增量序列1^2， -1^2， 2^2， -2^2，……， q^2,-q^2且q&lt;=|TableSize/2|,循环试探下一个存储地址<br>    【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，<br>        散列表表厂TableSize=13 (装填因子α=9/13≈0.69)；<br>        散列函数为：h(key)=key mod 11<br>        用平方探测法处理冲突，列出依次插入后的散列表，并估算查找性能ASLs</p>
</blockquote>
<pre><code>关键字(key) | 47 |  7  |  29  |  11  |  9  |  84  |  54  |  20  |  30  |
-|-|-|-|-|-|-|-|-|-
散列地址h(key) | 3 | 7 | 7 | 0 | 9 | 7 | 10 | 9 | 8 |
冲突次数 | 0 | 0 | 1 | 0 | 0 | 2 | 0 | 3 | 3 |</code></pre><p><img src="/images/%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95.png" alt="平方探测法"><br>        ASLs = (1+1+2+1+1+3+1+4+4)/9 = 18/9 = 2 平均成功查找次数</p>
<pre><code>是否有空间，平方探测(二次探测)就能找到？ 明明有空间，但是就是找不到</code></pre><p><img src="/images/%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="平方探测的问题"></p>
<pre><code>    跳来跳去就是找不到后面两个空位，但是避免了线性探测也很大的问题，就是聚集现象，二次探测也有聚集现象但没那么严重

    有定理显示：如果散列表长度TableSize是某个4k+3(k是正整数)形式的素数时，平方探测法就可以探查到整个散列表空间。

        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 平方探测法的查找与插入</span><br><span class="line">Position Find( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position CurrentPos, NewPos;</span><br><span class="line">    int CNum = 0; /* 记录冲突次数 */</span><br><span class="line"></span><br><span class="line">    NewPos = CurrentPos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */</span><br><span class="line">    /* 当该位置的单元非空，并且不是要找的元素时，发生冲突 */</span><br><span class="line">    while( H-&gt;Cells[NewPos].Info!=Empty &amp;&amp; H-&gt;Cells[NewPos].Data!=Key ) &#123;</span><br><span class="line">                                        /* 字符串类型的关键词需要 strcmp 函数!! */</span><br><span class="line">        /* 统计1次冲突，并判断奇偶次 */</span><br><span class="line">        if( ++CNum%2 )&#123; /* 奇数次冲突 */</span><br><span class="line">            NewPos = CurrentPos + (CNum+1)*(CNum+1)/4; /* 增量为+[(CNum+1)/2]^2 */</span><br><span class="line">            if ( NewPos &gt;= H-&gt;TableSize )</span><br><span class="line">                NewPos = NewPos % H-&gt;TableSize; /* 调整为合法地址 */</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; /* 偶数次冲突 */</span><br><span class="line">            NewPos = CurrentPos - CNum*CNum/4; /* 增量为-(CNum/2)^2 */</span><br><span class="line">            while( NewPos &lt; 0 )</span><br><span class="line">                NewPos += H-&gt;TableSize; /* 调整为合法地址 */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NewPos; /* 此时NewPos或者是Key的位置，或者是一个空单元的位置（表示找不到）*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Insert( HashTable H, ElementType Key )</span><br><span class="line">&#123;</span><br><span class="line">    Position Pos = Find( H, Key ); /* 先检查Key是否已经存在 */</span><br><span class="line"></span><br><span class="line">    if( H-&gt;Cells[Pos].Info != Legitimate ) &#123; /* 如果这个单元没有被占，说明Key可以插入在此 */</span><br><span class="line">        H-&gt;Cells[Pos].Info = Legitimate;</span><br><span class="line">        H-&gt;Cells[Pos].Data = Key;</span><br><span class="line">        /*字符串类型的关键词需要 strcpy 函数!! */</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf(&quot;键值已存在&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

再散列Rehashing</code></pre><h6 id="二次聚集现象"><a href="#二次聚集现象" class="headerlink" title="二次聚集现象"></a>二次聚集现象</h6><blockquote>
<p>  指在处理冲突过程中发生的两个第一个哈希地址不同的记录争夺同一个后继哈希地址的现象</p>
</blockquote>
<h5 id="BST树-二叉搜索树-Binary-Search-Tree"><a href="#BST树-二叉搜索树-Binary-Search-Tree" class="headerlink" title="BST树(二叉搜索树) Binary Search Tree"></a>BST树(二叉搜索树) Binary Search Tree</h5><blockquote>
<pre><code>也称二叉排序树或二叉查找树
查找问题：
    静态查找与动态查找
    针对动态查找，数据如何组织？</code></pre></blockquote>
<h6 id="BST树定义、性质、ADT及其实现"><a href="#BST树定义、性质、ADT及其实现" class="headerlink" title="BST树定义、性质、ADT及其实现"></a>BST树定义、性质、ADT及其实现</h6><blockquote>
<p>  二叉搜索树： 一颗二叉树，可以为空，如果不为空，满足以下性质：<br>        1、非空左子树的所有键值小于其根结点的键值<br>        2、非空右子树的所有键值大于其根结点的键值<br>        3、左、右子树都是二叉搜索树</p>
</blockquote>
<pre><code>Position Find(ElementType X, BinTree BST) : 从二叉搜索树BST中查找元素X，返回其所在结点的地址
Position FindMin(BinTree BST): 从二叉搜索树BST中查找并返回最小元素所在结点的地址
Position FindMax(BinTree BST): 从二叉搜索树BST中查找并返回最大元素所在结点的地址
BinTree Insert(ElementType X, BinTree BST)
BinTree Delete(ElementType X, BinTree BST)</code></pre><h6 id="BST树查找、插入、删除算法"><a href="#BST树查找、插入、删除算法" class="headerlink" title="BST树查找、插入、删除算法"></a>BST树查找、插入、删除算法</h6><p>####### 二叉搜索树的查找操作： Find</p>
<blockquote>
<p>  Position Find(ElementType X, BinTree BST) : 从二叉搜索树BST中查找元素X，返回其所在结点的地址<br>    查找从根结点开始，如果树为空，返回NULL<br>    若搜索树非空，则根结点关键字与X进行比较，并进行不同处理：<br>        1、若X小于根结点的键值，只需在左子树中继续搜搜<br>        2、如果X大于根结点的键值，在右子树中进行继续搜索<br>        3、若两者比较结果是相等，搜索完成，返回指向此结点的指针</p>
</blockquote>
<pre><code>                                r  r=X， OK！

                    X&lt;r     Tl     Tr    X&gt;r

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 递归的方法  而且使用的都是尾递归 效率不高</span><br><span class="line">Position Find(ElementType X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    if(!BST) return NULL; // 查找失败</span><br><span class="line">    if(X&gt;BST-&gt;Data)</span><br><span class="line">        return Find(X, BST-&gt;Right); // 在右子树中继续查找</span><br><span class="line">    else if(X&lt;BST-&gt;Data)</span><br><span class="line">        return Find(X, BST-&gt;Left); // 在左子树中继续查找</span><br><span class="line">    else  // X == BST-&gt;Data</span><br><span class="line">        return BST; // 查找成功，返回结点的找到结点的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

由于非递归函数的执行效率高，可将“尾递归”函数改为迭代函数，用循环
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Position IterFind(ElementType X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    while(BST)&#123;</span><br><span class="line">        if(X&gt;BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Right; // 向右子树中移动，继续查找</span><br><span class="line">        else if(X&lt;BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Left; // 向左子树中移动，继续查找</span><br><span class="line">        else // X== BST-&gt;Data</span><br><span class="line">            return BST; // 查找成功，返回结点的找到结点的地址</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL; // 查找失败</span><br><span class="line">&#125;</span><br><span class="line">// 查找的效率决定于树的高度</span><br></pre></td></tr></table></figure>

查找最大和最小元素
    最大元素一定是在树的最右分支的端结点上
    最小元素一定是在树的最左分支的端结点上</code></pre><p><img src="/images/%E6%9C%80%E5%8F%B3%E7%AB%AF%E7%BB%93%E7%82%B9%E5%92%8C%E6%9C%80%E5%B7%A6%E7%AB%AF%E7%BB%93%E7%82%B9.png" alt="最右端结点和最左端结点"><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 查找最小元素的递归函数</span><br><span class="line">Position FindMin(BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    if(!BST) return NULL; // 空的二叉搜索树，返回NULL</span><br><span class="line">    else if(!BST-&gt;Left)</span><br><span class="line">        return BST; // 找到最左叶结点并返回</span><br><span class="line">    else</span><br><span class="line">        return FindMin(BST-&gt;Left); // 沿左分支继续查找</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查找最大元素的迭代函数</span><br><span class="line">Position FindMax(BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    if(BST)</span><br><span class="line">        while(BST-&gt;Right) BST = BST-&gt;Right;</span><br><span class="line">        // 沿右分支继续查找，直到最右叶结点</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####### 二叉搜索树的插入</p>
<blockquote>
<p>  【分析】关键是要找到元素应该插入的位置，可以采用与Find类似的方法，插入完成后要保证仍然是二叉搜索树</p>
</blockquote>
<p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5.png" alt="二叉树的插入"></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 二叉搜索树的插入算法</span><br><span class="line">BinTree Insert(ElementType X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    if(!BST)&#123;</span><br><span class="line">        // 若原树为空，生成并返回一个结点的二叉搜索树</span><br><span class="line">        BST = malloc(sizeof(struct TreeNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = NULL;</span><br><span class="line">    &#125;else &#123; // 开始找要插入元素的位置</span><br><span class="line">        if(X &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Insert(X, BST-&gt;Left); // 递归插入左子树</span><br><span class="line">        else if(X&gt;BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Insert(X, BST-&gt;Right); // 递归插入右子树</span><br><span class="line">        // else X已经存在，什么都不做</span><br><span class="line">    &#125;</span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>####### 二叉搜索树的删除</p>
<blockquote>
<p>  考虑三种情况：<br>    1、要删除的是叶结点：直接删除，并再修改其父结点指针——置为NULL<br>    2、要删除的结点只有一个孩子结点：将其父结点的指针指向要删除结点的孩子结点<br>    3、要删除的结点有左、右两颗子树：<br>        用另一结点替代被删除结点：<strong>右子树的最小元素</strong>或者<strong>左子树的最大元素</strong><br>        1、取右子树的最小元素替代<br>        2、取左子树的最大元素替代</p>
</blockquote>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BinTree Delete(ElementType X, BinTree BST)</span><br><span class="line">&#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    if(!BST) printf(&quot;要删除的元素未找到&quot;);</span><br><span class="line">    else if(X&lt;BST-&gt;Data)</span><br><span class="line">        BST-&gt;Left = Delete(X, BST-&gt;Left); // 左子树递归删除</span><br><span class="line">    else if(X&gt;BST-&gt;Data)</span><br><span class="line">        BST-&gt;Right = Delete(X, BST-&gt;Right); // 右子树递归删除</span><br><span class="line">    else // 找到要删除的结点</span><br><span class="line">        if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; // 被删除结点有左右两个子结点</span><br><span class="line">            Tmp = FindMin(BSt-&gt;Right); // 在右子树中找最小的元素填充删除结点</span><br><span class="line">            BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">            BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right); // 在删除结点的右子树中删除最小元素</span><br><span class="line">        &#125;else &#123; // 被删除结点有一个或无子结点</span><br><span class="line">            Tmp = BST;</span><br><span class="line">            if(!BST-&gt;Left) // 有右孩子或无子结点</span><br><span class="line">                BST = BST-&gt;Right;</span><br><span class="line">            else if(!BST-&gt;Right) // 有左孩子或无子结点</span><br><span class="line">                BST = BST-&gt;Left;</span><br><span class="line">            free(Tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="平衡树AVL"><a href="#平衡树AVL" class="headerlink" title="平衡树AVL"></a>平衡树AVL</h5><blockquote>
<p>  平衡二叉树<br>    【例】搜索树结点不同插入次序，将导致不同的深度和平均查找长度ASL。<br>        “按照字典顺序比较大小”</p>
</blockquote>
<p><img src="/images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BC%95%E4%BE%8B.png" alt="平衡二叉树引例"><br>    a.自然月份序列<br>        ASL(a) = (1 + 2<em>2 + 3</em>3 + 4<em>3 + 5</em>2 + 6*1)/12 = 3.5<br>    b.按July，Feb，May，Mar，Aug，Jan， Apr，Jun， Oct， Sept， Nov， Dec<br>        ASL(b) = 3.0<br>    c.月份字符串大小顺序<br>        ASL(c) = 6.5</p>
<h6 id="平衡树-AVL-定义、性质、ADT及其实现"><a href="#平衡树-AVL-定义、性质、ADT及其实现" class="headerlink" title="平衡树(AVL)定义、性质、ADT及其实现"></a>平衡树(AVL)定义、性质、ADT及其实现</h6><blockquote>
<p>  平衡二叉树(Blanced Binary Tree) AVL树<br>        空树，或者<strong>任一结点</strong>左、右子树高度差的绝对值不超过1，即|BF(T)| &lt;= 1</p>
</blockquote>
<pre><code>&quot;平衡因子(Blance Factor，简称BF)&quot;：BF(T) = hl - hr,其中hl和hr分别为T的左、右子树的高度，左右子树的高度差</code></pre><p><img src="/images/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="平衡二叉树"></p>
<pre><code>平衡二叉树的高度能达到Log2^n吗? 完全二叉树的情况</code></pre><p><img src="/images/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6.png" alt="完全二叉树高度"></p>
<pre><code>设nh高度为h的平衡二叉树的最少结点树，结点数最少时：</code></pre><p><img src="/images/%E6%9C%80%E5%B0%91%E7%BB%93%E7%82%B9%E9%AB%98%E5%BA%A6.png" alt="最少结点高度"><br>    斐波那契序列：F0 = 1； F1 = 1；Fi = Fi-1 + Fi-2 for i&gt;1</p>
<pre><code>给定结点树为n的AVL树的最大高度为O(log2^n)</code></pre><h6 id="平衡树-AVL-查找、插入算法"><a href="#平衡树-AVL-查找、插入算法" class="headerlink" title="平衡树(AVL)查找、插入算法"></a>平衡树(AVL)查找、插入算法</h6><blockquote>
<p>  平衡二叉树的插入和删除都会有一个问题，会破坏原平衡二叉树的平衡，涉及到平衡二叉树的调整，也一定要保证二叉搜索树的条件成立</p>
</blockquote>
<pre><code>RR旋转 右子树的右子树添加</code></pre><p><img src="/images/%E5%8F%B3%E5%8D%95%E6%97%8B.png" alt="右单旋"><br>    不平衡的“发现者”是Mar，“麻烦结点”Nov在发现者右子树的右边，因而叫RR插入，需要RR旋转(右单旋)</p>
<p><img src="/images/%E5%8F%B3%E5%8D%95%E6%97%8B%E8%B0%83%E6%95%B4.png" alt="右单旋调整"></p>
<p><img src="/images/RR%E6%97%8B%E8%BD%AC_01.png" alt="RR旋转_例1"></p>
<p><img src="/images/RR%E6%97%8B%E8%BD%AC_02.png" alt="RR旋转_例2"></p>
<pre><code>LL旋转 左子树的左子树添加</code></pre><p><img src="/images/%E5%B7%A6%E5%8D%95%E9%80%89.png" alt="左单旋"><br>    “发现者”是Mar，“麻烦结点”Apr在发现者的左子树的左边，因而叫LL插入，需要LL旋转(左单旋)</p>
<p><img src="/images/%E5%B7%A6%E5%8D%95%E6%97%8B%E8%B0%83%E6%95%B4.png" alt="左单旋调整"></p>
<pre><code>LR旋转 左右旋转，左子树的右子树上添加</code></pre><p><img src="/images/LR%E6%97%8B%E8%BD%AC.png" alt="LR旋转"></p>
<pre><code>“发现者”是May,&quot;麻烦结点&quot;Jan在左子树的右边，因而叫LR插入，需要LR旋转 ，中间结点旋转到中间位置   </code></pre><p><img src="/images/LR%E6%97%8B%E8%BD%AC%E8%B0%83%E6%95%B4.png" alt="LR旋转调整"></p>
<pre><code>RL旋转 右左旋转，右子树的左子树上添加</code></pre><p><img src="/images/RL%E6%97%8B%E8%BD%AC.png" alt="RL旋转.png"></p>
<p><img src="/images/RL%E6%97%8B%E8%BD%AC%E8%B0%83%E6%95%B4.png" alt="RL旋转调整"></p>
<pre><code>注意：有时候插入元素即便不需要调整结构，也可能需要重新计算一些平衡因子。</code></pre><h6 id="平衡因子的概念"><a href="#平衡因子的概念" class="headerlink" title="平衡因子的概念"></a>平衡因子的概念</h6><blockquote>
<p>  “平衡因子(Blance Factor，简称BF)”：BF(T) = hl - hr,其中hl和hr分别为T的左、右子树的高度，左右子树的高度差</p>
</blockquote>
<h5 id="优先队列与堆"><a href="#优先队列与堆" class="headerlink" title="优先队列与堆"></a>优先队列与堆</h5><blockquote>
<p>  很多时候排队不一定要按时间顺序来进行排队，很多任务会有优先级别，类似CPU的调度，这个时候的排队原则又是什么呢？<br>    优先队列(Priority Queue): 特殊的”队列”,取出元素的顺序是依照元素的优先权(关键字)大小，而不是元素进入队列的先后顺序。</p>
</blockquote>
<h6 id="优先队列与堆的定义"><a href="#优先队列与堆的定义" class="headerlink" title="优先队列与堆的定义"></a>优先队列与堆的定义</h6><blockquote>
<p>  若采用数组或链表实现优先队列<br>    数组：<br>        插入 —— 元素总是插入尾部 O(1)<br>        删除 —— 查找最大(或最小)关键字从数组中删去元素O(n)，需要移动元素O(n)</p>
</blockquote>
<pre><code>链表：
    插入 —— 元素总是插入链表的头部 O(1)
    删除 —— 查找最大(最小)关键字O(n), 删去结点O(1)

有序数组：
    插入 —— 找到合适的位置O(n)或O(log2^n)，移动元素并插入O(n)
    删除 —— 删去最后一个元素 O(1)

有序链表：
    插入 —— 找到合适的位置O(n), 插入元素O(1)
    删除 —— 删除首元素或最后元素 O(1)

是否可以采用二叉树存储结构？
    - 二叉搜索树？ 树可能会歪
    - 如果采用二叉树结构，应更关注插入还是删除？ 重点考虑删除
        - 树结点顺序怎么安排？
        - 树结构怎样？

    最大值在根结点，用堆，完全二叉树进行存储

优先队列的完全二叉树表示：</code></pre><p><img src="/images/%E5%A0%86.png" alt="堆"></p>
<pre><code>堆的两个特性：
    结构性：用数组表示的完全二叉树
    有序性：任一结点的关键字是其子树所有结点的最大值(或最小值)
        “最大堆MaxHeap”, 也称&quot;大顶堆&quot;： 最大值
        “最小堆Minheap”, 也称“小顶堆”： 最小值

堆的ADT 抽象数据类型描述
类型对象：最大堆(MaxHeap)
数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值
操作集：最大堆H∈ MaxHeap, 元素item∈ElementType，主要操作有：
    - MaxHeap Create(int MaxSize): 创建一个空的最大堆
    - Boolean Is Full(MaxHeap H): 判断最大堆H是否已满
    - Insert(MaxHeap H, ElementType item): 将元素item插入最大堆H   **
    - Boolean IsEmpty(MaxHeap H): 判断最大堆H是否为空
    - ElementType DeleteMax(MaxHeap H): 返回H中最大元素 (高优先级) **</code></pre><h6 id="堆的生成"><a href="#堆的生成" class="headerlink" title="堆的生成"></a>堆的生成</h6><blockquote>
<p>  最大堆的建立<br>    堆的一个应用：堆排序<br>    —— 需要先建堆</p>
</blockquote>
<pre><code>建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中。
方法一： 通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为O(NlogN)
方法二：在线性时间复杂度下建立最大堆
    (1) 将N个元素按输入顺序存入，先满足完全二叉树的结构特性
    (2) 调整各结点位置，以满足最大堆的有序特性

建堆时间复杂性： O(n) 树中个结点的高度和

最大堆的操作

    最大堆的创建
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct HeapStruct *MaxHeap;</span><br><span class="line">struct HeapStruct&#123;</span><br><span class="line">    ElementType *Elements; // 存储堆元素的数组</span><br><span class="line">    int Size; // 堆的当前元素个数</span><br><span class="line">    int Capacity // 堆的最大容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MaxHeap Create (int MaxSize)</span><br><span class="line">&#123;</span><br><span class="line">    // 创建容量为MaxSize的空的最大堆</span><br><span class="line">    // 然后对结构里的三个分量进行赋值</span><br><span class="line">    MaxHeap H = malloc(sizeof(struct HeapStruct));</span><br><span class="line">    H-&gt;Elements = malloc((MaxSize+1) * sizeof(ElementType)); // 在申请一个数组空间，从下标为1的地方开始存放</span><br><span class="line">    H-&gt;Size = 0;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Elements[0] = MaxData; // 定义哨兵为大于堆中所有可能元素的值，便于以后更快操作</span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    最大堆的插入
    算法：将新增结点插入到从其父结点到根结点的有序序列中
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Insert(MaxHeap H, ElementType item)</span><br><span class="line">&#123;</span><br><span class="line">    // 将元素item插入到最大堆H，其中H-&gt;Elements[0]已经定义为哨兵</span><br><span class="line">    int i;</span><br><span class="line">    if(IsFull(H))&#123;</span><br><span class="line">        printf(&quot;最大堆已满&quot;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size; // i指向插入堆中的最后一个元素的位置</span><br><span class="line">    for( ; H-&gt;Elements[i/2] &lt; item; i/=2) // 与父结点比较，父结点位置为i/2</span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i/2]; // 向下过滤结点</span><br><span class="line">    // 注意for循环里面的第三个分式，for循环条件满足，i/=2, i赋值为原父结点，然后将值插入到调整后的i结点</span><br><span class="line">    // H-&gt;Element[0]是哨兵元素，它不小于堆中的最大元素，控制循环结束，如果没有哨兵可以在条件加&amp;&amp; i&gt;1</span><br><span class="line">    H-&gt;Elements[i] = item; // 将item插入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        时间复杂度 T(N) = O(logN)

    最大堆的删除
    取出根结点(最大值)元素，同时删除堆的一个结点
    时间复杂度为树的高度：T(N) = O(logN)

        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ElementType DeleteMax(MaxHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    // 从最大堆H中取出键值为最大的元素，并删除一个结点</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType MaxItem, temp;</span><br><span class="line"></span><br><span class="line">    // 1.首先判断堆空不空，如果为空就不需要删除任何东西了</span><br><span class="line">    if(IsEmpty(H))&#123;</span><br><span class="line">        printf(&quot;最大堆已空&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.然后把删的元素先保存起来</span><br><span class="line">    MaxItem = H-&gt;Elements[1]; // 取出根结点最大值</span><br><span class="line"></span><br><span class="line">    // 3.把最后一个元素替换上来</span><br><span class="line">    // 用最大堆中最后一个元素从根结点开始向上过滤下层结点</span><br><span class="line">    temp = H-&gt;Elements[H-&gt;Size--];</span><br><span class="line">    // 4. 找Temp该放在哪里， for循环就找temp的位置， 用parent来指示</span><br><span class="line">    // Parent*2 &lt;= H-&gt;Size; 判断是否有左儿子</span><br><span class="line">    // 然后进入循环找左右儿子里面最大的跟Parent比较</span><br><span class="line">    for(Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child)</span><br><span class="line">    &#123;</span><br><span class="line">        Child = Parent * 2; // Child指向左儿子  右儿子就是Child + 1</span><br><span class="line">        // Child = H-&gt;Size; 意味着左儿子是最后一个元素， Child != H-&gt;Size  意味着一定有右儿子</span><br><span class="line">        if((Child != H-&gt;Size) &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child + 1])) // 比较左右儿子</span><br><span class="line">            Child++; </span><br><span class="line">        // Child指向左右子结点的较大者 </span><br><span class="line">        if(temp &gt;= H-&gt;Elements[Child]) break;</span><br><span class="line">        else // 移动temp元素到下一层</span><br><span class="line">            H-&gt;Elements[Parent] = H-&gt;Elements[Child]; // 就是把左右儿子中最大的提上来</span><br><span class="line">        // 然后for循环中的Parent = Child；就是让Parent下去，到左右儿子中最大的那个位置上去</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[Parent] = H-&gt;Elements[Child];</span><br><span class="line">    return MaxItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">// 堆的定义与操作</span><br><span class="line">typedef struct HNode *Heap; /* 堆的类型定义 */</span><br><span class="line">struct HNode &#123;</span><br><span class="line">    ElementType *Data; /* 存储元素的数组 */</span><br><span class="line">    int Size;          /* 堆中当前元素个数 */</span><br><span class="line">    int Capacity;      /* 堆的最大容量 */</span><br><span class="line">&#125;;</span><br><span class="line">typedef Heap MaxHeap; /* 最大堆 */</span><br><span class="line">typedef Heap MinHeap; /* 最小堆 */</span><br><span class="line"></span><br><span class="line">#define MAXDATA 1000  /* 该值应根据具体情况定义为大于堆中所有可能元素的值 */</span><br><span class="line"></span><br><span class="line">MaxHeap CreateHeap( int MaxSize )</span><br><span class="line">&#123; /* 创建容量为MaxSize的空的最大堆 */</span><br><span class="line"></span><br><span class="line">    MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode));</span><br><span class="line">    H-&gt;Data = (ElementType *)malloc((MaxSize+1)*sizeof(ElementType));</span><br><span class="line">    H-&gt;Size = 0;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Data[0] = MAXDATA; /* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*/</span><br><span class="line"></span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsFull( MaxHeap H )</span><br><span class="line">&#123;</span><br><span class="line">    return (H-&gt;Size == H-&gt;Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Insert( MaxHeap H, ElementType X )</span><br><span class="line">&#123; /* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if ( IsFull(H) ) &#123; </span><br><span class="line">        printf(&quot;最大堆已满&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size; /* i指向插入后堆中的最后一个元素的位置 */</span><br><span class="line">    for ( ; H-&gt;Data[i/2] &lt; X; i/=2 )</span><br><span class="line">        H-&gt;Data[i] = H-&gt;Data[i/2]; /* 上滤X */</span><br><span class="line">    H-&gt;Data[i] = X; /* 将X插入 */</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define ERROR -1 /* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */</span><br><span class="line"></span><br><span class="line">bool IsEmpty( MaxHeap H )</span><br><span class="line">&#123;</span><br><span class="line">    return (H-&gt;Size == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ElementType DeleteMax( MaxHeap H )</span><br><span class="line">&#123; /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType MaxItem, X;</span><br><span class="line"></span><br><span class="line">    if ( IsEmpty(H) ) &#123;</span><br><span class="line">        printf(&quot;最大堆已为空&quot;);</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaxItem = H-&gt;Data[1]; /* 取出根结点存放的最大值 */</span><br><span class="line">    /* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span><br><span class="line">    X = H-&gt;Data[H-&gt;Size--]; /* 注意当前堆的规模要减小 */</span><br><span class="line">    for( Parent=1; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2;</span><br><span class="line">        if( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line"></span><br><span class="line">    return MaxItem;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*----------- 建造最大堆 -----------*/</span><br><span class="line">void PercDown( MaxHeap H, int p )</span><br><span class="line">&#123; /* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line"></span><br><span class="line">    X = H-&gt;Data[p]; /* 取出根结点存放的值 */</span><br><span class="line">    for( Parent=p; Parent*2&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2;</span><br><span class="line">        if( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= H-&gt;Data[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BuildHeap( MaxHeap H )</span><br><span class="line">&#123; /* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */</span><br><span class="line">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    /* 从最后一个结点的父节点开始，到根结点1 */</span><br><span class="line">    for( i = H-&gt;Size/2; i&gt;0; i-- )</span><br><span class="line">        PercDown( H, i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h6 id="调整算法"><a href="#调整算法" class="headerlink" title="调整算法"></a>调整算法</h6><blockquote>
<p>  调整算法在上面对的操作里详细的说明，可以记一下</p>
</blockquote>
<h6 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h6><blockquote>
<p>  这个不知道说的是什么，没找到资料</p>
</blockquote>
<h4 id="四、排序"><a href="#四、排序" class="headerlink" title="四、排序"></a>四、排序</h4><blockquote>
<p>  内容：<br>        排序基本概念；<br>        插入排序，<br>        希尔排序，<br>        选择排序，<br>        快速排序，<br>        合并排序，<br>        基数排序<br>        等排序算法基本思想，算法代码及基本的时间复杂度分析</p>
</blockquote>
<h5 id="排序基本概念"><a href="#排序基本概念" class="headerlink" title="排序基本概念"></a>排序基本概念</h5><blockquote>
<p>  排序算法的效率很重要，大多数情况下，为简单起见，讨论从小到大的整数排序，N是正整数，只讨论基于比较的排序(&gt; = &lt; 有定义)，只讨论内部排序，假设内存空间足够大，排序可一次完成，稳定性：任意两个相等的数据，排序前后的相对位置不发生改变<br>    没有一种排序是任何情况下都表现最好的。</p>
</blockquote>
<h5 id="冒泡排序——不要求"><a href="#冒泡排序——不要求" class="headerlink" title="冒泡排序——不要求"></a>冒泡排序——不要求</h5><pre><code>Bubble Sort,是一种最基础的交换排序
把相邻的元素两两比较，根据大小交换元素位子

原始的冒泡排序是稳定排序，由于冒泡排序每一轮要遍历所有元素，循环的次数和元素数组相当，所以时间复杂度为O(N^2)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Bubble_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    for(P=N-1; P&gt;=0; P--)&#123;</span><br><span class="line">        flag = 0;</span><br><span class="line">        for(i=0; i&lt;P; i++)&#123; // 一趟冒泡</span><br><span class="line">            if(A[i] &gt; A[i+1])&#123;</span><br><span class="line">                Swap(A[i], A[i+1]);</span><br><span class="line">                flag = 1; // 标识发生了交换</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(flag == 0) break; // 全程无交换</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

// 简单 稳定 两两交换
最好情况：顺序T = O(N)  
最坏情况：逆序T = O(N^2)</code></pre><h5 id="插入排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#插入排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="插入排序算法基本思想，算法代码及基本的时间复杂度分析"></a>插入排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<p>  扑克牌抓牌</p>
</blockquote>
<pre><code>就想玩牌一样，插入排序算法也是类似的思想：维护一个有序区，把元素一个一个插入到有序区的适当位置，直到所有元素有序位置，当我们把每一个新元素插入到有序区时，并不需要立马进行元素的两两交换，可以将待插入元素暂存起来，将有序区元素从左向右复制移动位置，找到带插入位置后，将元素插入。

mark first element as sorted 将第一个元素标记为已排序
for each unsorted element X 遍历每个没有排序过的元素
    &apos;extract&apos; the element X 提取元素X
    for j=lastSortedIndex down to 0   j 从最后一个被排序的位置开始到0进行遍历
        if current element j &gt; X  如果当前排序过的元素j &gt; 提取过的元素
            move sorted element to the right by 1 将排序过的元素向右移一格
        break loop and insert X here. 否则插入提取的元素


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 从后往前比</span><br><span class="line">void Insertion_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    int P, i;</span><br><span class="line">    ElementType Tmp;</span><br><span class="line"></span><br><span class="line">    for(P=1; P&lt;N; P++)&#123;</span><br><span class="line">        Tmp = A[P]; // 摸下一张牌,取出末排序序列中的第一个元素</span><br><span class="line">        for(i=P; i&gt;0 &amp;&amp; A[i-1]&gt;Tmp; i--)</span><br><span class="line">            A[i] = A[i-1]; // 移出空位 依次与已排序序列中元素比较并右移</span><br><span class="line">        A[i] = Tmp; // 新牌落位 放进合适的位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

// 稳定
最好情况：顺序T = O(N)
最坏情况：逆序T = O(N^2)</code></pre><h5 id="希尔排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#希尔排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="希尔排序算法基本思想，算法代码及基本的时间复杂度分析"></a>希尔排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<p>  by Donald Shell<br><img src="/images/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="希尔排序"></p>
</blockquote>
<pre><code>怎样可以对插入排序算法做出优化呢？
- 在大多数元素已经有序的情况下，插入排序的工作量较小(因为不用频繁的进行比较和交换)
- 在元素数量较小的情况下，插入排序的工作量较小

我们怎么能让大部分元素有序，或者让元素数量减少呢？
不妨对原始数组进行一些预处理，使得原始数组的大部分元素变得有序，分组排序，以此对数组进行一定的粗略调整

分组跨度，被称为希尔排序的增量，增量的选择可以有很多种。

利用分组粗调的方式减少了直接插入排序的工作量，是的算法的时间复杂度低于O(N^2)

原始希尔排序 Dm = [N/2], Dk = [Dk+1/2]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Shell_sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    for(D=N/2; D&gt;0; D/=2)&#123; // 希尔增量系列</span><br><span class="line">        for(P=D; P&lt;N; P++)&#123; // 插入排序</span><br><span class="line">            Tmp = A[P];</span><br><span class="line">            for(i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D)</span><br><span class="line">                A[i] = A[i-D];</span><br><span class="line">            A[i] = Tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

最快情况： T = cita(N^2)

注意：增量元素不互质，则小增量可能根本不起作用
更多增量序列
- Hibbard增量序列 1, 3, 7, 15……
    Dk = 2^k - 1 相邻元素互质
    最坏情况：T = cita(N^3/2)
- Sedgewick增量序列 {1， 5， 9， 41， 109}
    —— 9*4^i-9*2^i+1 或4^i-3*2^i + 1
    最坏时间复杂度：cita(N^(4/3))

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void ShellSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 希尔排序 - 用Sedgewick增量序列 */</span><br><span class="line">    int Si, D, P, i;</span><br><span class="line">    ElementType Tmp;</span><br><span class="line">    /* 这里只列出一小部分增量 */</span><br><span class="line">    int Sedgewick[] = &#123;929, 505, 209, 109, 41, 19, 5, 1, 0&#125;;</span><br><span class="line">    </span><br><span class="line">    for ( Si=0; Sedgewick[Si]&gt;=N; Si++ ) </span><br><span class="line">        ; /* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span><br><span class="line"></span><br><span class="line">    for ( D=Sedgewick[Si]; D&gt;0; D=Sedgewick[++Si] )</span><br><span class="line">        for ( P=D; P&lt;N; P++ ) &#123; /* 插入排序*/</span><br><span class="line">            Tmp = A[P];</span><br><span class="line">            for ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )</span><br><span class="line">                A[i] = A[i-D];</span><br><span class="line">            A[i] = Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

希尔排序是不稳定排序，值相同的元素可能被调换位置</code></pre><h5 id="选择排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#选择排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="选择排序算法基本思想，算法代码及基本的时间复杂度分析"></a>选择排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
</blockquote>
<pre><code>冒泡排序，就是把每一个元素和下一个元素进行比较和交换，使得较大的元素像气泡一样向右侧移动这样一来，每一轮操作都可以把最大元素移动到最右侧，经过多轮操作，无序的数列称为了升序数列，冒泡排序有一个很大的弊端，就是元素交换次数太多了。频繁的数组元素交换意味着更多的内存读写操作，严重影响了代码运行效率

每一轮选出最小者直接交换到左侧的思路，就是选择排序的思路，这种排序的最大优势就是省去了多余的元素交换。

选择排序存在一个明显问题，就是不稳定性也就是说，当数列包含多个值相等的元素时，选择排序有可能打乱它们的原有顺序。

repeat (numOfElements - 1) times 重复(元素个数 - 1)次
set the first unsorted element as the minum 把第一个没有排序过的元素设置为最小值
for each of the unsorted elements 遍历每个没有排序过的元素
    if element &lt; currentMinimum 如果元素 &lt; 现在的最小值
        set element as new minimum 将此元素设置成为新的最小值
swap minimum with first unsorted position 将最小值和第一个没有排序过的位置交换

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Selection_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    for(i=0; i&lt;N; i++)&#123;</span><br><span class="line">        MinPosition = ScanForMin(A, i, N-1); // 从A[i]到A[N-1]中找最小元，并将其位置赋给MinPosition</span><br><span class="line">        Swap(A[i], A[MinPostion]); // 将末排序部分的最小元换到有序部分的最后位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

无论如何： T = cita(N^2)  如何快速找到最小元？ 这个地方用到了堆排序

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void Swap( ElementType *a, ElementType *b )</span><br><span class="line">&#123;</span><br><span class="line">    ElementType t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PercDown( ElementType A[], int p, int N )</span><br><span class="line">&#123;   /* 改编代码4.24的PercDown( MaxHeap H, int p )    */</span><br><span class="line">    /* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 */</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line"></span><br><span class="line">    X = A[p]; /* 取出根结点存放的值 */</span><br><span class="line">    for( Parent=p; (Parent*2+1)&lt;N; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * 2 + 1;</span><br><span class="line">        if( (Child!=N-1) &amp;&amp; (A[Child]&lt;A[Child+1]) )</span><br><span class="line">            Child++;  /* Child指向左右子结点的较大者 */</span><br><span class="line">        if( X &gt;= A[Child] ) break; /* 找到了合适位置 */</span><br><span class="line">        else  /* 下滤X */</span><br><span class="line">            A[Parent] = A[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    A[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapSort( ElementType A[], int N ) </span><br><span class="line">&#123; /* 堆排序 */</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    for ( i=N/2-1; i&gt;=0; i-- )/* 建立最大堆 */</span><br><span class="line">        PercDown( A, i, N );</span><br><span class="line">    </span><br><span class="line">    for ( i=N-1; i&gt;0; i-- ) &#123;</span><br><span class="line">        /* 删除最大堆顶 */</span><br><span class="line">        Swap( &amp;A[0], &amp;A[i] ); /* 见代码7.1 */</span><br><span class="line">        PercDown( A, 0, i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="快速排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#快速排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="快速排序算法基本思想，算法代码及基本的时间复杂度分析"></a>快速排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<pre><code>快速排序是从冒泡排序演变过来的算法，但是比冒泡排序要高效的多，所以叫做快速排序。快速排序之所以快速，是因为它使用了分治法。同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大元素移动到数列的另一边，从而把数列拆解成了两个部分。这种思想就叫做分治法。在分治法的思想下原数列在每一轮被拆解分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。</code></pre></blockquote>
<pre><code>**分而治之**</code></pre><p><img src="/images/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B.png" alt="分而治之"></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Quicksort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    if(N &lt; 2) return; // 如果只有一个元素，直接return</span><br><span class="line">    pivot = 从A[]中选一个元 // ？怎么选主元</span><br><span class="line">    将S = &#123; A[] \ pivot &#125; 分成2个独立子集：// ？怎么分子集</span><br><span class="line">        A1 = &#123; a∈S | a&lt;= pivot &#125; 和</span><br><span class="line">        A2 = &#123; a∈S | a&lt;= pivot &#125;;</span><br><span class="line"></span><br><span class="line">    A[] = Quicksort(A1, N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2, N2);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

什么是快速排序算法的最好的情况？
每次正好中分 =&gt; T(N) = O(NlogN)

平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是O(nlogn)

那么基准元素是如何选出呢？又如何把其他元素移动到基准元素的两端呢？
基准元素的选择，以及元素的移动，都是快速排序的核心问题。

**选主元**
-  最简单的方式是选择数列的第一个元素 令pivot = A[0]
        这种选择在绝大多数情况下是没问题的，但是假如有一个原本逆序或顺序的数列，期望排序成顺序序列，整个数列并没有被分成一半一半，每一轮仅仅确定了基准元素的位置，这种情况下数列第一个要么是最小值，要么是最大值，根本无法发挥分治法的优势，在这种极端情况下，快速排序需要进行N轮，时间复杂度化成了O(N^2)</code></pre><p><img src="/images/%E9%80%89%E4%B8%BB%E5%85%83.png" alt="选主元"></p>
<pre><code>-  可以不选择数列第一个元素，而是随机选择一个元素作为基准元素 rand()函数不便宜
        这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分，当然即使是随机选择基准元素，每次也有极小的几率选到数列的最大值或最小值，同样会影响分治的效果。
-   取头、中、尾的中位数
        例如 8、12、3的中位数就是8

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ElementType Median3(ElementType A[], int Left, int Right)</span><br><span class="line">&#123;</span><br><span class="line">    int Center = (Left + Right) / 2;</span><br><span class="line">    if(A[Left] &gt; A[Center])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Center]);</span><br><span class="line">    if(A[Left] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Left], &amp;A[Right]);</span><br><span class="line">    if(A[Center] &gt; A[Right])</span><br><span class="line">        Swap(&amp;A[Center], &amp;A[Right]);</span><br><span class="line">    // A[Left] &lt;= A[Center] &lt;= A[Right]</span><br><span class="line">    Swap(&amp;A[Center], &amp;A[Right - 1]); // 将pivot藏到右边</span><br><span class="line">    // 只需要考虑A[Left + 1]  …… A[Right - 2]</span><br><span class="line"></span><br><span class="line">    return A[Right - 1] ;// 返回pivot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**子集划分**</code></pre><p><img src="/images/%E5%AD%90%E9%9B%86%E5%88%92%E5%88%86.png" alt="子集划分"></p>
<pre><code>如果有元素正好等pivot怎么办？ 停下来交换

快速排序的问题：
    用递归
    对于小规模的数据(例如N不到100)可能还不如插入排序快


解决方案
    - 当递归的数据规模充分小，则停止递归，直接调用简单排序（例如插入排序）
    - 在程序中定义一个Cutoff的阈值


一次排序就会把主元放到正确的位置上，以后也不会移动，这也是快速排序快的原因

算法实现
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 快速排序</span><br><span class="line">ElementType Median3(ElementType A[], int Left, int Right)&#123;</span><br><span class="line">    int Center = (Left + Right) /2;</span><br><span class="line">    if(A[ left ] &gt; A[ Center ]) Swap(&amp;A[ Left ], &amp;A[ Center ]);</span><br><span class="line">    if(A[ left ] &gt; A[ Right ]) Swap(&amp;A[ Left ], &amp;A[ Right ]);</span><br><span class="line">    if(A[ Center ] &gt; A[ Right ]) Swap(&amp;A[ Center ], &amp;A[ Right ]);</span><br><span class="line">    // 此时A[ Left ] &lt; A[ Center ] &lt; A[ Right ]</span><br><span class="line">    Swap(&amp;A[ Center ], &amp;A[ Right-1 ]); // 将基准pivot藏到右边</span><br><span class="line">    // 只需要考虑A[Left + 1]...A[Right -2]</span><br><span class="line">    return A[Right - 1]; // 返回基准Pivot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Qsort(ElementType A[], int Left, int Right)&#123;</span><br><span class="line">    // 核心递归函数</span><br><span class="line">    int Pivot, Cutoff, Low, High;</span><br><span class="line">    if( Cutoff &lt;= Right - Left)&#123; // 阈值，如果序列元素充分多，做快速排序</span><br><span class="line">        Pivot = Median3(A, Left, Right); // 选主元 选基准</span><br><span class="line">        Low = Left; High = Right - 1; // 划分子集</span><br><span class="line">        while (1)&#123; // 将序列中比基准小的移动到基准的左边，大的移到右边</span><br><span class="line">            while (A[ ++Low ] &lt; Pivot) &#123; &#125;</span><br><span class="line">            while (A[ --Right ] &gt; Pivot) &#123; &#125;</span><br><span class="line">            if(Low &lt; High) Swap(&amp;A[Low], &amp;A[High]);</span><br><span class="line">            else break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 然后把pivot放到正确的位置,将基准换到正确的位置</span><br><span class="line">        Swap(&amp;A[Low], &amp;A[Right-1]); // 把藏到Right-1 上的主元换到A[i]上去</span><br><span class="line">        // 递归排序自集 主元在i的位置上</span><br><span class="line">        Qsort(A, Left, Low-1); // 递归解决左半子集</span><br><span class="line">        Qsort(A, Low+1, Right); // 递归解决右半子集</span><br><span class="line">    &#125; else &#123; // 否则做插入排序 数据太少用简单排序</span><br><span class="line">        Insertion_Sort(A+Lfet, Right-left+1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用一个壳套住 </span><br><span class="line">void QuickSort(ElementType A[], int N)</span><br><span class="line">&#123; // 统一接口</span><br><span class="line">    Qsort(A, 0, N-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="合并排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#合并排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="合并排序算法基本思想，算法代码及基本的时间复杂度分析"></a>合并排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<pre><code>每个小组内部先比较出先后顺序之后，小组之间会展开进一步的比较和排序，合并成一个大组；大组之间继续比较和排序，再合并成更大的组……最终，所有的元素合并成一个有序集合。</code></pre></blockquote>
<p><img src="/images/%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="合并排序"></p>
<pre><code>这个比较与合并的过程叫做归并，Merge

核心：有序子列的归并</code></pre><p><img src="/images/%E6%9C%89%E5%BA%8F%E5%AD%90%E5%88%97%E7%9A%84%E5%BD%92%E5%B9%B6.png" alt="有序子列的归并"></p>
<pre><code>如果两个子列一共有N个元素，则归并的时间复杂度是？ T(N) = O(N)



递归算法：

典型分而治之的应用

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序 —— 递归实现</span><br><span class="line">// L = 左边起始位置，R = 右边起始位置，RightEnd = 右边终点位置</span><br><span class="line">void Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">    // 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列</span><br><span class="line">    int LeftEnd， NumElements, Tmp;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    LeftEnd = R-1; // 左边终点位置 ，假设左右两列挨着</span><br><span class="line">    Tmp = L; // 有序序列的起始位置  存放结果的数组的初始位置</span><br><span class="line">    NumElements = RightEnd - L + 1;</span><br><span class="line"></span><br><span class="line">    // 归并过程</span><br><span class="line">    while(L&lt;=LeftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        if(A[L]&lt;= A[R])</span><br><span class="line">            TmpA[Tmp++] = A[L++]; // 将左边元素复制到TmpA</span><br><span class="line">        else</span><br><span class="line">            TmpA[Tmp++] = A[R++]; // 将右边的元素复制到TmpA</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(L&lt;= LeftEnd)</span><br><span class="line">        TmpA(Tmp++) = A[L++]; // 直接复制左边剩下的</span><br><span class="line">    while(R&lt;= RightEnd)</span><br><span class="line">        TmpA(Tmp++) = A[R++]; // 直接复制右边剩下的</span><br><span class="line"></span><br><span class="line">    // 此时TmpA为归并以后的结果，再将TmpA中的结果倒回到A里， 起始位置可能会有变化，从后往回倒，一共执行NumElements次</span><br><span class="line">    for(i=0; i&lt;NumElements; i++, RightEnd--)</span><br><span class="line">        A[RightEnd] = TmpA[RightEnd]; // 将有序的TmpA[]复制回A[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Msort(ElementType A[], ElementType TmpA[], int L, int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">    // A[] 待排数组 TmpA[] 临时数组 L 当前待排数组最左边位置 RightEnd当前待排数组最右边位置</span><br><span class="line">    // 核心递归排序函数</span><br><span class="line">    int Center; /// 记录中间位置，将待排数组一分为二</span><br><span class="line"></span><br><span class="line">    if(L &lt; RightEnd) &#123; // 当待排序列有元素的时候</span><br><span class="line">        Center = (L+RightEnd)/2;</span><br><span class="line">        Msort(A, TmpA, L, Center); // 递归解决左边</span><br><span class="line">        Msort(A, TmpA, Center+1, RightEnd); // 递归解决右边</span><br><span class="line">        Merge(A, TmpA, Center+1, RightEnd); // 合并两段有序序列</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSort(ElmentType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    // 归并排序</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line">    TmpA = (ElementType *)malloc(N*sizeof(ElementType)); // 这个时候的好处，临时数组只要创建和销毁一次</span><br><span class="line"></span><br><span class="line">    if(TmpA != NULL)&#123;</span><br><span class="line">        Msort(A, TmpA, 0, N-1);</span><br><span class="line">        free(TmpA);</span><br><span class="line">    &#125;</span><br><span class="line">    else printf(&quot;空间不足&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

T(N) = T(N/2) + T(N/2) + O(N) 
T(N) = O(NlogN)
稳定



非递归算法</code></pre><p><img src="/images/%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95.png" alt="非递归合并算法"></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序 —— 循环实现</span><br><span class="line"></span><br><span class="line">void Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">    // 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列</span><br><span class="line">    int LeftEnd， NumElements, Tmp;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    LeftEnd = R-1; // 左边终点位置 ，假设左右两列挨着</span><br><span class="line">    Tmp = L; // 有序序列的起始位置  存放结果的数组的初始位置</span><br><span class="line">    NumElements = RightEnd - L + 1;</span><br><span class="line"></span><br><span class="line">    // 归并过程</span><br><span class="line">    while(L&lt;=LeftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        if(A[L]&lt;= A[R])</span><br><span class="line">            TmpA[Tmp++] = A[L++]; // 将左边元素复制到TmpA</span><br><span class="line">        else</span><br><span class="line">            TmpA[Tmp++] = A[R++]; // 将右边的元素复制到TmpA</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(L&lt;= LeftEnd)</span><br><span class="line">        TmpA(Tmp++) = A[L++]; // 直接复制左边剩下的</span><br><span class="line">    while(R&lt;= RightEnd)</span><br><span class="line">        TmpA(Tmp++) = A[R++]; // 直接复制右边剩下的</span><br><span class="line"></span><br><span class="line">    &lt;!-- </span><br><span class="line">    // 非递归算法不用最后这步</span><br><span class="line">    // 此时TmpA为归并以后的结果，再将TmpA中的结果倒回到A里， 起始位置可能会有变化，从后往回倒，一共执行NumElements次 </span><br><span class="line">    for(i=0; i&lt;NumElements; i++, RightEnd--)</span><br><span class="line">        A[RightEnd] = TmpA[RightEnd]; // 将有序的TmpA[]复制回A[] </span><br><span class="line">    --&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这个是一趟的归并</span><br><span class="line">// N整个待排序列长度</span><br><span class="line">// Length = 当前有序子列的长度 Length在初始的时候是1，在执行的过程中lenght要加倍</span><br><span class="line">void Merge_pass(ElementType A[], ElementType TmpA[], int N, int length)</span><br><span class="line">&#123;   </span><br><span class="line">    // 两两归并相邻有序子列</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    for(i=0; i&lt;N-2*length; i+=2*length)  // i+=2*length 跳过两段去找下一对 结束条件保证把成对的处理完</span><br><span class="line">        Merge(A, TmpA, i, i+length, i+2*length-1);  // 这里的merge跟递归算法里的merge有点不一样，不做最后一步，不用将TmpA里的数据写回到A</span><br><span class="line">        // 从左到右一对一对的执行Merge i最左边位置， i+length跳过子列长度下一列的初始位置， i+2*length-1 下一段的终止位置</span><br><span class="line">    if(i+length &lt; N) // 说明最后不止一个子列，归并最后2个子列</span><br><span class="line">        Merge(A, TmpA. i, i+length, N-1); // 注意最后一个子列的结尾无论如何都是N-1</span><br><span class="line">    else // 最后只剩1个子列， 直接把剩下的A倒到TmpA里面去</span><br><span class="line">        for(j=i; j&lt;N; j++) TmpA[j] = A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">    int length;</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line"></span><br><span class="line">    length = 1; // 初始化子序列长度</span><br><span class="line">    TmpA = malloc(N * sizeof(ElementType)); // 申请一个临时数组跟原始数组等长的数组</span><br><span class="line">    if(TmpA != NULL)&#123;</span><br><span class="line">        while(length &lt; N)&#123;</span><br><span class="line">            Merge_pass(A, TmpA, N, length); // 一趟归并A将结果存在在TmpA中</span><br><span class="line">            length *= 2;</span><br><span class="line">            Merge_pass(TmpA, A, N, length); // 将归并后的结果TmpA倒回到A里</span><br><span class="line">            length *=2;</span><br><span class="line"></span><br><span class="line">            // 归并两次的原因，保证归并后的结果是存放在A里面的</span><br><span class="line">        &#125;</span><br><span class="line">        free(TmpA);</span><br><span class="line">    &#125;</span><br><span class="line">    else prinft(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

额外空间复杂度是 O(N)
T(N) = T(N/2) + T(N/2) + O(N) 
T(N) = O(NlogN)


Merge Sort是稳定的
主要用于外排，不用于内排</code></pre><h5 id="基数排序算法基本思想，算法代码及基本的时间复杂度分析"><a href="#基数排序算法基本思想，算法代码及基本的时间复杂度分析" class="headerlink" title="基数排序算法基本思想，算法代码及基本的时间复杂度分析"></a>基数排序算法基本思想，算法代码及基本的时间复杂度分析</h5><blockquote>
<p>  仅仅基于比较进行的排序下界O(NlogN)<br>    在介绍基数排序之间先介绍一下桶排序</p>
</blockquote>
<pre><code>【例】假设我们有N个学生，他们的成绩是0到100之间的整数(于是有M=101个不同的成绩值)。如何在线性时间内将学生按成绩排序？
设立101个桶
        0  1  2  ……        100
count  
101个空链表对应101个桶
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Bucket_Sort(ElementType A[], int N)&#123;</span><br><span class="line">    count[] 舒适化; // 舒适化101个桶</span><br><span class="line">    while (读入1个学生成绩grade)</span><br><span class="line">        将该生插入count[grade]链表;</span><br><span class="line">    // 输出</span><br><span class="line">    for(i=0; i&lt;M; i++)&#123; // 扫描每一个桶</span><br><span class="line">        if(count[i])</span><br><span class="line">            输出整个count[i]链表;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

T(N, M) = O(M+N)
如果M&gt;&gt;N,该怎么办？

【例】假设我们有N=10个整数，每个整数的值在0到999之间(于是有M=1000个不同的值)。还有可能在线性时间内排序吗？
这个时候就要用到基数排序了，为什么叫基数，基数就是进制的基数，我们在说2进制的数的时候基数就是2，8进制的时候基数就等于8，10进制基数就等于10。充分利用基数建桶

输入序列： 64 8 216 512 27 729 0 1 343 125
用“次位优先”(Least Significant Digit) LSD算法 看 216这个数， 个位6位最次位， 百位数2为最主位， 次位优先，先从比较次位个位开始

Bucket  0    1     2    3    4    5    6    7    8    9
// 第一趟排序，考虑个位数把它们放到相应的桶里去
Pass1   0    1   512  343   64   125  216  27    8   729
// 第二趟排序，考虑十位数把它们放到相应的桶里去
Pass2   0   512   125       343        64
        1   216    27
        8         729
// 第三趟排序，考虑上一次的结果，用链表串起来，然后考虑百位数放到相应的桶里去
Pass3   0   125   216  343       512       729
        1
        8
       27                              
       64
// 扫描每一个桶，然后把结果串到一个链表里
=》 0 1 8 27 64 125 216 343 512 729 整个数列就是有序的了</code></pre><p><img src="/images/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png" alt="基数排序"></p>
<pre><code>整个次位优先算法的时间复杂度是多少呢？
T = O(P(N+B)):
P: 排序趟数 logB
N：待排序个数
B：桶的个数
桶的个数跟N的个数相比大概是一个什么数量级；当桶的个数非常小的情况下，差不多是线性复杂度

【多关键字排序】 一副扑克牌是按2种关键字排序的
花色 面值 (花色为主关键字、面值为次关键字排序)</code></pre><p><img src="/images/%E5%9F%BA%E6%95%B0%E5%85%B3%E9%94%AE%E5%AD%97%E6%8E%92%E5%BA%8F.png" alt="基数关键字排序"></p>
<pre><code>=&gt; 用“主位优先”(Most Significant Digit) 排序：为花色建4个桶</code></pre><p><img src="/images/%E5%9F%BA%E6%95%B0%E5%85%B3%E9%94%AE%E5%AD%97%E6%8E%92%E5%BA%8F01.png" alt="基数关键字排序01"></p>
<pre><code>=&gt; 用“次位优先”(Least Significant Digit) 排序：为面值建13个桶</code></pre><p><img src="/images/%E5%9F%BA%E6%95%B0%E5%85%B3%E9%94%AE%E5%AD%97%E6%8E%92%E5%BA%8F02.png" alt="基数关键字排序02"><br>    将结果合并，然后再为花色建4个桶</p>
<pre><code>问题：LSD任何时候都比MSD快吗？

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/* 基数排序 - 次位优先 */</span><br><span class="line"></span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"></span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line"></span><br><span class="line">int GetDigit ( int X, int D )</span><br><span class="line">&#123; /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line">    </span><br><span class="line">    for (i=1; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X % Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LSDRadixSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 基数排序 - 次位优先 */</span><br><span class="line">    int D, Di, i;</span><br><span class="line">    Bucket B;</span><br><span class="line">    PtrToNode tmp, p, List = NULL; </span><br><span class="line">    </span><br><span class="line">    for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">        B[i].head = B[i].tail = NULL;</span><br><span class="line">    for (i=0; i&lt;N; i++) &#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">        tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">        tmp-&gt;key = A[i];</span><br><span class="line">        tmp-&gt;next = List;</span><br><span class="line">        List = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 下面开始排序 */ </span><br><span class="line">    for (D=1; D&lt;=MaxDigit; D++) &#123; /* 对数据的每一位循环处理 */</span><br><span class="line">        /* 下面是分配的过程 */</span><br><span class="line">        p = List;</span><br><span class="line">        while (p) &#123;</span><br><span class="line">            Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */</span><br><span class="line">            /* 从List中摘除 */</span><br><span class="line">            tmp = p; p = p-&gt;next;</span><br><span class="line">            /* 插入B[Di]号桶尾 */</span><br><span class="line">            tmp-&gt;next = NULL;</span><br><span class="line">            if (B[Di].head == NULL)</span><br><span class="line">                B[Di].head = B[Di].tail = tmp;</span><br><span class="line">            else &#123;</span><br><span class="line">                B[Di].tail-&gt;next = tmp;</span><br><span class="line">                B[Di].tail = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 下面是收集的过程 */</span><br><span class="line">        List = NULL; </span><br><span class="line">        for (Di=Radix-1; Di&gt;=0; Di--) &#123; /* 将每个桶的元素顺序收集入List */</span><br><span class="line">            if (B[Di].head) &#123; /* 如果桶不为空 */</span><br><span class="line">                /* 整桶插入List表头 */</span><br><span class="line">                B[Di].tail-&gt;next = List;</span><br><span class="line">                List = B[Di].head;</span><br><span class="line">                B[Di].head = B[Di].tail = NULL; /* 清空桶 */</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 将List倒入A[]并释放空间 */</span><br><span class="line">    for (i=0; i&lt;N; i++) &#123;</span><br><span class="line">        tmp = List;</span><br><span class="line">        List = List-&gt;next;</span><br><span class="line">        A[i] = tmp-&gt;key;</span><br><span class="line">        free(tmp);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/* 基数排序 - 主位优先 */</span><br><span class="line"></span><br><span class="line">/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */</span><br><span class="line"></span><br><span class="line">#define MaxDigit 4</span><br><span class="line">#define Radix 10</span><br><span class="line"></span><br><span class="line">/* 桶元素结点 */</span><br><span class="line">typedef struct Node *PtrToNode;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int key;</span><br><span class="line">    PtrToNode next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 桶头结点 */</span><br><span class="line">struct HeadNode &#123;</span><br><span class="line">    PtrToNode head, tail;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct HeadNode Bucket[Radix];</span><br><span class="line"></span><br><span class="line">int GetDigit ( int X, int D )</span><br><span class="line">&#123; /* 默认次位D=1, 主位D&lt;=MaxDigit */</span><br><span class="line">    int d, i;</span><br><span class="line">    </span><br><span class="line">    for (i=1; i&lt;=D; i++) &#123;</span><br><span class="line">        d = X%Radix;</span><br><span class="line">        X /= Radix;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MSD( ElementType A[], int L, int R, int D )</span><br><span class="line">&#123; /* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */</span><br><span class="line">    int Di, i, j;</span><br><span class="line">    Bucket B;</span><br><span class="line">    PtrToNode tmp, p, List = NULL; </span><br><span class="line">    if (D==0) return; /* 递归终止条件 */</span><br><span class="line">    </span><br><span class="line">    for (i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */</span><br><span class="line">        B[i].head = B[i].tail = NULL;</span><br><span class="line">    for (i=L; i&lt;=R; i++) &#123; /* 将原始序列逆序存入初始链表List */</span><br><span class="line">        tmp = (PtrToNode)malloc(sizeof(struct Node));</span><br><span class="line">        tmp-&gt;key = A[i];</span><br><span class="line">        tmp-&gt;next = List;</span><br><span class="line">        List = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 下面是分配的过程 */</span><br><span class="line">    p = List;</span><br><span class="line">    while (p) &#123;</span><br><span class="line">        Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */</span><br><span class="line">        /* 从List中摘除 */</span><br><span class="line">        tmp = p; p = p-&gt;next;</span><br><span class="line">        /* 插入B[Di]号桶 */</span><br><span class="line">        if (B[Di].head == NULL) B[Di].tail = tmp;</span><br><span class="line">        tmp-&gt;next = B[Di].head;</span><br><span class="line">        B[Di].head = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 下面是收集的过程 */</span><br><span class="line">    i = j = L; /* i, j记录当前要处理的A[]的左右端下标 */</span><br><span class="line">    for (Di=0; Di&lt;Radix; Di++) &#123; /* 对于每个桶 */</span><br><span class="line">        if (B[Di].head) &#123; /* 将非空的桶整桶倒入A[], 递归排序 */</span><br><span class="line">            p = B[Di].head;</span><br><span class="line">            while (p) &#123;</span><br><span class="line">                tmp = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                A[j++] = tmp-&gt;key;</span><br><span class="line">                free(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            /* 递归对该桶数据排序, 位数减1 */</span><br><span class="line">            MSD(A, i, j-1, D-1);</span><br><span class="line">            i = j; /* 为下一个桶对应的A[]左端 */</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MSDRadixSort( ElementType A[], int N )</span><br><span class="line">&#123; /* 统一接口 */</span><br><span class="line">    MSD(A, 0, N-1, MaxDigit); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png" alt="排序算法比较"></p>
<h4 id="五、图"><a href="#五、图" class="headerlink" title="五、图"></a>五、图</h4><blockquote>
<p>  内容：<br>        图的基本概念<br>        图的存储结构<br>            - 邻接矩阵<br>            - 邻接表<br>        图的遍历<br>            - 广度优先遍历<br>            - 深度优先遍历；<br>        最小生成树基本概念<br>            - Prim算法<br>            - Kruskal算法<br>        最短路径问题<br>            - 广度优先遍历算法<br>            - Dijkstra算法<br>            - Floyd算法；<br>        拓扑排序</p>
</blockquote>
<h5 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h5><p><img src="/images/%E5%9B%BE%E7%9A%84%E5%BC%95%E4%BE%8B.png" alt="图的引例"><br>    从陈家村到张家村，怎么走最快呢？ 图最经典的最短路径问题<br>    怎么修公路使的村村通的花费最少呢？ 图最经典的最小生成树问题<br>    边可以理解为一种关系<br><img src="/images/%E5%9C%B0%E9%93%81%E7%BA%BF%E8%B7%AF.png" alt="地铁线路"></p>
<pre><code>什么是“图”(Graph)
    - 表示“多对多”的关系 【包含线性表和树的关系】
    - 包含
        - 一组顶点：通常用V(Vertex)表示顶点集合
        - 一组边：通常用E(Edge)表示边的集合
            - 边是顶点对：(v,w) ∈ E，其中v,w ∈ V    v —— w 双向 圆括号表示
            - 有向边&lt;v,w&gt;表示从v指向w的边(单行边)    v ——&gt; w 单向 尖括号表示
            - 不考虑重边和自回路   </code></pre><p><img src="/images/%E9%87%8D%E8%BE%B9%E5%92%8C%E8%87%AA%E5%9B%9E%E8%B7%AF.png" alt="重边和自回路"></p>
<pre><code>抽象数据类型定义 ADT
- 类型名称： 图 (Graph)
- 数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成
- 操作集：对于任意图G ∈ Graph，以及v ∈ V，e ∈ E
    - Graph Create(): 建立并返回空图
    - Graph InsertVertex(Graph G, Vertex v): 将v插入G
    - Graph InsertEdge(Graph G, Edge e): 将e插入G
    - void DFS(Graph G, Vertex v): 从顶点v出发深度优先遍历图G
    - void BFS(Graph G, Vertex v): 从顶点v出发广度优先遍历图G
    - void ShortestPath(Graph G, Vertex v, int Dist[]): 计算图G中顶点v到任意其他顶点的最短距离
    - void MST(Graph G): 计算图G的最小生成树
    ……</code></pre><p><img src="/images/%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%89%E5%90%91%E5%9B%BE.png" alt="无向图有向图"><br>    如果图中所有边无所谓反向，称为无向图<br>    图中边有可能双向有可能单向，称为有向图<br>    边上有数字，叫权重，权重可以赋予现实中的各种意义，带权重的图叫网络</p>
<h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h5><blockquote>
<p>  怎么在程序中表示一个图，以下不止邻接矩阵和邻接表两种方法，还可以有别的方法。</p>
</blockquote>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><blockquote>
<p>  邻接矩阵G[N][N]——N个顶点从0到N-1编号<br>        G[i][j] = {  1   若&lt;vi, vj&gt;是G中的边<br>                    0   否则               }</p>
</blockquote>
<p><img src="/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="邻接矩阵"></p>
<pre><code>    不允许自回路边，所以对角线全为0, 对称阵，其实有一条边存了两次，显然浪费空间


邻接矩阵
    - 问题：对于无向图的存储，怎样可以省一半空间?
        只存下三角，用一维元素</code></pre><p><img src="/images/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%97%A0%E5%90%91%E5%9B%BE.png" alt="邻接矩阵无向图"><br>    问题：Vi和Vj之间若没有边怎么办？</p>
<pre><code>邻接矩阵 —— 有什么好处？
- 直观、简单、好理解
- 方便检查任意一对顶点间是否存在边
- 方便找任一顶点的所有“邻接点”（有边直接相连的顶点）
- 方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数为“入度”）
    · 无向图：对应行(或列)非0元素的个数
    · 有向图：对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度”
邻接矩阵 —— 有什么不好？
- 浪费空间 —— 存稀疏图（点很多而边很少）有大量无效元素
    · 对稠密图(特别是完全图)还是很合算的
- 浪费时间 —— 统计稀疏图中一共有多少条边

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// 大纲没有要求，可以看看，有对图有编码的感觉</span><br><span class="line">/* 图的邻接矩阵表示法 */</span><br><span class="line">#define MaxVertexNum 100  /* 最大顶点数设为100*/</span><br><span class="line">#define INFINITY 65535  /* ∞设为双字节无符号整数的最大值65535*/</span><br><span class="line">typedef int Vertex;  /* 用顶点下标表示顶点，为整型*/</span><br><span class="line">typedef int WeightType;  /* 边的权值设为整型 */ </span><br><span class="line">typedef char DataType;  /*  顶点存储的数据类型设为字符型 */</span><br><span class="line"></span><br><span class="line">/* 边的定义*/</span><br><span class="line">typedef struct ENode *PtrToENode; // 指向边结点的指针</span><br><span class="line">struct ENode &#123;</span><br><span class="line">    Vertex V1, V2; // 有向边&lt;V1, V2&gt; 两个顶点</span><br><span class="line">    WeightType Weight; // 权重</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToENode Edge;</span><br><span class="line"></span><br><span class="line">/*图结点的定义*/</span><br><span class="line">typedef struct GNode *PtoToGNode; // 指向结点的指针</span><br><span class="line">struct GNode &#123;</span><br><span class="line">    int Nv; // 顶点数</span><br><span class="line">    int Ne; // 边数</span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum]; // 邻接矩阵  定义二维数组</span><br><span class="line">    DataType Data[MaxVertexNum];  // 存顶点的数据</span><br><span class="line">    // 在很多情况下，顶点无数据，此时Data[]可以不用出现</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToNode MGraph; // 以邻接矩阵存储的图类型</span><br><span class="line"></span><br><span class="line">// 初始化一个有VertexNum个顶点但没有边的图</span><br><span class="line">MGraph CreateGraph(int VertexNum)&#123;</span><br><span class="line">    Vertex V, W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = (MGraph)malloc(sizeof(struct GNode)); // 建立图</span><br><span class="line">    Graph -&gt; Nv = VertexNum;</span><br><span class="line">    Graph -&gt; Ne = 0;</span><br><span class="line">    // 初始化邻接矩阵</span><br><span class="line">    // 注意：这里默认顶点编号从0开始，到(Graph -&gt; Nv - 1)</span><br><span class="line">    for(V=0; V &lt; Graph-&gt;Nv, V++)</span><br><span class="line">        for(W=0; W &lt; Graph-&gt;Nv; W++)</span><br><span class="line">            Graph-&gt;G[V][W] = INFNITY; //或“0” 表示没有变</span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 向MGraph中插入边</span><br><span class="line">void InsertEdge(MGraph Graph, Edge E)&#123;</span><br><span class="line">    // 插入边&lt;V1, V2&gt;</span><br><span class="line">    Graph -&gt; G[E-&gt;V1][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">    // 若是无向图，还要插入边&lt;V2, V1&gt;</span><br><span class="line">    Graph -&gt; G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 完整地建立一个MGraph</span><br><span class="line">// - 输入格式：Nv Ne</span><br><span class="line">// V1 V2 Weight</span><br><span class="line">MGraph BuildGraph()&#123;</span><br><span class="line">    // 声明临时变量</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    int Nv, i;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv); // 读入顶点个数</span><br><span class="line">    Graph = CreateGraph(Nv); // 初始化有Nv个顶点 但没有边的图</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne)); // 读入边数</span><br><span class="line">    if( Graph -&gt; Ne != 0)&#123; // 如果Ne为零，表示读进来的边数，就是没有一条边，就可以直接退出</span><br><span class="line">        E = (Edge) malloc (sizeof(struct ENode)); // 建立临时边结点，去存读入的边</span><br><span class="line">        // 读入边，格式为“起点 终点 权重”，插入邻接矩阵</span><br><span class="line">        for(i=0; i&lt;Graph-&gt;Ne;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">            // 注意：如果权重不是整型，Weight的读入格式要改</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果顶点有数据的话，读入数据</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        scanf(&quot;%c&quot;, &amp;(Graph-&gt;Data[V]));</span><br><span class="line"></span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 简短一点写，核心代码可简化为</span><br><span class="line">int G[MAXN][MAXN], Nv, Ne;</span><br><span class="line">void BuildGraph()&#123;</span><br><span class="line">    int i, j, v1, v2, w;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv);</span><br><span class="line">    // CreateGraph</span><br><span class="line">    for(i=0; i&lt;Nv; i++&gt;)</span><br><span class="line">        for(j=0; j&lt;Nv; j++&gt;)</span><br><span class="line">            G[i][j] = 0; // 或INFINITY</span><br><span class="line">            </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Ne);</span><br><span class="line">    for(i=0; i&lt;Ne; i++)&#123;</span><br><span class="line">        scanf(&quot;%d %d %d&quot;, &amp;v1, &amp;v2, &amp;w);</span><br><span class="line">        // InsertEdge</span><br><span class="line">        G[v1][v2] = w;</span><br><span class="line">        G[v2][v1] = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><blockquote>
<p>  怎么在程序中表示一个图的另一种表示法 —— 邻接表<br>    邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素<br>    <strong>对于网络，结构中要增加权值的域</strong><br>    为每一个结点开一个指针，指针数组，数组的元素是头指针</p>
</blockquote>
<p><img src="/images/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="邻接表"></p>
<pre><code>邻接表的表示不唯一，链表的顺序不唯一
无向边被存了两遍

邻接表一定要够稀疏才够合算

邻接表的好处？
- 方便还找任一顶点的所有“邻接点”
- 节约稀疏图的空间
    -   需要N个头只在指针 + 2E个结点（每个结点至少2个域）
- 方便计算任一顶点的“度”？
    - 对无向图：是的
    - 对有向图：只能计算“出度”;需要构造“逆邻接表”（存指向自己的边）来方便计算&quot;入度&quot;
- 方便检查任意一对顶点间是否存在边？
    NO

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">// 大纲没有要求，可以看看，有点对图有编码的感觉</span><br><span class="line">// 图的邻接表表示法</span><br><span class="line">#define MaxVertexNum 100 //最大顶点数设为100</span><br><span class="line">typedef int Vertex; // 用顶点下标表示顶点，为整型</span><br><span class="line">typedef int WeightType; // 边的权值设为整型</span><br><span class="line">typedef char DataType; // 顶点存储的数据类型设为字符型</span><br><span class="line"></span><br><span class="line">// 边的定义</span><br><span class="line">typedef struct ENode *PtrToENode;</span><br><span class="line">struct ENode &#123;</span><br><span class="line">    int Nv; // 顶点数</span><br><span class="line">    int Ne; // 边数</span><br><span class="line">    AdjList G; // 邻接表</span><br><span class="line">&#125;;</span><br><span class="line">typedef PtrToGNode LGraph;</span><br><span class="line">// 以邻接表方式存储图的类型</span><br><span class="line"></span><br><span class="line">// 邻接点的定义</span><br><span class="line">typedef struct AdjVNode *PtrToAdjVNode;</span><br><span class="line">struct AdjNode&#123;</span><br><span class="line">    Vertex AdjV; // 邻接点下标</span><br><span class="line">    WeightType Weight; // 边权重</span><br><span class="line">    PtrToAdjVNode Next; // 指向下一个邻接点的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 顶点表头结点的定义</span><br><span class="line">typedef struct Vnode&#123;</span><br><span class="line">    PtrToAdjVNode FirstEdge; // 边表有指针</span><br><span class="line">    DataType Data; // 存顶点的数据</span><br><span class="line">    // 注意：很多情况下，顶点无数据，此时Data可以不用出现</span><br><span class="line">&#125; AdjList[MaxVertexNum]; // AdjList是邻接表类型</span><br><span class="line"></span><br><span class="line">// 图结点的定义</span><br><span class="line">typedef struct GNode *PtrToGNode;</span><br><span class="line">struct GNode &#123;</span><br><span class="line">    int Nv; // 顶点数</span><br><span class="line">    int Ne; // 边数</span><br><span class="line">    AdjList G; // 邻接表</span><br><span class="line">&#125;</span><br><span class="line">typedef PtrToGNode LGraph; // 以邻接表方式存储的图类型</span><br><span class="line"></span><br><span class="line">// LGraph初始化 初始化一个有VertexNum个顶点但没有变的图</span><br><span class="line">typedef int Vertex; // 用顶点下标表示顶点，为整型</span><br><span class="line">LGraph CreateGraph(int VertexNum)&#123;</span><br><span class="line">    // 初始化一个有VertexNum个顶点但没有边的图</span><br><span class="line">    Vertex V;</span><br><span class="line">    LGraph Graph;</span><br><span class="line"></span><br><span class="line">    Graph = (LGraph)malloc(sizeof(struct GNode)); // 建立图</span><br><span class="line">    Graph-&gt;Nv = VertexnNum;</span><br><span class="line">    Graph-&gt;Ne = 0;</span><br><span class="line">    // 初始化邻接表头指针</span><br><span class="line">    // 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1)</span><br><span class="line">        for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">            Graph-&gt;G[V].FristEdge = NULL;</span><br><span class="line"></span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//向LGraph中插入边， 顶点插入链表中，插入头部</span><br><span class="line">void InsertEdge(LGraph Graph, Edge E)&#123;</span><br><span class="line">    PtrToAdjVNode NewNode;</span><br><span class="line"></span><br><span class="line">    // 插入边&lt;V1, V2&gt;</span><br><span class="line">    // 为V2建立新的邻接点</span><br><span class="line">    NewNode = (PtrToAdjNode)malloc(sizeof(struct AdjVNode));</span><br><span class="line">    NewNode -&gt; AdjV = E-&gt;V2;</span><br><span class="line">    NewNode -&gt; Weight = E-&gt;Weight;</span><br><span class="line"></span><br><span class="line">    // 将V2插入V1的表头</span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FristEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class="line"></span><br><span class="line">    // 若是无向图，还要插入边&lt;V2, V1&gt;</span><br><span class="line">    // 为V1建立新的邻接点</span><br><span class="line">    NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));</span><br><span class="line">    NewNode -&gt; AdjV = E-&gt; V1;</span><br><span class="line">    NewNode -&gt; Weight = E-&gt; Weight;</span><br><span class="line">    // 将V1插入V2的表的头</span><br><span class="line">    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FristEdge;</span><br><span class="line">    Graph-&gt;G[E-&gt;V2].FristEdge = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 完整地建立一个LGraph</span><br><span class="line">LGraph BuildGraph()&#123;</span><br><span class="line">    LGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    int Nv, i;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;Nv); // 读入顶点个数</span><br><span class="line">    Graph = CreateGraph(Nv); // 初始化有Nv个顶点但没有边的图</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne)); // 读入边数</span><br><span class="line">    if(Graph-&gt;Ne != 0)&#123; // 如果有边</span><br><span class="line">        E = (Edge)malloc(sizeof(struct ENode)); // 建立边结点</span><br><span class="line">        // 读入边，格式为“起点，终点， 权重”，插入邻接矩阵</span><br><span class="line">        for(i=0; i&lt;Graph-&gt;Ne; i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V2, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">            // 注意：如果权重不是整型，Weight的读入格式要改</span><br><span class="line">            InsertEdge(Graph, E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果顶点有数据的话，读入数据</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        scanf(&quot;%c&quot;, &amp;(Graph-&gt;G[V].Data));</span><br><span class="line">    return Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><blockquote>
<p>  把图中的每个顶点访问一遍，不可重复访问。<br>    那为什么要做图遍历呢？可以解决很多问题</p>
</blockquote>
<pre><code>为什么需要两种遍历？
图不连通怎么办？

连通：如果从v到w存在一条(无向)路径，则称v和w是连通的
路径：v到w的路径是一系列顶点{V, v1, v2,……, vn, W}的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数(如果带权，则是所有边的权重和)。如果v到w之间的所有顶点都不同，则称简单路径。
回路：起点等于终点的路径， 图中有回路，则不是简单路径
连通图：图中任意两顶点均连通


图不连通怎么办？
无向图：
    连通分量：无向图的极大连通子图
    极大顶点数：再加1个顶点就不连通了
    极大边数：包含子图中所有顶点相连的所有边
有向图:
    强连通：有向图中顶点v和w之间存在双向路径，则称v和w是强连通的
    强连通图：有向图中任意两顶点均强连通
    强连通分量：有向图的极大强连通子图</code></pre><h6 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h6><blockquote>
<p>  Breadth First Search, BFS<br>    一层一层的访问结点<br>    程序实现，借用队列<br>    类似层序遍历<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void BFS(Vertex V)&#123;</span><br><span class="line">    visited[V] = true;</span><br><span class="line">    Enqueue(V, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        for(V的每个邻接点W)</span><br><span class="line">            visited[W] = true;</span><br><span class="line">            Enqueue(W, Q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>若有N个顶点、E条边，时间复杂度是
* 用邻接表存储图，有O(N+E)
* 用邻接矩阵存储图，有O(N^2)</code></pre><h6 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h6><blockquote>
<p>  Depth First Search, DFS<br>    类似于树的<strong>先序遍历</strong><br>    访问完结点一定要原路返回，原路返回，对应堆栈出栈<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Vertex V)&#123;</span><br><span class="line">    visited[V] = true;</span><br><span class="line">    for(V的每个邻接点W)</span><br><span class="line">        if(!visited[W])</span><br><span class="line">            DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>若有N个顶点，E条边，时间复杂度是
* 用邻接表存储图，有O(N+E)
* 用邻接矩阵存储图，有O(N^2)</code></pre><h5 id="最小生成树-Minimum-Spanning-Tree"><a href="#最小生成树-Minimum-Spanning-Tree" class="headerlink" title="最小生成树 (Minimum Spanning Tree)"></a>最小生成树 (Minimum Spanning Tree)</h5><blockquote>
<p>最小生成树存在 &lt;==&gt; 图连通, 最少边，花费最少<br>    - 是一颗树<br>      无回路<br>      |V|个顶点一定有|V|-1条边<br>    - 是生成树<br>      包含全部顶点<br>      |V|-1条边都在图里<br>    - 边的权重和最小</p>
</blockquote>
<pre><code>(向生成树中任加一条边都一定构成回路)</code></pre><h6 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h6><blockquote>
<p>有两种 Prim算法 和 Kruskal算法</p>
<ul>
<li>什么是“贪”：每一步都要最好的</li>
<li>什么是“好”：权重最小的边</li>
<li>需要约束：<pre><code>- 只能用图里有的边
- 只能正好用掉|V|-1条边
- 不能有回路</code></pre></li>
</ul>
</blockquote>
<p>####### Prim算法</p>
<blockquote>
<p>让一颗小树长大 – 有点像Dijkstra算法<br><img src="/images/Prim%E7%AE%97%E6%B3%95.png" alt="Prim算法"><br>    Prim Dijkstra算法对比：<br><img src="/images/Prim_Dijkstra.png" alt="Prim_Dijkstra算法对比"></p>
</blockquote>
<pre><code>Prim算法里的dist， 当前顶点与最小生成树中收录所有顶点的最短距离，V，将V收录进最小生成树MST，此时结点到最小生成树的距离dist[V] = 0;
最小生成树里的树怎么存呢？ 对每个顶点存 parent[S] = -1 (父结点的编号)，此处为根结点
dist[V] = E&lt;S, V&gt; 或 正无穷
T = O(|V|^2)---稠密图合算</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/* 邻接矩阵存储 - Prim最小生成树算法*/</span><br><span class="line">Vertex FindMinDist(MGraph Graph, WeightType dist[])</span><br><span class="line">&#123;</span><br><span class="line">    // 返回未被收录顶点中dist最小者</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    WeightType MinDist = INFINITY; // 无穷大</span><br><span class="line"></span><br><span class="line">    for(V=0; V&lt;Graph-&gt; Nv; V++)&#123;</span><br><span class="line">        if(dist[V] != 0 &amp;&amp; dist[V] &lt; MinDist)&#123;</span><br><span class="line">            // 若V未被收录，且dist[V]更小</span><br><span class="line">            MinDist = dist[V]; // 更新最小距离</span><br><span class="line">            MinV = V; // 更新对应顶点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(MinDist &lt; INFINITY) // 若找到最小dist</span><br><span class="line">        return MinV; // 返回对应的顶点下标</span><br><span class="line">    else retuen ERROR; // 若这样的顶点不存在，返回-1作为标记</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Prim(MGraph Graph, LGraph MST)</span><br><span class="line">&#123;</span><br><span class="line">    // 将最小生成树保存为邻接表存储的图MST， 返回最小权重和</span><br><span class="line">    WeightType dist[MaxVertexNum], TotalWeight;</span><br><span class="line">    Vertex parent[MaxVertexNum], V, W;</span><br><span class="line">    int VCount;</span><br><span class="line">    Edge E;</span><br><span class="line"></span><br><span class="line">    // 初始化，默认初始点下标为0</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)&#123;</span><br><span class="line">        // 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY</span><br><span class="line">        dist[V] = Graph -&gt; G[0][V];</span><br><span class="line">        parent[V] = 0; // 暂且定义所有顶点的父结点都是初始点0</span><br><span class="line">    &#125;</span><br><span class="line">    TotalWeight = 0; // 初始化权重和</span><br><span class="line">    VCount = 0; // 初始化收录的顶点数</span><br><span class="line">    // 创建包含所有顶点但没有边的图，注意用邻接表版本</span><br><span class="line">    MST = CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    E = (Edge)malloc(sizeof(struct ENode)); // 建立空的边结点</span><br><span class="line"></span><br><span class="line">    // 将初始点0收录进MST</span><br><span class="line">    dist[0] = 0;</span><br><span class="line">    VCount ++;</span><br><span class="line">    parent[0] = -1; // 当前树根是0</span><br><span class="line"></span><br><span class="line">    while(1)&#123;</span><br><span class="line">        V = FindMinDist(Graph, dist);</span><br><span class="line">        // V = 未被收录点中dist最小者</span><br><span class="line">        if(V == ERROR) // 若这样的V不存在</span><br><span class="line">            break; // 算法结束</span><br><span class="line">        // 将V及相应的边&lt;parent[V], V&gt;收录进MST</span><br><span class="line">        E-&gt; V1 = parent[V];</span><br><span class="line">        E-&gt; V2 = V;</span><br><span class="line">        E-&gt; Weight = dist[V];</span><br><span class="line">        InsertEdge(MST. E);</span><br><span class="line">        TotalWeigt += dist[V];</span><br><span class="line">        dist[V] = 0;</span><br><span class="line">        VCount++;</span><br><span class="line"></span><br><span class="line">        for(w=0; w&lt;Graph-&gt;Nv; w++) // 对图中的每个顶点w</span><br><span class="line">            if(dist[w]！=0 &amp;&amp; Graph-&gt; G[V][W]&lt;INFINITY) &#123;</span><br><span class="line">                // 若w是v的邻接点并且未被收录</span><br><span class="line">                    if(Graph-&gt;G[V][W] &lt; dist[W])&#123;</span><br><span class="line">                        // 若收录V使得dist[W]变小</span><br><span class="line">                        dist[W] = Graph-&gt;G[V][W]; // 更新dist[W]</span><br><span class="line">                        parent[W] = V; // 更新树</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; // while结束</span><br><span class="line">    if(VCount &lt; Graph-&gt;Nv) // MST中收的顶点不到|V|个</span><br><span class="line">        TotalWeight = ERROR;</span><br><span class="line">    return TotalWeight; // 算法执行完毕，但会最小权重和或错误标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####### Kruskal算法 </p>
<blockquote>
<p>将森林合并成树–稀疏图合算， 很多结点，边的条数比较少<br>    默认每个结点都是一棵树，然后通过不断的收录最小权重的边，合并树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 伪码</span><br><span class="line">void Kruskal (Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    MST = &#123;&#125;; // 这里收录的是边，不是顶点， 一开始是空集</span><br><span class="line">    while ( MST中不到|V| - 1条边 &amp;&amp; E中还有边)&#123;</span><br><span class="line">        从E中取一条权重最小的边E&lt;V, W&gt;; // 从边集中取，怎么取？ **最小堆**</span><br><span class="line">        将E&lt;V, W&gt;从E中删除;</span><br><span class="line">        if (E&lt;v, w&gt;不在MST中构成回路) // 怎么知道有没有构成回路？ **并查集**， 边的两个顶点在不同的集合</span><br><span class="line">            将E&lt;v, w&gt;加入MST</span><br><span class="line">        else</span><br><span class="line">            彻底无视 E&lt;v, w&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    // MST中还没收满 循环已经跳出来了，E中没有边了</span><br><span class="line">    if (MST 中不到|V| - 1 条边)</span><br><span class="line">        Error(&quot;生成树不存在&quot;); // 原图不连通</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>T = O(|E|log|E|)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">/* 邻接表存储 - Kruskal最小生成树算法*/</span><br><span class="line">/* ------------------------顶点并查集-------------------*/</span><br><span class="line">typedef Vertex ElementType; // 默认元素可以用非负整数表示</span><br><span class="line">typedef Vertex SetName; // 默认用根结点的下标作为集合名称</span><br><span class="line">typedef ElementType SetType[MaxVertexNum]; // 假设集合元素下标从0开始</span><br><span class="line"></span><br><span class="line">void InitializeVSet(SetType S, int N)&#123;</span><br><span class="line">    // 初始化并查集</span><br><span class="line">    ElementType X;</span><br><span class="line">    for(X=0; X&lt;N; X++) S[X] = -1;</span><br><span class="line">&#125;</span><br><span class="line">void Union(SetType S, SetName Root1, SetName Root2)</span><br><span class="line">&#123;</span><br><span class="line">    // 这里默认Root1和Root2是不同集合的根结点</span><br><span class="line">    // 保证小集合并入大集合</span><br><span class="line">    if(S[Root2] &lt; S[Root1]) &#123; // 如果集合2比较大</span><br><span class="line">        S[Root2] += S[Root1]; // 集合1并入集合2</span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        S[Root1] += S[Root2];</span><br><span class="line">        S[Roots1] = Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SetName Find(SetType S, ElementType X)</span><br><span class="line">&#123;</span><br><span class="line">    // 默认集合元素全部初始化为-1</span><br><span class="line">    if( S[X] &lt; 0) // 找到集合的根</span><br><span class="line">        return X;</span><br><span class="line">    else </span><br><span class="line">        return S[X] = Find( S, S[X]); // 路径压缩</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CheckCycle(SetType VSet, Vertex V1, Vertex V2)</span><br><span class="line">&#123;</span><br><span class="line">    // 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路</span><br><span class="line">    Vertex Root1, Root2;</span><br><span class="line"></span><br><span class="line">    Root1 = Find(VSet, V1); // 得到V1所属的连通集名称</span><br><span class="line">    Root2 = Find(VSet, V2); // 得到V2所属的连通集名称</span><br><span class="line"></span><br><span class="line">    if(Root1 == Root2) // 若V1和V2已经连通，则该边不能要</span><br><span class="line">        return false;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 否则该边可以被收集，同时将V1和V2并入同一连通集</span><br><span class="line">        Union(VSet, Root1, Root2);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*-----------------------并查集定义结束--------------------------------*/</span><br><span class="line">/*-----------------------边的最小堆定义--------------------------------*/</span><br><span class="line">void PercDown(Edge ESet, int p, int N)</span><br><span class="line">&#123;</span><br><span class="line">    // 将N个元素的边数组中国已ESet[p]为根的子堆调整为关于Weight的最小堆</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    struct ENode X;</span><br><span class="line"></span><br><span class="line">    X = ESet[p]; // 取出根结点存放的值</span><br><span class="line">    for(Parent=p; (Parent*2 + 1) &lt; N; Parent=Child)&#123;</span><br><span class="line">        Child = Parent*2 + 1;</span><br><span class="line">        if((Child!=N-1) &amp;&amp; (ESet[Child].Weight &gt; ESet[Child+1].Weight))</span><br><span class="line">            Child++; // Child指向左右子结点的较小者</span><br><span class="line">        if(X.Weight &lt;= ESet[Child].Weight) break; // 找到了合适位置</span><br><span class="line">        else // 下滤X</span><br><span class="line">            ESet[Parent] = ESet[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    ESet[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitializeESet(LGraph Graph, Edge ESet)&#123;</span><br><span class="line">    // 将图的边存入数组Set， 并且初始化为最小堆</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    int ECount;</span><br><span class="line"></span><br><span class="line">    // 将图的边存入数组ESet</span><br><span class="line">    ECount = 0;</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)</span><br><span class="line">        for(W=Graph-&gt;G[V].FristEdge; W; W=W-&gt;Next)</span><br><span class="line">            if(V&lt;W-&gt;AdjV) &#123; // 避免重复录入无向图的边，之手V1&lt;V2的边</span><br><span class="line">                ESet[ECount].V1 = V;</span><br><span class="line">                ESet[ECount].V2 = W-&gt;AdjV;</span><br><span class="line">                ESet[Ecount++].Weight = W-&gt;Weight;</span><br><span class="line">            &#125;</span><br><span class="line">    // 初始化为最小堆</span><br><span class="line">    for(ECount=Graph-&gt;Ne/2; ECount&gt;=0; ECount--)</span><br><span class="line">        PercDown(ESet, ECount, Graph-&gt;Ne);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetEdge(Edge ESet, int CurrentSize)</span><br><span class="line">&#123;</span><br><span class="line">    // 给定当前堆的大小CurrentSize， 将当前最小边位置弹出并调整堆</span><br><span class="line"></span><br><span class="line">    // 将最小边与当前堆的最后一个位置的边交换</span><br><span class="line">    Swap(&amp;ESet[0], &amp;ESet[CurrentSize - 1]);</span><br><span class="line">    // 将剩下的边继续调整成最小堆</span><br><span class="line">    PercDown(ESet, 0, CurrentSize - 1);</span><br><span class="line"></span><br><span class="line">    return CurrentSize - 1; // 返回最小边所在位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> /*-----------------------最小堆定义结束--------------------------------*/</span><br><span class="line"></span><br><span class="line"> int Kruskal(LGraph Graph, LGraph MST)</span><br><span class="line"> &#123;// 将最小生成树保存为邻接表存储的图MST， 返回最小权重和</span><br><span class="line">    WeightType TotalWeight;</span><br><span class="line">    int ECount, NextEdge;</span><br><span class="line">    SetType VSet; // 顶点数组</span><br><span class="line">    Edge ESet; // 边数组</span><br><span class="line"></span><br><span class="line">    InitializeVSet(VSet, Graph-&gt;Nv); // 初始化顶点并查集</span><br><span class="line">    ESet = (Edge)malloc(sizeof(struct ENode)*Graph-&gt;Ne);</span><br><span class="line">    InitializeESet(Graph, ESet); // 初始化边的最小堆</span><br><span class="line">    // 创建包含所有顶点但没有边的图，用邻接表</span><br><span class="line">    MST = CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    TotalWeight = 0; // 初始化权重和</span><br><span class="line">    ECount = 0; // 初始化收录的边数</span><br><span class="line"></span><br><span class="line">    NextEdge = Graph-&gt;Ne; //原生边集的规模</span><br><span class="line">    while(ECount &lt; Graph-&gt;Nv - 1)&#123;</span><br><span class="line">        // 当收集的边不足以构成树时</span><br><span class="line">        NextEdge = GetEdge(ESet, NextEdge); // 从边集中得到最小边的位置</span><br><span class="line">        if(NextEdge &lt; 0) // 边集已空</span><br><span class="line">            break;</span><br><span class="line">        // 如果该边的加入不构成回路，即两端结点不属于同一连通集</span><br><span class="line">        if(CheckCycle(VSet, ESet[NextEdge].V1, ESet[NextEdge].V2) ==  true)&#123;</span><br><span class="line">            // 将该边插入MST</span><br><span class="line">            InsertEdge(MST, ESet+NextEdge);</span><br><span class="line">            TotalWeight += ESet[NextEdge].Weight; // 累计权重</span><br><span class="line">            Ecount++; // 生成树中边数加1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ECount &lt; Graph-&gt;Nv - 1)</span><br><span class="line">        TotalWeight = -1; // 设置错误标记，表示生成树不存在</span><br><span class="line">    return TotalWeight;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h5><blockquote>
<p>在网络中，求两个不同顶点之间的所有路径中权值之和最小的那条路径<br>    - 这条路径就是两点之间的最短路径(Shortest Path)<br>    - 第一个顶点为源点(Source)<br>    - 最后一个顶点为终点(Destination)</p>
</blockquote>
<pre><code>问题分类：
单源最短路径问题： 从某固定源点出发，求其到所有其他顶点的最短路径
    - (有向)无权图
    - (有向)有权图

多源最短路径问题：求任意两顶点间的最短路径</code></pre><h6 id="BFS-广度优先遍历算法"><a href="#BFS-广度优先遍历算法" class="headerlink" title="BFS 广度优先遍历算法"></a>BFS 广度优先遍历算法</h6><blockquote>
<p>  [无权图的单源最短路径算法]<br>    详细的看视频讲解理解算法：(<a href="http://jdvodrvfb210d.vod.126.net/mooc-video/nos/mp4/2016/08/22/1004848002_652eec25c98b4cfe833863aa38a720e7_hd.mp4?ak=99ed7479ee303d1b1361b0ee5a4abcee0b5d8d309c21117103b4f89c70f969d3ea1f14bab52959e1c73ef3ae2f753c140d5fd180c9d920a388c7f0113a203cf6dc73ca898c2e909ad081fb3bc930be9adae3070f62128a029f5d4c798f8df62e8d527559dfc298f46da8ad5f53c2548f0797ab0443b0ce0c1b07fa8415bc5e265f33a26f5b1c3ca6c5fb7b88ad4b8b179b7ad6f2c848f1a32a51c2df2fed3c1e9e78811ec85e3d19ea763a2749a2e3af" target="_blank" rel="noopener">http://jdvodrvfb210d.vod.126.net/mooc-video/nos/mp4/2016/08/22/1004848002_652eec25c98b4cfe833863aa38a720e7_hd.mp4?ak=99ed7479ee303d1b1361b0ee5a4abcee0b5d8d309c21117103b4f89c70f969d3ea1f14bab52959e1c73ef3ae2f753c140d5fd180c9d920a388c7f0113a203cf6dc73ca898c2e909ad081fb3bc930be9adae3070f62128a029f5d4c798f8df62e8d527559dfc298f46da8ad5f53c2548f0797ab0443b0ce0c1b07fa8415bc5e265f33a26f5b1c3ca6c5fb7b88ad4b8b179b7ad6f2c848f1a32a51c2df2fed3c1e9e78811ec85e3d19ea763a2749a2e3af</a>)</p>
</blockquote>
<pre><code>按照递增(非递减)的顺序找出各个顶点的最短路
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void BFS(Vertex S)&#123;</span><br><span class="line">    visited[S] = true;//不需要</span><br><span class="line">    Enqueue(S, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        for(V的每个邻接点W)</span><br><span class="line">            if(!visited[W]) &#123;// 不需要</span><br><span class="line">                visited[W] = true; // 不需要</span><br><span class="line">                Enqueue(W, Q)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

dist[W] = S到W的最短距离
dist[S] = 0
path[W] = S到W的路上经过的某顶点

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Unweighted(Vertex S)&#123;</span><br><span class="line">    Enqueue(S, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        for(V的每个邻接点W)</span><br><span class="line">            if(dist[W] == -1)&#123;</span><br><span class="line">                dist[W] = dist[V] + 1;</span><br><span class="line">                path[W] = V;</span><br><span class="line">                Enqueue(W, Q)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><img src="/images/%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.png" alt="无权图的单源最短路径算法"></p>
<pre><code>准备工作


初始化dist path两个数组， -1， 队列Q空
取V3作为源点 dist第三个元素初始化为0
源点入队Q，然后进入while循环，检查队列是否为空
队列中有V3
不为空，V3出列，
对V3的两个邻接点V1 V6 进行遍历
是否为-1（判断是不是没有被访问过），是的，dist距离+1，然后将v3记录在路径上
然后将V1压进队列中，
然后遍历V6 ，没有访问过，v3距离+1 ，然后将v3记录在路径上，
将V6压入队列中
while一次循环结束
队列中有V1 V6 接着进行循环
然后V1出队列，遍历V1的两个邻接点V2 V4，
dist[2] = 2
path[2] = 1
V2 入队， 队列元素为V6 V2
然后遍历另外一个临界点V4
dist[4] = 2
path[4] = 1
V4，入队，先队列元素为V6 V2 V4
又进入下一次while循环，队列不为空
V6出队，V6没有邻接点，直接跳出for循环，进入下一次while循环
V2出队，V2邻接点V4 V5， 进入for循环 V4不等于-1 已经访问过了无视，然后遍历V5，没有访问过
dist[5] = 3
path[5] = 2
V5入队，然后进入下一次while循环检查队列，县队列 V4 V5
V4出队，遍历V4邻接点V4 V5 V6 V7，（V4， V5， V6已被访问过直接跳过）
dist[7] = 3
path[7] = 4
完成后V7入队，现队列 V5 V7
再进入whilw循环
V5 出队， 一个临界点V7 已被访问过，什么都不做，进入下一次while循环，现队列中V7
在进入while循环
V7出队，V7邻接点V6，已被访问过，什么都不做，在回到while循环，此时队列为空，循环结束

dist[2] = 2: V2的最短路径为2
path[2] = 1： 且这条最短路径是为V1到达V2的

下标   1   2   3   4   5    6   7
dist   1   2   0   2   3    1   3
path   3   1  -1   1   2    3   4


查找最短路径，依次顺着path路径入栈，再出栈,然后就找到最短路径

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 邻接表存储 - 无权图的单源最短路径算法</span><br><span class="line">// dist[] path[] 全部初始化为1</span><br><span class="line">    void Unweighted(LGraph Graph, int dist[], int path[], Vertex S)&#123;</span><br><span class="line">        Queue Q;</span><br><span class="line">        Vertex V;</span><br><span class="line">        PtrToAdjVNode W;</span><br><span class="line"></span><br><span class="line">        Q = CreateQueue(Graph-&gt; Nv); //创建空队列，MaxSize为外部定义的常数</span><br><span class="line">        dist[S] = 0; // 初始化源点</span><br><span class="line">        AddQ(Q, S);</span><br><span class="line"></span><br><span class="line">        while(!IsEmpty(Q))&#123;</span><br><span class="line">            V = DeleteQ(Q);</span><br><span class="line">            for(W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next) // 对V的每个邻接点W-&gt;AdjV</span><br><span class="line">                if(dist[W-&gt;AdjV == -1]) // 若w-&gt;AdjV未被访问过</span><br><span class="line">                    dist[W-&gt;AdjV] = dist[V] + 1; // W-&gt;AdjV到S的距离更新</span><br><span class="line">                    path[W-&gt;AdjV] = V; // 将V记录在S到w-&gt;AdjV的路径上</span><br><span class="line">                    Add(Q, W-&gt;AdjV);</span><br><span class="line">        &#125; // whilw结束</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><h6 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h6><blockquote>
<p>  有权图的单源最短路径算法<br>    有权图最短路和无权图最短路，最大的区别是有权图最短路径不一定是经过顶点数最少的路径</p>
</blockquote>
<pre><code>- 按照递增的顺序找出各个顶点的最短路 
- Dijkstra算法
    - 令S = {源点S + 已经确定了最短路径的顶点vi}
    - 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过S中的顶点。即路径{s-&gt;(vi ∈ S)-&gt;v}的最小长度
    - 若路径是按照递增(非递减)的顺序生成的，则
        - 真正的最短路必须只经过S中的顶点
        - 每次从未收录的顶点中选一个dist最小的收录(贪心算法思想)
        - 增加一个v进入S，可能影响另一个w的dist值
            dist[w] = min{dist[w], dist[v]+&lt;v, w&gt;d的权重}</code></pre><p><img src="/images/%E6%9C%89%E6%9D%83%E5%9B%BE%E5%8D%95%E6%BA%90%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.png" alt="有权图单源路径算法"><br>    V1源点 V6终点，从V1到V6的最短路径是哪条？<br>    不考虑，负值圈negative-costcycle</p>
<pre><code>首先初始化dist path两个数组
下标   1    2    3    4    5    6    7
dist   ∞    ∞   ∞     ∞    ∞    ∞   ∞
path   -1   -1  -1    -1   -1   -1   -1
选择V1作为源点，源点到自己的距离dist[1] = 0 相邻结点V2 V4的距离就被更新为权重，路径桑的顶点更新为1
下标   1    2    3    4    5    6    7
dist   0    2    ∞    1    ∞    ∞   ∞
path   -1   1    -1   1   -1   -1   -1

初始化完毕进入Dijkstra函数处理
找到未收录顶点dist最小数，V = V4 = 1， 标志为被访问过
遍历V4的每个邻接点W， V3 V5 V6 V7
V3遍历，判断没有被访问过，dist[v] = dist[V4] = 1 + E&lt;v,w&gt;=E&lt;v4, v3&gt;的权重=2 显然是小于dist[w] = dist[v3]=∞
所以dist[w] = dist[v3]更新为 dist[V] + E&lt;v,w&gt; = 1 + 2 = 3;
path[V3] = V4
下标   1    2    3    4    5    6    7
dist   0    2    3     1    ∞    ∞   ∞
path   -1   1    4     1   -1   -1   -1

至此完成V4一个邻接点的处理，进入下一个邻接点V5 进行处理
V5遍历，没有被访问过，同V3，dist[V]+E&lt;v, w&gt; &lt; dist[W] =&gt; dist[V4] + E&lt;V4, V5&gt; = 1 + 2 &lt; ∞
dist[V5] = 3
path[V5] = v4
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    ∞   ∞
path   -1   1    4     1   4   -1   -1
处理 V6 没有被访问过，同V3，dist[V]+E&lt;v, w&gt; &lt; dist[W] =&gt; dist[V4] + E&lt;V4, V6&gt; = 1 + 8 &lt; ∞
dist[V6] = 9
path[V6] = v4
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    9   ∞
path   -1   1    4     1   4    4   -1
处理 V7 没有被访问过，同V3，dist[V]+E&lt;v, w&gt; &lt; dist[W] =&gt; dist[V4] + E&lt;V4, V7&gt; = 1 + 4 &lt; ∞
dist[V7] = 5
path[V7] = v4
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    9    5
path   -1   1    4     1   4    4    4
至此处理完V4
接着进入下一轮循环，在没被收录顶点dist中找最小的 显然是顶点V2 = 2
然后对顶点V2的邻接点w， V4， V5进行遍历
V4已被访问过， 跳过
遍历V5，现在的dist[V] = dist[V2] = 2 ;E&lt;V2, V5&gt; = 10  
dist[V] + E&lt;V2, V5&gt; &gt; dist[w] = dist[V5] = 3
保持V5原路径不变
接着进入下一轮循环，找到未收录顶点dist最小数，V = V3/V5 = 3，选择V3 标志为被访问过
然后对V3的邻接点遍历访问 V1 V6
V1已被访问过跳过
V6，dist[V] = dist[V3] = 3 ;E&lt;V3, V6&gt; = 5  
dist[3] + E&lt;V3, V6&gt; = 8  &lt; dist[w] = dist[V6] = 9, 更新路径
dist[V6] = 8
path[V6] = v3
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    8    5
path   -1   1    4     1   4    3    4
对V3处理完毕后，接着找未收录顶点dist最小数 V5 =3，标志被访问过，
对V5的邻接点遍历处理 ，只有一个邻接点V7， V7现在的最短距离是5 从V4过来的
遍历V7，现在的dist[V] = dist[V5] = 3 ;E&lt;V5, V7&gt; = 6  
dist[V] + E&lt;V5, V7&gt;=9 &gt; dist[w] = dist[V7] = 5
保持V7原路径不变
对V5处理完毕后，接着找未收录顶点dist最小数 V7 = 5，标志被访问过，
V7唯一的邻接点V6， V6现在最短距离是8
dist[V7] = 5, V&lt;V7, V6&gt; = 1 
(dist[V7] = 5 )+ (V&lt;V7, V6&gt; = 1 ) = 6 &lt; dist[W]=dist[V6] = 8更新路径
dist[V6] = 6
path[V6] = V7
下标   1    2    3    4    5    6    7
dist   0    2    3     1   3    6    5
path   -1   1    4     1   4    7    4
继续找下一个未被收录顶点dist最小数 V6 访问V6
V6无邻接点，V6循环结束
在接着找未被收录顶点dist最小数，这样的顶点已经不存在了，至此跳出while循环，结束算法

算法完成后，V1到V6的最短路径是哪一条呢？
从path[V6]开始找到V7，然后path[V7]找到path[V4]，然后在path[V4]找到path[V1],然后找path[V1] = -1 &lt; 0.所以V1是源点
得到路径 V1-&gt;V4-&gt;V7-&gt;V6

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        V = 未收录顶点中dist最小者</span><br><span class="line">        if(这样的v不存在)</span><br><span class="line">            break; // 跳出循环</span><br><span class="line"></span><br><span class="line">        collected[V] = true;</span><br><span class="line">        for( V的每个邻接点W)</span><br><span class="line">            if(collected[W] == false) // 还没有被收录</span><br><span class="line">                if(dist[V]+E&lt;v, w&gt; &lt; dist[W])&#123;</span><br><span class="line">                    dist[W] = dist[V] + E&lt;v, w&gt;</span><br><span class="line">                    path[W] = V</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 不能解决有负边的情况</span><br></pre></td></tr></table></figure>

// 时间复杂度：这个程序的算法复杂度很大程度上取决于怎么做V = 未收录顶点中dist最小者
- 方法1：直接扫描所有未收录顶点-O(|V|)
    T = O(|V|^2 + |E|) 对稠密图效果好
- 方法2: 将dist存在最小堆中- O(log|V|)
    更新dist[w]的值 - O(log|V|)
    T = O(|V|log|V| + |E|log|V|) = O(|E|log|V|) 对于稀疏图效果好

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 邻接矩阵存储 - 有权图的单源最短路径算法</span><br><span class="line">Vertex FindMinDist(MGraph Graph, int dist[], int collected[])&#123;</span><br><span class="line">    // 返回未被收录顶点中dist最少这</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    int MinDist = INFINITY;</span><br><span class="line"></span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv;V++)&#123;</span><br><span class="line">        if(collected[V] == false &amp;&amp; dist[V]&lt;MinDist)&#123;</span><br><span class="line">            // 若V未被收录，且dist[V]更小</span><br><span class="line">            MinDist = dist[V]; //更新最小距离</span><br><span class="line">            MinV = V; // 更新对应顶点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(MinDist &lt; INFINITY) // 若找到最小dist</span><br><span class="line">        return MinV; // 返回对应的顶点下标</span><br><span class="line">    else return ERROR; // 若这样的顶点不存在，返回错误标记</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool Dijkstra(MGraph Graph, int dist[], int path[], Vertex S)&#123;</span><br><span class="line">    int collected[MaxVertexNum];</span><br><span class="line">    Vertex V, W;</span><br><span class="line"></span><br><span class="line">    // 初始化：此处默认邻接矩阵中不存在的边用INFINITY表示</span><br><span class="line">    for(V=0; V&lt;Graph-&gt;Nv; V++)&#123;</span><br><span class="line">        dist[V] = Graph-&gt;G[S][V];</span><br><span class="line">        if(dist[V]&lt;INFINITY)</span><br><span class="line">            path[V] = S;</span><br><span class="line">        else</span><br><span class="line">            path[V] = -1;</span><br><span class="line">        collected[S] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 先将起点收入集合</span><br><span class="line">    dist[S] = 0;</span><br><span class="line">    collected[S] = true;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        // V = 未被收录顶点中dist最小者</span><br><span class="line">        V = FindMinDist(Graph, dist, collected);</span><br><span class="line">        if(V== ERROR) // 若这样的V不存在</span><br><span class="line">            break; // 算法结束</span><br><span class="line">        </span><br><span class="line">        collected[V] = true; // 收录V</span><br><span class="line">        for(W=0; W&lt;Graph-&gt;Nv; W++)&#123; // 对图中的每个顶点W</span><br><span class="line">            // 若W是V的邻接点并且未被收录</span><br><span class="line">            if(collected[W]=false &amp;&amp; Graph-&gt;G[V][W] &lt; INFINITY) &#123;</span><br><span class="line">                if(Graph -&gt; G[V][W] &lt; 0) //  若有负边</span><br><span class="line">                    return false; // 不能正确解决，返回错误标记</span><br><span class="line">                // 若收录V使得dist[W]变小</span><br><span class="line">                if(dist[V] + Graph-&gt;[V][W] &lt; dist[W])&#123;</span><br><span class="line">                    dist[W] = dist[V] + Graph -&gt; G[V][W]; // 更新dist[W]</span><br><span class="line">                    path[W] = V; // 更新S到W的路径</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // while结束</span><br><span class="line">    return true; // 算法执行完毕，返回正确标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h6 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h6><blockquote>
<p>  多源最短路径算法<br>    方法1：直接将单源最短路算法调用|V|遍，  T = O(|V|^3 + |E|*|V|) 对于稀疏图效果好<br>    方法2：Floyd算法 T= O(|V|^3)  对于稠密图效果好</p>
</blockquote>
<pre><code>Floyd算法
    - 用邻接矩阵，二维数组，来记录 D^k[i][j] = 路径{i-&gt; {l&lt;= k}-&gt; j} 的最小长度
    - D^0, D^1,……,D^|V|-1[i][j]即给出了i到j的真正最短距离
    - 最初的D^-1是什么？ 初始的矩阵应该怎么定义？ 自己定义为邻接矩阵，对角元全部为0，i，j有边初始化为权重， i，j之间没有边，定义为∞
    - 如何完成递推？当D^k-1已经完成，递推到D^k时：
        或者k∉最短路径{i-&gt; {l&lt;= k}-&gt;j}, 即收录不会影响最短路径，D^k = D^k-1
        或者新加进去的k， k∈最短路径{i-&gt; {l&lt;= k}-&gt;j}，k一定在最短路径上, 则该路径必定由两段最短路劲组成：D^k[i][j] = D^k-1[i][k] + D^k-1[k][j]
其实这个讲解完了依旧还是晕，没听懂，没搞明白，但是代码还是要写一下
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vois Floyd() &#123;</span><br><span class="line">    for( i=0; i&lt;N; i++)</span><br><span class="line">        for(j=0; j&lt;N; j++)&#123;</span><br><span class="line">            D[i][j] = G[i][j]; // 初始化为邻接矩阵</span><br><span class="line">            path[i][j] = -1; // 用另外一个数组记录路径，初始化为-1，表示i j之间没有路径</span><br><span class="line">        &#125;</span><br><span class="line">    for(k=0; k&lt;N; k++) // 上标从0开始</span><br><span class="line">        for(i=0; i&lt;N; i++)</span><br><span class="line">            for(j=0; j&lt;N; j++)</span><br><span class="line">                if(D[i][k] + D[k][j]&lt; D[i][j])&#123;</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印从i到j的最短路径， 递归打印i到k的路径， 打印k的值， 递归打印从k到j的路径</span><br></pre></td></tr></table></figure>

T = O(|V|^3)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 邻接矩阵存储 - 多源最短路径算法</span><br><span class="line">bool Floyd(MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum])&#123;</span><br><span class="line">    Vertex i, j, k; </span><br><span class="line"></span><br><span class="line">    // 初始化</span><br><span class="line">    for(i=0; i&lt;Graph-&gt;Nv; i++)</span><br><span class="line">        for(j=0; j&lt;Graph-&gt;Nv; j++)</span><br><span class="line">            D[i][j] = Graph-&gt;G[i][j];</span><br><span class="line">            path[i][j] = -1;</span><br><span class="line"></span><br><span class="line">    for(k=0; k&lt;Graph-&gt;Nv; k++)</span><br><span class="line">        for(i=0; i&lt;Graph-&gt;Nv; i++)</span><br><span class="line">            for(j=0; j&lt;Graph-&gt;Nv; j++)</span><br><span class="line">                if(D[i][k] + D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">                    D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">                    if(i == j &amp;&amp; D[i][j]&lt;0) // 若发现负值圈</span><br><span class="line">                        return false; // 不能正确解决，返回错误标记</span><br><span class="line">                    path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">    return true; // 算法执行完毕，返回正确标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><ul>
<li><p>AOV：Acitivity On Vertex 网络 例：计算机专业排课</p>
</li>
<li><p>DAG：Directed Acyclic Graph 有向无环图</p>
</li>
<li><p>拓扑序：如果图中从v到w有一条有向路径，则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序</p>
</li>
<li><p>获得一个拓扑序的过程就是拓扑排序</p>
</li>
<li><p>AOV如果有合理的拓扑序，则必定是有向无环图Directed Acyclic Graph, DAG</p>
<p>  每次输出没有前驱的结点，入度为零，没有边指向它，从图中删除该点</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void TopSort()</span><br><span class="line">&#123;</span><br><span class="line">    for(cnt=0; cnt&lt;|V|;cont++)&#123;</span><br><span class="line">        V = 未输出的入度为0的顶点;// 时间复杂度取决于这一步怎么找</span><br><span class="line">        // 如果外循环还未结束，这样的V就已经不存在了，意味着图中还剩下好几个顶点没有被输出，但是每一个顶点入度都不是0，说明图中必定是有回路的</span><br><span class="line">        if(这样的V不存在)&#123;</span><br><span class="line">            ERROR(&quot;图中有回路&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        输出v，或者记录v的输出序号</span><br><span class="line">        for(v的每个临界接点W)</span><br><span class="line">            Indegree[w]--; // 遍历每个邻接点，入度减1，即为删除该点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  随时将入度变为0的顶点放到一个容器里</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//改一下算法</span><br><span class="line">void TopSort()</span><br><span class="line">&#123;</span><br><span class="line">    for(图中每个顶点v)</span><br><span class="line">        if(Indegree[v]==0)</span><br><span class="line">            Enqueue(V, Q);</span><br><span class="line">    while(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        //输出V，或者记录V的输出序号；</span><br><span class="line">        cnt++</span><br><span class="line">        for(V的每个邻接点W)</span><br><span class="line">            if(--Indegree[W]== 0)</span><br><span class="line">                Enqueue(W, Q);</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt != |V|)</span><br><span class="line">        Error(&quot;图中有回路&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这个算法也可以用来检测有向图是否是DAG 有向无环图</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/13/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/13/linux/" itemprop="url">linux$</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T11:53:26+08:00">
                2019-08-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-13T15:26:27+08:00">
                2019-08-13
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/13/linux/" class="leancloud_visitors" data-flag-title="linux$">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h3><blockquote>
<p>工作中用到的linux命令记录</p>
</blockquote>
<h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><p><strong>盘符切换命令 cd</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /root/Docements # 切换到目录/root/Docements</span><br><span class="line">cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录  </span><br><span class="line">cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</span><br></pre></td></tr></table></figure>

<p><strong>创建目录 mkdir</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项]... 目录... </span><br><span class="line"> -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask</span><br><span class="line"> -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; </span><br><span class="line"> -v, --verbose  每次创建新目录都显示信息</span><br></pre></td></tr></table></figure>

<p><strong>删除命令 rm</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</span><br><span class="line">-i ：互动模式，在删除前会询问用户是否操作</span><br><span class="line">-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</span><br><span class="line"></span><br><span class="line">删除文件夹</span><br><span class="line">rm -ir filedir 这个命令需要确认每个文件是否要被删除，文件过多会很繁琐</span><br><span class="line">rm -rf filedir 这个命令会直接删除文件夹，不会给出警告信息和提示</span><br></pre></td></tr></table></figure>

<p><strong>移动命令 mv</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br><span class="line">-i ：若目标文件已经存在，就会询问是否覆盖</span><br><span class="line">-u ：若目标文件已经存在，且比目标文件新，才会更新</span><br></pre></td></tr></table></figure>

<p><strong>复制命令 cp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a ：将文件的特性一起复制</span><br><span class="line">-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</span><br><span class="line">-r ：递归持续复制，用于目录的复制行为</span><br><span class="line">-u ：目标文件与源文件有差异时才会复制</span><br></pre></td></tr></table></figure>

<p><strong>查看文件夹内容 LS</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ </span><br><span class="line">-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ </span><br><span class="line">-d ：仅列出目录本身，而不是列出目录内的档案数据 </span><br><span class="line">-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) </span><br><span class="line">-F ：根据档案、目录等信息，给予附加数据结构，例如： </span><br><span class="line">*：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； </span><br><span class="line">-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； </span><br><span class="line">-i ：列出 inode 位置，而非列出档案属性； </span><br><span class="line">-l ：长数据串行出，包含档案的属性等等数据； </span><br><span class="line">-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) </span><br><span class="line">-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； </span><br><span class="line">-R ：连同子目录内容一起列出来； </span><br><span class="line">-S ：以档案容量大小排序！ </span><br><span class="line">-t ：依时间排序 </span><br><span class="line">--color=never ：不要依据档案特性给予颜色显示； </span><br><span class="line">--color=always ：显示颜色 </span><br><span class="line">--color=auto ：让系统自行依据设定来判断是否给予颜色 </span><br><span class="line">--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 </span><br><span class="line">--time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) </span><br><span class="line">而非内容变更时间 (modification time)</span><br></pre></td></tr></table></figure>

<p><strong>查看当前工作目录的完整路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd -P # 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径</span><br></pre></td></tr></table></figure>

<p><strong>压缩解压命令 tar</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c ：新建打包文件</span><br><span class="line">-t ：查看打包文件的内容含有哪些文件名</span><br><span class="line">-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</span><br><span class="line">-j ：通过bzip2的支持进行压缩/解压缩</span><br><span class="line">-z ：通过gzip的支持进行压缩/解压缩</span><br><span class="line">-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</span><br><span class="line">-f filename ：filename为要处理的文件</span><br><span class="line">-C dir ：指定压缩/解压缩的目录dir</span><br></pre></td></tr></table></figure>

<p><strong>压缩文件或文件夹为.gz gzip</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> gzip[参数][文件或者目录]</span><br><span class="line">-a or --ascii 　使用ASCII文字模式。 </span><br><span class="line">-c or --stdout or --to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 </span><br><span class="line">-d or --decompress or ----uncompress 　解开压缩文件。 </span><br><span class="line">-f or --force 　强行压缩文件。不理会文件名称 or 硬连接是否存在以及该文件是否为符号连接。 </span><br><span class="line">-h or --help 　在线帮助。 </span><br><span class="line">-l or --list 　列出压缩文件的相关信息。 </span><br><span class="line">-L or --license 　显示版本与版权信息。 </span><br><span class="line">-n or --no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 </span><br><span class="line">-N or --name 　压缩文件时，保存原来的文件名称及时间戳记。 </span><br><span class="line">-q or --quiet 　不显示警告信息。 </span><br><span class="line">-r or --recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </span><br><span class="line">-S&lt;压缩字尾字符串&gt; or ----suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 </span><br><span class="line">-t or --test 　测试压缩文件是否正确无误。 </span><br><span class="line">-v or --verbose 　显示指令执行过程。 </span><br><span class="line">-V or --version 　显示版本信息。 </span><br><span class="line">-num 用指定的数字num调整压缩的速度，-1 or --fast表示最快压缩方法（低压缩比），-9 or --best表示最慢压缩方法（高压缩比）。系统缺省值为6。</span><br></pre></td></tr></table></figure>

<p><strong>远程登录Linux主机 ssh命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-l login_name] [-p port] [user@]hostname</span><br></pre></td></tr></table></figure>

<p><strong>Linux下进行远程拷贝文件的命令 scp命令</strong></p>
<blockquote>
<p>scp secure copy, 与cp命令类似，但是cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [原路径] [目标路径]</span><br><span class="line"></span><br><span class="line">-1 强制scp命令使用协议ssh1 </span><br><span class="line">-2 强制scp命令使用协议ssh2 </span><br><span class="line">-4 强制scp命令只使用IPv4寻址 </span><br><span class="line">-6 强制scp命令只使用IPv6寻址 </span><br><span class="line">-B 使用批处理模式（传输过程中不询问传输口令或短语） </span><br><span class="line">-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） </span><br><span class="line">-p 保留原文件的修改时间，访问时间和访问权限。 </span><br><span class="line">-q 不显示传输进度条。 </span><br><span class="line">-r 递归复制整个目录。 </span><br><span class="line">-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 </span><br><span class="line">-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 </span><br><span class="line">-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 </span><br><span class="line">-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 </span><br><span class="line">-l limit 限定用户所能使用的带宽，以Kbit/s为单位。 </span><br><span class="line">-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， </span><br><span class="line">-P port 注意是大写的P, port是指定数据传输用到的端口号 </span><br><span class="line">-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure>

<p><strong>远程登录操作 telnet命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">telnet[参数][主机]</span><br><span class="line"></span><br><span class="line">-8 允许使用8位字符资料，包括输入与输出。</span><br><span class="line">-a 尝试自动登入远端系统。</span><br><span class="line">-b&lt;主机别名&gt; 使用别名指定远端主机名称。</span><br><span class="line">-c 不读取用户专属目录里的.telnetrc文件。</span><br><span class="line">-d 启动排错模式。</span><br><span class="line">-e&lt;脱离字符&gt; 设置脱离字符。</span><br><span class="line">-E 滤除脱离字符。</span><br><span class="line">-f 此参数的效果和指定&quot;-F&quot;参数相同。</span><br><span class="line">-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</span><br><span class="line">-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</span><br><span class="line">-K 不自动登入远端主机。</span><br><span class="line">-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</span><br><span class="line">-L 允许输出8位字符资料。</span><br><span class="line">-n&lt;记录文件&gt; 指定文件记录相关信息。</span><br><span class="line">-r 使用类似rlogin指令的用户界面。</span><br><span class="line">-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。</span><br><span class="line">-x 假设主机有支持数据加密的功能，就使用它。</span><br><span class="line">-X&lt;认证形态&gt; 关闭指定的认证形态。</span><br></pre></td></tr></table></figure>

<p><strong>远程下载命令 wget命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">wget [参数] [URL地址]</span><br><span class="line"></span><br><span class="line">启动参数：</span><br><span class="line">-V, –version 显示wget的版本后退出</span><br><span class="line">-h, –help 打印语法帮助</span><br><span class="line">-b, –background 启动后转入后台执行</span><br><span class="line">-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc</span><br><span class="line"></span><br><span class="line">记录和输入文件参数：</span><br><span class="line">-o, –output-file=FILE 把记录写到FILE文件中</span><br><span class="line">-a, –append-output=FILE 把记录追加到FILE文件中</span><br><span class="line">-d, –debug 打印调试输出</span><br><span class="line">-q, –quiet 安静模式(没有输出)</span><br><span class="line">-v, –verbose 冗长模式(这是缺省设置)</span><br><span class="line">-nv, –non-verbose 关掉冗长模式，但不是安静模式</span><br><span class="line">-i, –input-file=FILE 下载在FILE文件中出现的URLs</span><br><span class="line">-F, –force-html 把输入文件当作HTML格式文件对待</span><br><span class="line">-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀</span><br><span class="line">–sslcertfile=FILE 可选客户端证书</span><br><span class="line">–sslcertkey=KEYFILE 可选客户端证书的KEYFILE</span><br><span class="line">–egd-file=FILE 指定EGD socket的文件名</span><br><span class="line"></span><br><span class="line">下载参数：</span><br><span class="line">–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)</span><br><span class="line">-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).</span><br><span class="line">-O –output-document=FILE 把文档写到FILE文件中</span><br><span class="line">-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀</span><br><span class="line">-c, –continue 接着下载没下载完的文件</span><br><span class="line">–progress=TYPE 设定进程条标记</span><br><span class="line">-N, –timestamping 不要重新下载文件除非比本地文件新</span><br><span class="line">-S, –server-response 打印服务器的回应</span><br><span class="line">–spider 不下载任何东西</span><br><span class="line">-T, –timeout=SECONDS 设定响应超时的秒数</span><br><span class="line">-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒</span><br><span class="line">–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒</span><br><span class="line">–random-wait 在下载之间等待0…2*WAIT秒</span><br><span class="line">-Y, –proxy=on/off 打开或关闭代理</span><br><span class="line">-Q, –quota=NUMBER 设置下载的容量限制</span><br><span class="line">–limit-rate=RATE 限定下载输率</span><br><span class="line"></span><br><span class="line">目录参数：</span><br><span class="line">-nd –no-directories 不创建目录</span><br><span class="line">-x, –force-directories 强制创建目录</span><br><span class="line">-nH, –no-host-directories 不创建主机目录</span><br><span class="line">-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…</span><br><span class="line">–cut-dirs=NUMBER 忽略 NUMBER层远程目录</span><br><span class="line"></span><br><span class="line">HTTP 选项参数：</span><br><span class="line">–http-user=USER 设定HTTP用户名为 USER.</span><br><span class="line">–http-passwd=PASS 设定http密码为 PASS</span><br><span class="line">-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)</span><br><span class="line">-E, –html-extension 将所有text/html文档以.html扩展名保存</span><br><span class="line">–ignore-length 忽略 `Content-Length’头域</span><br><span class="line">–header=STRING 在headers中插入字符串 STRING</span><br><span class="line">–proxy-user=USER 设定代理的用户名为 USER</span><br><span class="line">–proxy-passwd=PASS 设定代理的密码为 PASS</span><br><span class="line">–referer=URL 在HTTP请求中包含 `Referer: URL’头</span><br><span class="line">-s, –save-headers 保存HTTP头到文件</span><br><span class="line">-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION</span><br><span class="line">–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)</span><br><span class="line">–cookies=off 不使用 cookies</span><br><span class="line">–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie</span><br><span class="line">–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中</span><br><span class="line"></span><br><span class="line">FTP 选项参数：</span><br><span class="line">-nr, –dont-remove-listing 不移走 `.listing’文件</span><br><span class="line">-g, –glob=on/off 打开或关闭文件名的 globbing机制</span><br><span class="line">–passive-ftp 使用被动传输模式 (缺省值).</span><br><span class="line">–active-ftp 使用主动传输模式</span><br><span class="line">–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)</span><br><span class="line"></span><br><span class="line">递归下载参数：</span><br><span class="line">-r, –recursive 递归下载－－慎用!</span><br><span class="line">-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)</span><br><span class="line">–delete-after 在现在完毕后局部删除文件</span><br><span class="line">-k, –convert-links 转换非相对链接为相对链接</span><br><span class="line">-K, –backup-converted 在转换文件X之前，将之备份为 X.orig</span><br><span class="line">-m, –mirror 等价于 -r -N -l inf -nr</span><br><span class="line">-p, –page-requisites 下载显示HTML文件的所有图片</span><br><span class="line"></span><br><span class="line">递归下载中的包含和不包含(accept/reject)：</span><br><span class="line">-A, –accept=LIST 分号分隔的被接受扩展名的列表</span><br><span class="line">-R, –reject=LIST 分号分隔的不被接受的扩展名的列表</span><br><span class="line">-D, –domains=LIST 分号分隔的被接受域的列表</span><br><span class="line">–exclude-domains=LIST 分号分隔的不被接受的域的列表</span><br><span class="line">–follow-ftp 跟踪HTML文档中的FTP链接</span><br><span class="line">–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表</span><br><span class="line">-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表</span><br><span class="line">-H, –span-hosts 当递归时转到外部主机</span><br><span class="line">-L, –relative 仅仅跟踪相对链接</span><br><span class="line">-I, –include-directories=LIST 允许目录的列表</span><br><span class="line">-X, –exclude-directories=LIST 不被包含目录的列表</span><br><span class="line">-np, –no-parent 不要追溯到父目录</span><br><span class="line">wget -S –spider url 不下载只显示过程</span><br></pre></td></tr></table></figure>

<p><strong>查看和配置网络设备 ifconfig命令</strong></p>
<blockquote>
<p>当网络环境发生变化可通过此命令对网络进行相应的配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网络设备] [参数]</span><br><span class="line"></span><br><span class="line">up 启动指定网络设备/网卡。</span><br><span class="line">down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。</span><br><span class="line">arp 设置指定网卡是否支持ARP协议。</span><br><span class="line">-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包</span><br><span class="line">-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包</span><br><span class="line">-a 显示全部接口信息</span><br><span class="line">-s 显示摘要信息（类似于 netstat -i）</span><br><span class="line">add 给指定网卡配置IPv6地址</span><br><span class="line">del 删除指定网卡的IPv6地址</span><br><span class="line">&lt;硬件地址&gt; 配置网卡最大的传输单元</span><br><span class="line">mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)</span><br><span class="line">netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。</span><br><span class="line">tunel 建立隧道</span><br><span class="line">dstaddr 设定一个远端地址，建立点对点通信</span><br><span class="line">-broadcast&lt;地址&gt; 为指定网卡设置广播协议</span><br><span class="line">-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议</span><br><span class="line">multicast 为网卡设置组播标志</span><br><span class="line">address 为网卡设置IPv4地址</span><br><span class="line">txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度</span><br></pre></td></tr></table></figure>

<h2 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h2><p><strong>chmod</strong></p>
<p><strong>使用vi编辑器的命令 vi/vim命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /var/log/aa.log # 打开 /var/log/aa.log文件并编辑</span><br></pre></td></tr></table></figure>

<p><strong>连接文件或标准输入并打印 cat命令</strong></p>
<blockquote>
<p>这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] [文件]...</span><br><span class="line">-A, --show-all           等价于 -vET</span><br><span class="line">-b, --number-nonblank    对非空输出行编号</span><br><span class="line">-e                       等价于 -vE</span><br><span class="line">-E, --show-ends          在每行结束处显示 $</span><br><span class="line">-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号</span><br><span class="line">-s, --squeeze-blank  有连续两行以上的空白行，就代换</span><br></pre></td></tr></table></figure>

<p><strong>查看文件内容 more命令</strong></p>
<blockquote>
<p>more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页查看文件的内容，还支持直接条转行等功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] </span><br><span class="line">命令参数：</span><br><span class="line">+n 从笫n行开始显示</span><br><span class="line">-n 定义屏幕大小为n行</span><br><span class="line">+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 </span><br><span class="line">-c 从顶部清屏，然后显示</span><br><span class="line">-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-l 忽略Ctrl+l（换页）字符</span><br><span class="line">-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class="line">-s 把连续的多个空行显示为一行</span><br><span class="line">-u 把文件内容中的下画线去掉</span><br><span class="line">常用操作命令：</span><br><span class="line">Enter 向下n行，需要定义。默认为1行</span><br><span class="line">Ctrl+F 向下滚动一屏</span><br><span class="line">空格键 向下滚动一屏</span><br><span class="line">Ctrl+B 返回上一屏</span><br><span class="line">= 输出当前行的行号</span><br><span class="line">：f 输出文件名和当前行的行号</span><br><span class="line">V 调用vi编辑器</span><br><span class="line">!命令 调用Shell，并执行命令 </span><br><span class="line">q 退出more</span><br></pre></td></tr></table></figure>

<p><strong>查看文件内容 less命令</strong></p>
<blockquote>
<p>命令用法比起more更加的有弹性，在more的时候，我们并没有办法向前面翻，只能往后看，但是使用less时，就可以使用【pageup】【pagedown】等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容，除此之外less还有更多的搜索功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">less [参数]  文件 </span><br><span class="line">-b &lt;缓冲区大小&gt; 设置缓冲区的大小</span><br><span class="line">-e 当文件显示结束后，自动离开</span><br><span class="line">-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</span><br><span class="line">-g 只标志最后搜索的关键词</span><br><span class="line">-i 忽略搜索时的大小写</span><br><span class="line">-m 显示类似more命令的百分比</span><br><span class="line">-N 显示每行的行号</span><br><span class="line">-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">-Q 不使用警告音</span><br><span class="line">-s 显示连续空行为一行</span><br><span class="line">-S 行过长时间将超出部分舍弃</span><br><span class="line">-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">/字符串：向下搜索“字符串”的功能</span><br><span class="line">?字符串：向上搜索“字符串”的功能</span><br><span class="line">n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">b 向后翻一页</span><br><span class="line">d 向后翻半页</span><br><span class="line">h 显示帮助界面</span><br><span class="line">Q 退出less 命令</span><br><span class="line">u 向前滚动半页</span><br><span class="line">y 向前滚动一行</span><br><span class="line">空格键 滚动一行</span><br><span class="line">回车键 滚动一页</span><br><span class="line">[pagedown]： 向下翻动一页</span><br><span class="line">[pageup]： 向上翻动一页</span><br></pre></td></tr></table></figure>

<p><strong>从指定点开始将文件写到标准输出 tail命令</strong></p>
<blockquote>
<p>从指定点开始将文件写到标准输出，使用tail命令的-f选项可以方便的查阅正在改变的日志文件，tail -f filename会把filename里最尾部的内容显示在屏幕上，并且不断刷新最新的文件内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tail[必要参数][选择参数][文件] </span><br><span class="line"></span><br><span class="line">-f 循环读取</span><br><span class="line">-q 不显示处理信息</span><br><span class="line">-v 显示详细的处理信息</span><br><span class="line">-c&lt;数目&gt; 显示的字节数</span><br><span class="line">-n&lt;行数&gt; 显示行数</span><br><span class="line">--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. </span><br><span class="line">-q, --quiet, --silent 从不输出给出文件名的首部 </span><br><span class="line">-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</span><br></pre></td></tr></table></figure>

<p><strong>用于比较两个文件或目录的不同 diff</strong></p>
<blockquote>
<p>diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效，以逐行的方式，比较文本文件的异同处，如果指定比较的是目录的时候，diff命令会比较两个目录下名字相同的文本文件，列出不同的二进制文件、公共子目录和只在一个目录出现的文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">diff[参数][文件1或目录1][文件2或目录2]</span><br><span class="line"></span><br><span class="line"># diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的</span><br><span class="line"># 文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</span><br><span class="line"></span><br><span class="line">-a or --text 　#diff预设只会逐行比较文本文件。</span><br><span class="line">-b or --ignore-space-change 　#不检查空格字符的不同。</span><br><span class="line">-B or --ignore-blank-lines 　#不检查空白行。</span><br><span class="line">-c 　#显示全部内文，并标出不同之处。</span><br><span class="line">-C or --context 　#与执行&quot;-c-&quot;指令相同。</span><br><span class="line">-d or --minimal 　#使用不同的演算法，以较小的单位来做比较。</span><br><span class="line">-D or ifdef 　#此参数的输出格式可用于前置处理器巨集。</span><br><span class="line">-e or --ed 　#此参数的输出格式可用于ed的script文件。</span><br><span class="line">-f or -forward-ed 　#输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span><br><span class="line">-H or --speed-large-files 　#比较大文件时，可加快速度。</span><br><span class="line">-l or --ignore-matching-lines 　#若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符 or 字符串，则不显示这两个文件的差异。</span><br><span class="line">-i or --ignore-case 　#不检查大小写的不同。</span><br><span class="line">-l or --paginate 　#将结果交由pr程序来分页。</span><br><span class="line">-n or --rcs 　#将比较结果以RCS的格式来显示。</span><br><span class="line">-N or --new-file 　#在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span><br><span class="line">-p 　#若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span><br><span class="line">-P or --unidirectional-new-file 　#与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span><br><span class="line">-q or --brief 　#仅显示有无差异，不显示详细的信息。</span><br><span class="line">-r or --recursive 　#比较子目录中的文件。</span><br><span class="line">-s or --report-identical-files 　#若没有发现任何差异，仍然显示信息。</span><br><span class="line">-S or --starting-file 　#在比较目录时，从指定的文件开始比较。</span><br><span class="line">-t or --expand-tabs 　#在输出时，将tab字符展开。</span><br><span class="line">-T or --initial-tab 　#在每行前面加上tab字符以便对齐。</span><br><span class="line">-u,-U or --unified= 　#以合并的方式来显示文件内容的不同。</span><br><span class="line">-v or --version 　#显示版本信息。</span><br><span class="line">-w or --ignore-all-space 　#忽略全部的空格字符。</span><br><span class="line">-W or --width 　#在使用-y参数时，指定栏宽。</span><br><span class="line">-x or --exclude 　#不比较选项中所指定的文件 or 目录。</span><br><span class="line">-X or --exclude-from 　#您可以将文件 or 目录类型存成文本文件，然后在=中指定此文本文件。</span><br><span class="line">-y or --side-by-side 　#以并列的方式显示文件的异同之处。</span><br></pre></td></tr></table></figure>

<p><strong>确定主机与外部链接状态 ping命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ping [参数] [主机名或IP地址]</span><br><span class="line">-d 使用Socket的SO_DEBUG功能。</span><br><span class="line">-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。</span><br><span class="line">-n 只输出数值。</span><br><span class="line">-q 不显示任何传送封包的信息，只显示最后的结果。</span><br><span class="line">-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。</span><br><span class="line">-R 记录路由过程。</span><br><span class="line">-v 详细显示指令的执行过程。</span><br><span class="line">&lt;p&gt;-c 数目：在发送指定数目的包后停止。</span><br><span class="line">-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。</span><br><span class="line">-I 网络界面：使用指定的网络界面送出数据包。</span><br><span class="line">-l 前置载入：设置在送出要求信息之前，先行发出的数据包。</span><br><span class="line">-p 范本样式：设置填满数据包的范本样式。</span><br><span class="line">-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。</span><br><span class="line">-t 存活数值：设置存活数值TTL的大小。</span><br></pre></td></tr></table></figure>

<p><strong>为某一个文件在另一个位置建立一个同步的链接</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</span><br><span class="line"></span><br><span class="line">软链接：</span><br><span class="line">1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</span><br><span class="line">2.软链接可以 跨文件系统 ，硬链接不可以</span><br><span class="line">3.软链接可以对一个不存在的文件名进行链接</span><br><span class="line">4.软链接可以对目录进行链接</span><br><span class="line"></span><br><span class="line">硬链接:</span><br><span class="line">1.硬链接，以文件副本的形式存在。但不占用实际空间。</span><br><span class="line">2.不允许给目录创建硬链接</span><br><span class="line">3.硬链接只有在同一个文件系统中才能创建</span><br><span class="line"></span><br><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br><span class="line"></span><br><span class="line">必要参数:</span><br><span class="line">-b 删除，覆盖以前建立的链接</span><br><span class="line">-d 允许超级用户制作目录的硬链接</span><br><span class="line">-f 强制执行</span><br><span class="line">-i 交互模式，文件存在则提示用户是否覆盖</span><br><span class="line">-n 把符号链接视为一般目录</span><br><span class="line">-s 软链接(符号链接)</span><br><span class="line">-v 显示详细的处理过程</span><br><span class="line"></span><br><span class="line">选择参数:</span><br><span class="line">-S “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”</span><br><span class="line">-V “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/pm2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/pm2/" itemprop="url">pm2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T17:00:25+08:00">
                2019-08-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-15T14:12:50+08:00">
                2019-08-15
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/12/pm2/" class="leancloud_visitors" data-flag-title="pm2">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  440
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>pm2 安装为root用户安装，现切换为普通user用户使用pm2报错，正在解决：<br>解决方案一：SUDO，赋予普通用户临时root权限，并限制监控user操作，实现服务的可控。<br>SUDO（substitude user do）使得系统管理员可以授权特定用户或用户组作为临时root执行命令，同时还能对命令及其参数提供审核跟踪。可以针对单个命令、仅在需要时授予临时权限，减少因为执行错误命令损坏系统，sudo也能以其他用户身份执行命令并且记录用户执行的命令，以及失败的权限申请。<br>手册参考：[ps:全英文]<br><a href="https://gratisoft.us/sudo/man.html" target="_blank" rel="noopener">https://gratisoft.us/sudo/man.html</a><br><a href="https://gratisoft.us/sudo/man/1.8.6/sudoers.man.html" target="_blank" rel="noopener">https://gratisoft.us/sudo/man/1.8.6/sudoers.man.html</a></p>
</blockquote>
<p><a href="https://wiki.archlinux.org/index.php/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p>
<p>pm2 非root用户权限设置</p>
<h3 id="检查状态-日志-指标"><a href="#检查状态-日志-指标" class="headerlink" title="检查状态 日志 指标"></a>检查状态 日志 指标</h3><p><strong>列出托管应用程序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 [list|ls|status]</span><br></pre></td></tr></table></figure>

<p><strong>显示日志</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">显示实时日志：</span><br><span class="line">pm2 logs</span><br><span class="line">显示就日志：</span><br><span class="line">pm2 logs --lines 200</span><br><span class="line">基于终端仪表盘：</span><br><span class="line">pm2 monit</span><br></pre></td></tr></table></figure>

<p><strong>管理应用程序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pm2 restart app</span><br><span class="line">pm2 reload app</span><br><span class="line">pm2 stop app</span><br><span class="line">pm2 delete app</span><br></pre></td></tr></table></figure>

<p><strong>集群模式</strong></p>
<blockquote>
<p>对于node.js应用程序，PM2包括一个自动负载均衡器，它将共享每个进程这件的所有http[s]/websocket/tcp/udp连接</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要以集群模式启动应用程序:</span><br><span class="line">pm2 start app.js -i max</span><br></pre></td></tr></table></figure>

<p><strong>用户不在sudoers文件中的解决方法</strong><br>1、查看/etc/sudoers文件权限，如果为只读权限，修改为可写权限<br>ls -l /etc/sudoers</p>
<p>2、修改sudoers文件的权限不只是只读<br>chmod 777 /etc/sudoers</p>
<p>3、编辑sudoers文件，添加user用户为所有可执行权限</p>
<p>4、修改回sudoers权限为440<br>chmod 440 sudoers</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/docker/" itemprop="url">docker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T16:24:30+08:00">
                2019-08-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-12T16:24:30+08:00">
                2019-08-12
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/12/docker/" class="leancloud_visitors" data-flag-title="docker">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/redis_memcached/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/redis_memcached/" itemprop="url">redis memcached</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T11:21:11+08:00">
                2019-08-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-12T14:46:31+08:00">
                2019-08-12
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/12/redis_memcached/" class="leancloud_visitors" data-flag-title="redis memcached">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  603
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>项目里有用到memcached ，想对比Redis看一下，这里的区别，以及这两个服务的应用场景是什么。</p>
</blockquote>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote>
<p>Redis是一个开源使用ANSIC语言编写，遵循BSD协议，支持网络，可基于内存亦可持久化的日志型，Key-Value数据库，并提供多种语言的API<br>它通常被称为数据结构服务器，因为值（value）可以是字符串（String），哈希（Map），列表（list），集合（sets）和有序集合（stored sets）等类型。</p>
</blockquote>
<p>Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p>Redis与其他key-value缓存产品有一下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，<strong>重启的时候可以再次加载进行使用</strong>。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供了list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<p>Redis 优势：<br>性能极高- Redis能读的速度是110000次/s，写的速度是81000次/s.<br>丰富的数据类型 - Redis支持二进制案例的，Strings，lists，Hashes，Sets及Ordered Sets数据类型操作。<br>原子 - Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。<br>丰富的特性 - Redis还支持publish/subscribe，通知，key过期等等特性。</p>
<p>Redis与其他Key-value存储有什么不同</p>
<pre><code>Redis有这更为复杂的数据结构，并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径，Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。

Redis运行在内存中，但是可以持久化到磁盘，所以对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存，在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</code></pre><h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/bekjae.jpg" alt="KOKI HOO">
            
              <p class="site-author-name" itemprop="name">KOKI HOO</p>
              <p class="site-description motion-element" itemprop="description">PEACE&LOVE</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KOKI HOO</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">66.5k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jD3hLxRDgCSdorrir1RFkW3R-gzGzoHsz", "9AOQX6uUKthSSONK5UO95RGd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
