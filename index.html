<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="PEACE&amp;LOVE">
<meta property="og:type" content="website">
<meta property="og:title" content="KOKI">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KOKI">
<meta property="og:description" content="PEACE&amp;LOVE">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KOKI">
<meta name="twitter:description" content="PEACE&amp;LOVE">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>KOKI</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a5ecac7771fad0fda5191a255b9e3f5c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KOKI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/08/严蔚敏视频目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/08/严蔚敏视频目录/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-08T11:14:33+08:00">
                2019-10-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-10-08T15:04:30+08:00">
                2019-10-08
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/10/08/严蔚敏视频目录/" class="leancloud_visitors" data-flag-title>
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  158
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第五章 数组和广义表<br>P30 : 12:20 广义表的操作与递归函数 广义表深度<br>P31 : 广义表<br>遍历时所有非线性结构（包括二叉树，树，和广义表）的操作的基础<br>遍历有不同的搜索路径，不同的应用需要不同的搜索路径</p>
<p>P32 P33 ： 广义表 查找的部分<br>深度优先搜索遍历<br>二叉树 先序、中序、后序<br>树     先根 后根<br>图     先访问顶点 后访问顶点<br>广义表  先遍历表头 先遍历表尾</p>
<p>深度优先搜索遍历算法的两种形式：<br>递归<br>非递归</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/02/haobin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/02/haobin/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-02T11:11:50+08:00">
                2019-09-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-17T11:58:13+08:00">
                2019-09-17
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/09/02/haobin/" class="leancloud_visitors" data-flag-title>
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  504
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###<br>预备知识:</p>
<p>指针：<br>    指针的重要性：指针是C语言的灵魂<br>    定义：<br>        地址:<br>            内存单元的编号<br>            从0开始的非负整数<br>            范围： 0-FFFFFFFF(0-4G-1)<br>        指针:<br>            指针就是地址， 地址就是指针<br>            指针变量是存放存放内存单元地址的变量<br>            指针的本质是一个操作受限的非负整数</p>
<pre><code>        int i = 10;
        int *p = &amp;i; // 等价于int *p； p = &amp;i;
        1\p存放了i的地址，所以我们所p指向了i
        2、p和i是完全不同的两个变量，修改其中i的值不影响p的值，修改p的值不影响i
        3、p指向i，*p就是i变量本身，更形象的是所有出现*p的地方

    总结：
        - 如果一个指针变量假定为p存放了某个普通
        - *p等价于i，或者说*p可以与i在任何地方互换
        - 如果一个指针变量直系那个了某个普通变量，则*指针变量，就完全等价于该普通变量
    注意：
        - 指针变量也是变量，只不过它存放的不能内存单元的内容，只能存放内存单元的地址
        - 普通变量前不能加*
        - 变量和表达式前不能加&amp;

    x占8个字节，一个字节是8位，一个字节一个地址，8个字节8个地址
    分类：
    1、基本类型的指针
    2、指针和数组的关系
CPU操作内存： 地址线（32位----最大内存4G） 控制线 数据线</code></pre><p>结构体<br>动态内存的分配和释放</p>
<p>线性结构<br>    连续存储【数组】<br>    离散存储【链表】<br>    线性结构的两个常见应用：栈 队列<br>    专题：递归<br>    1、1+2+3+4+5+……=100<br>    2、求阶乘<br>    3、汉诺塔<br>    4、走迷宫</p>
<p>非线性结构<br>    树<br>    图</p>
<p>查找与排序<br>    折半查找</p>
<pre><code>排序：
冒泡
插入
选择
快速排序
归并排序</code></pre><p>程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/23/Tableau/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/Tableau/" itemprop="url">Tableau</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-23T10:57:58+08:00">
                2019-08-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-23T10:59:41+08:00">
                2019-08-23
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BI/" itemprop="url" rel="index">
                    <span itemprop="name">BI</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/23/Tableau/" class="leancloud_visitors" data-flag-title="Tableau">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#### </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/19/xulun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/xulun/" itemprop="url">xulun</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T11:08:35+08:00">
                2019-08-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-01T15:58:22+08:00">
                2019-09-01
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DATA-STRUCTURE/" itemprop="url" rel="index">
                    <span itemprop="name">DATA STRUCTURE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/19/xulun/" class="leancloud_visitors" data-flag-title="xulun">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据结构讨论的范畴"><a href="#数据结构讨论的范畴" class="headerlink" title="数据结构讨论的范畴"></a>数据结构讨论的范畴</h3><p>####<br>数据结构与程序设计密切相关</p>
<blockquote>
<p>程序设计：为计算机处理问题编制一组指令集</p>
<ul>
<li>怎么处理，处理的策略是什么，这是算法要讨论的问题</li>
<li>对处理的信息怎么表示，问题的数据模型是什么<br>算法：处理问题的策略<br>数据结构: 问题的数学模型</li>
</ul>
</blockquote>
<p>  例如：数值计算的程序设计问题：</p>
<p>  结构静力分析计算——线性代数方程组<br>  全球天气预报——环流模式方程</p>
<p>  例一：求一组（n个）整数中的最大值：<br>  算法：？基本操作是“比较两个数的大小”<br>  模型：？<br>  例二： 计算机对弈<br>  算法：？对弈的规则和策略<br>  模型: ?<br>  例三：足协的数据库管理<br>  算法：？需要管理的项目？如何管理？用户界面<br>  模型：？</p>
<p>数据结构描述显示世界实体的数学模型（非数值计算）及其上的操作在计算机中的表示和实现。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="数据与数据结构"><a href="#数据与数据结构" class="headerlink" title="数据与数据结构"></a>数据与数据结构</h4><ul>
<li>数据：（数据操作对象）所有能被输入到计算机中，且被计算机处理的符号的集合计算机操作的对象的总称，是计算机处理的信息的某种特定的符号表示形式。</li>
<li>数据元素：数据中的一个“个体”，数据结构中讨论的基本单位，是数据项的集合</li>
<li>数据项：数据结构中讨论的最小单位，数据元素是数据项的集合。<br>例如：运动员（数据元素） 包含6个数据项：姓名 俱乐部名称 出生日期（由，年月日三个数据项组成，出生日期称为组合项） 参加日期 职务 业绩 </li>
<li>数据结构：带<strong>结构</strong>的数据元素的集合<br>例如：一个含12位数的十进制数可以用三个4位十进制数表示<br>3214,6587,9345 - al(3214)，a2(6587),a3(9345)<br>在a1，a2，a3之间存在“次序”关系<br>&lt;a1, a2&gt;、&lt;a2, a3&gt;<br>次序颠倒：a1 a2 a3（3214,6587,9345） 不等于 a2 a1 a3（6587,3214,9345）</li>
</ul>
<p>又例：2行3列的二维数组{a1，a2，a3，a4，a5，a6}<br>    a1 |a2 |a3<br>    a4 |a5 |a6<br>    行的次序关系：row= {&lt;a1, a2&gt;,&lt;a2, a3&gt;,&lt;a3, a4&gt;,&lt;a4, a5&gt;,&lt;a5, a6&gt;}<br>    列的次序关系：clo = {&lt;a1, a4&gt;,&lt;a2, a5&gt;,&lt;a3, a6&gt;}</p>
<pre><code>a1 a3 a5        a1 a2 a3
a2 a4 a6 不等于  a4 a5 a6</code></pre><p>再例，一维数组{a1，a2，a3，a4，a5，a6}中存在次序关系：{&lt;ai,ai+1&gt;| i = 1,2,3,4,5}}</p>
<p>数据的逻辑关系可以归纳为以下四类：<br>线性结构：<img src="/images/line.png" alt="线性结构"><br>树形结构：<img src="/images/tree.png" alt="树性结构"><br>图形结构：<img src="/images/graph.png" alt="图性结构"><br>集合结构：<img src="/images/cluster.png" alt="集合结构"></p>
<p>数据结构的形式定义为：<br>    数据结构是一个二元组<br>        Data_Structures = (D,S)，其中：D是数据元素的有限集，S是D上关系的有限集</p>
<p>数据的存储结构-逻辑结构在存储器中的映象</p>
<p>数据元素的映象方法：<br>用二进制位（bit）的位串表示数据元素：<br>（321）10 = （501）8 = （101000001）2；<br>A = （101）8 = （001000001）2；</p>
<p>关系的映象方法：表示&lt;x, y&gt;的方法</p>
<p>顺序映象：以存储位置的相邻表示后继关系<br>    y的存储位置和x的存储位置之间差一个常量C，C是一个隐含值，整个存储结构中只含数据元素本身的信息，没有附加信息<br>    ————<br>    x|y<br>    ————</p>
<p>链式映象：以附加信息（指针）表示后继关系，需要用一个和X在一起的附加信息指示y的存储位置</p>
<p>在不同的编程环境中,存储结构有不同的描述方法<br>当用高级程序设计语言进行编程时，通常可用高级标称语言语言中提供的数据类型描述之</p>
<p>例如：以三个带有次序关系的整数表示一个长整数时，可利用C语言中提供的整数数组类型，定义长整数为：<br>    typedef int Long_int[3]</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>在用高级程序语言填写的程序中，必须对程序中出现的每个变量或表达式，明确说明它们所属的数据类型。

数据类型是一个值的集合和定义在此集合上的一组操作的总称。【数值型 结构型】</code></pre><h4 id="抽象数据类型-Abstract-Data-Type-简称ADT"><a href="#抽象数据类型-Abstract-Data-Type-简称ADT" class="headerlink" title="抽象数据类型 Abstract Data Type 简称ADT"></a>抽象数据类型 Abstract Data Type 简称ADT</h4><pre><code>是指一个数据模型以及定义在此数据模型上的一组操作
ADT有两个重要特征：
**数据抽象**：用ADT描述程序处理的实体时，强调的是其本质的特征、其所能完成的功能以及它和外部用户的接口（即外界使用它的方法）
例如：抽象数据类型复数的定义：
    ADT Complex {
        数据对象：D = {e1，e2 | e2，e2∈RealSet}
        数据关系：R1 = {&lt;e1,e2&gt;| e1是复数的实数部分，e2的复数的虚数部分}
        基本操作：
            - InitComplex(&amp;Z，v1，v2) 操作结果：构造复数Z，其实部和虚部分别被赋以参数v1和v2的值。
            - DestoryComplex(&amp;Z) 操作结果：复数Z被销毁
            - GetReal(Z, &amp;realPart) 初始条件：复数已存在。 操作结果: 用realPart返回复数Z的实部值
            - GetImag(Z, &amp;ImagPart) 初始条件：复数已存在。 操作结果： 用ImagPart返回复数Z的虚部值
            - Add(z1,z2,&amp;sum) 初始条件z1，z2是复数。操作结果：用sum返回两个复数z1，z2的和值                        
    } ADT Complex
**数据封装**：将实体的外部特性和其内部实现细节分离，并且对外部用户隐藏其实现细节

抽象数据类型的描述方法：
    抽象数据类型可用（D，S，P）三元组表示：其中D是数据对象，S是D上的关系集，P是对D的基本操作集
抽象数据类型的表示和实现：抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现</code></pre><h3 id="算法及其量度"><a href="#算法及其量度" class="headerlink" title="算法及其量度"></a>算法及其量度</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><pre><code>算法是为了解决某类问题而规定的一个有限长的操作序列，一个算法必须满足一下五个重要特性：
有穷性 确定性 可行性 有输入 有输入
1、有穷性： 对于任意一组合法输入值，在执行有穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成
2、确定性：对于每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行，并且在任何条件下，算法都只有一条执行路径。
3、可行性：算法中的所有操作必须足够基本，都可以通过已经实现的基本操作运算有限次实现之
4、有输入：作为算法加工对象的量值，通常体现为算法中的一组变量。有些输入量需要在算法执行过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法中
5、有输出：它是一组与输入与确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法的功能</code></pre><h4 id="算法设计的原则"><a href="#算法设计的原则" class="headerlink" title="算法设计的原则"></a>算法设计的原则</h4><pre><code>1、正确性 ，首先算法应当满足以特定的规格说明方式给出的需求，其次，对算法是否正确的理解可以有一下四个层次：
            a 程序中不含语法错误
            b 程序对于几组输入数据能够得出满足要求的结果
            c 程序对于精心选择的、典型。苛刻且带有刁难性的几组输入数据能够得出满足要求的结果（边界，临界）
            d 程序对于一切合法的输入数据都能得到满足要求的结果
2、可读性 算法主要是为了人的阅读和交流，其次才是为了计算机执行，因此算法应该易于人的理解，另一方面，晦涩难读的程序易于隐藏较多错误而难以调试
3、健壮性 当输入的数据非法时，算法应当恰当地做出反映或进行相应处理，而不是莫名其妙的输出结果，并且，处理出错的方法不应是中断程序的执行，而应是返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理
4、高效率与低存储量需求 通常效率指的是算法执行时间，存储量指的是算法执行过程中所需的最大存储空间，两者都与问题的规模有关。</code></pre><h4 id="算法效率的衡量方法和准则"><a href="#算法效率的衡量方法和准则" class="headerlink" title="算法效率的衡量方法和准则"></a>算法效率的衡量方法和准则</h4><p>通常有两种衡量算法效率的方法：<br>事后统计法：<br>    缺点：<br>        - 必须执行程序<br>        - 其它因素掩盖算法本质<br>事前分析估算法</p>
<blockquote>
<p>和算法执行时间相关的因素</p>
<ul>
<li>算法选用的策略</li>
<li>问题的规模</li>
<li>编写程序的语言</li>
<li>编译程序产生的机器代码的质量</li>
<li>计算机执行指令的速度<br>一个特定算法的“运行工作量”的大小，只依赖于问题的规模（通常用整数n表示），或者说它是问题规模的函数</li>
</ul>
</blockquote>
<p>假如，随着问题规模n的增长，算法执行时间的增长率和f（n）的增长率相同，则可记作：<br>    T（n） = O（f（n））<br>    称T（n）为算法的（渐近）时间复杂度</p>
<p>如何估算算法的时间复杂度？<br>    算法 = 控制结构 + 若干原操作（固有数据类型的操作）<br>    算法的执行时间 = ∑原操作（i）的执行次数 * 原操作（i）的执行时间<br>    算法的执行时间与原操作执行次数之和成正比</p>
<pre><code>从算法中选取一种对于所研究的问题来说是**基本操作**的原操作，以该基本操作**在算法中重复执行的次数作为算法中重复执行的次数**，作为算法运行时间的衡量准则</code></pre><p>例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line"> for(j=1; j&lt;=n; ++j)&#123;</span><br><span class="line">     c[i,j] = 0;</span><br><span class="line">     for(k=1; k&lt;=n; ++k)</span><br><span class="line">        c[i,j] += a[i,k]*b[k,j] // 此处乘法操作为基本操作</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 基本操作：乘法操作<br> 时间复杂度：O(n^3)</p>
<p>例二 选择排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void select_sort(int a[], int n)&#123;</span><br><span class="line">    // 将a中整数序列重新排序成自小到大有序的整数序列</span><br><span class="line">    for(i = 0; i&lt; n-1; ++i)&#123; // 循环n次</span><br><span class="line">        j = i;</span><br><span class="line">        for(k = i+1; k&lt;n ; ++k) // n-1+n-2+n-3 + …… +1= n(n-1)/2</span><br><span class="line">            if(a[k] &lt; a[j]) j = k;</span><br><span class="line">        if(j!=i) a[j] &lt;--&gt; a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // select_sort</span><br></pre></td></tr></table></figure>

<p>控制结构是两层循环:<br>基本操作: 比较(数据元素)操作<br>时间复杂度：O(n^2)</p>
<p>语句的执行次数为语句的频度</p>
<p>例三 冒泡排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void bubble_sort(int a[], int n)&#123;</span><br><span class="line">    // 将a中整数序列重新排列成自小至大</span><br><span class="line">    // 有序的整数序列</span><br><span class="line">    for(i=n-1, change = TRUE; i&gt;1&amp;&amp;change; --i)&#123;</span><br><span class="line">        change = FALSE;</span><br><span class="line">        for(j=0; j&lt;i; ++j)</span><br><span class="line">            if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">                a[j] &lt;--&gt; a[j+1];</span><br><span class="line">                change = TRUE</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; // bubble_sort</span><br></pre></td></tr></table></figure>

<p>基本操作：赋值操作 时间复杂度O(n)</p>
<h2 id="四、算法的存储空间需求："><a href="#四、算法的存储空间需求：" class="headerlink" title="四、算法的存储空间需求："></a>四、算法的存储空间需求：</h2><pre><code>算法的空间复杂度S(n) = O(g(n))
表示随着问题规模n的增大，算法运行所需存储量的增长率域g(n)的增长率相同</code></pre><h4 id="算法的存储量包括："><a href="#算法的存储量包括：" class="headerlink" title="算法的存储量包括："></a>算法的存储量包括：</h4><p>1、输入数据所占空间<br>2、程序本身所占空间<br>3、辅助变量所占空间</p>
<p>若输入数据所占空间只取决于问题本身与算法无关，则只需要分析输入和程序之外的辅助变量所占额外空间<br>若所需额外空间相对于输入数据量来说是常数，则称此算法为原地工作<br>若所需存储亮依赖于特定的输入，则通常按最坏情况考虑</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性结构是一个数据元素的有序次序集合。</p>
<p>线性结构的基本特征：<br>1/集合中必存在唯一的一个‘第一元素’<br>2、集合中比存在唯一的一个最后元素<br>3、除最后元素外，均有唯一的后继<br>4、除第一个元素之外，均有唯一的前驱</p>
<p>线性表的类型和定义<br> 抽象数据类型线性表的定义如下：<br> ADT List{<br>     数据对象：<br>     D={ai|ai(Elemset,i=1,2,……,n, n&gt;=0)}<br>     {<br>         称n为线性表的表长，称n=0时的线性表为空表。<br>     }<br>     数据关系：<br>     R = {&lt;ai-1, ai&gt;|ai-1,ai∈D, i= 2,……n}<br>     {设线性表为(a1,a2,……aj……an，称i为a在线性表中的位序)}<br>     基本操作：<br>     InitList(&amp;L){结构初始化}<br>     操作结果：构造一个空的线性表L<br>     DestoryList(&amp;L){销毁结构}<br>     初始条件：线性表L已存在<br>     操作结果：销毁线性表L<br>     {引用型操作}<br>     ListEmpyt(L)<br>     初始条件：线性表L已存在<br>     操作结果：若L为空表，则返回TRUE，否则FALSE<br>     ListLength(L)<br>     初始条件：线性表L已存在<br>     操作结果：返回L中元素个数<br>     PriorElem(L,cur_e,&amp;pre_e)<br>     初始条件：线性表L已存在<br>     操作结果：若cur_e是L的元素，但不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义<br>     NextElem(L,cur_e,&amp;next_e)<br>     初始条件：线性表L已存在<br>     操作结果：若cur_e是L的元素，但不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义<br>     GetElem(L,i,&amp;e)<br>     初始条件：线性表L已存在 1&lt;= i &lt;=LengthList(L)<br>     操作结果：用e返回L中第i个元素的值<br>     LocateElem(L,e,compare())<br>     初始条件：线性表L已存在，compare()是元素判定函数<br>     操作结果：返回L中第一个与e满足关系compare()的元素的位序，若这样的元素不存在，则返回值为0ßß<br>     ListTraverse(L, visit())<br>     初始条件：线性表L已存在<br>     操作结果：依次对L的每个元素调用函数visit()，一旦visit()失败，则操作失败<br>     {加工型操作}<br>     ClearList(&amp;L)<br>     初始条件：线性表L已存在<br>     操作结果：将L重置为空<br>     PutElem(L, i, &amp;e)<br>     操作结果:L中第i个元素赋值同e的值<br>     ListInsert(&amp;l, i, e)<br>     初始条件：线性表L已存在1&lt;= i &lt;=LengthList(L) + 1<br>     操作结果：在L的第i个元素之前插入新的元素e，L的长度增1<br>     ListDelete(&amp;L, i, &amp;e)<br>     初始条件：线性表L已存在且非空1&lt;= i &lt;=LengthList(L)<br>     操作结果：删除L的第i个元素，并用e返回其值，L的长度减1<br> }</p>
<p> 例2-1<br> 假设：有两个集合A和B分别用两个线性表LA和LB表示（即：线性表中的数据元素即为集合中的成员）<br> 现要求一个新的集合A = A ∪ B 并集。</p>
<p> 上述问题可演绎为要求对线性表做如下操作：<br> 扩大线性表LA，将存在于线性表LB中而不存在于线性表LA中的数据元素插入到线性LA中去。</p>
<p> 1、从线性表LB中依次取得每个数据元素: GetElem(LB，i) -&gt; e<br> 2、依值在线性表LA中进行查访：LocateElem(LA, e, equal())<br> 3、若不存在，则插入之：ListInsert(LA, n+1, e)</p>
<p> void union (List &amp;LA, List LB){<br>     // 求线性表的长度<br>     LA_len = ListLength(LA);<br>     LB_len = ListLength(LB);<br>     for(i=1; i&lt;= LB_len; i++){<br>         GetElem(LB, i, e);// 去LB中第i个元素赋给e<br>         if(!LocateElem(LA, e, equal()))<br>            ListInsert(LA, ++LA_len, e); // LA中不存在和e相同的数据元素，则插入<br>     }<br> }</p>
<p> 例2-2<br> 已知一个非纯集合B，试构造一个纯集合A，使A中包含B中所有值各不相同的数据元素</p>
<p> void purge(List&amp;La, List&amp;Lb){<br>     // 已知线性表Lb中包含非纯集合B中所有元素，试构造线性表La，使La只含Lb中所有值均不相同的元素<br>     InitList(La); // 设置空的线性表La<br>     La_len = ListLength(La);<br>     Lb_len = ListLength(Lb);<br>     // 求线性表的长度<br>     for(i=1; i&lt;=Lb.len; i++){<br>         GetElemt(Lb, i , e);<br>         // 从线性表Lb中取第i个元素<br>         if(!LocateElem(La, e, equal())){<br>             ++La_len;<br>             ListInsert(La,La_len, e);<br>             // 元素e插入线性表La<br>         }<br>     }<br> }</p>
<p> // 排序之后<br> void purge(List &amp;La, List Lb){<br>     InitList(LA);<br>     La_len = ListLength(La);<br>     Lb_len = ListLength(Lb);<br>     //求线性表的长度<br>     for(i=1; i&lt;Lb_len; i++){<br>         GetElem(Lb, i, e)<br>         //取Lb中第i个数据元素赋给e<br>         if(ListEmpty(LA)||!equal(en, e)){<br>             ListInsert(La, ++La_len, e);<br>             en = e;<br>         }<br>     }// La中不存在和e相同的数据元素，则插入<br> }</p>
<p> 例 2-3<br> 归并两个‘其数据元素按值非递减有序排列的’线性表LA和LB，求线性表LC也具有同样特性。<br> 1、分别从LA和LB中取得当前元素ai和bj<br> 2、若ai&lt;=bj,则将ai插入到LC中，否则将bj插入到LC中</p>
<p> void MergeList(List La,List Lb,List&amp;c){<br>     InitList(Lc);<br>     i = j =1; k = 0;<br>     La_len = ListLength(La);<br>     Lb_Len = ListLength(Lb);<br>     while((i&lt;=La_length)&amp;&amp;(j&lt;=Lb_len)){<br>         // La和Lb均非空<br>         GetElem(La, i, ai);<br>         GetElem(Lb, j, bj);<br>         if(ai&lt;=bj){<br>             ListInsert(Lc, ++k, ai);<br>             ++i<br>         } else {<br>             ListInsert(Lc, ++k, bj);<br>             ++j;<br>         }<br>     }<br>     while(i&lt;=La_len){<br>         GetElem(La, i++, ai);<br>         ListInsert(Lc, ++k, ai);<br>     }<br>     while(i&lt;=Lb_len){<br>         GetElem(Lb, j++, bj);<br>         ListInsert(Lc, ++k, bj);<br>     }<br> } // merge list</p>
<p> 线性表类型的实现-顺序映象<br> 用一组地址连续的存储单元，一次 存放 线性表中的数据元素<br> ——————————————————————————————<br> |a1|a2|a3|……ai-1|ai|ai|……|an|<br> ——————————————————————————————<br> a1线性表的起始地址，称作线性表的基地址<br> 以存储位置相邻表示有序对&lt;ai-1, ai&gt;即：<br> LOC(ai) = LOC(ai-1) + c<br> c: 一个数据元素所占存储量</p>
<p> 所有数据元素的存储位置均取决于第一个数据元素的存储位置：<br> LOC(ai) = LOC(a1) + (i-1)*c<br> LOC(a1)为基地址</p>
<p> 顺序映象的C语言描述<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define LIST_INIT_SIZE 80</span><br><span class="line">// 线性表存储空间 的初始分配量</span><br><span class="line">#define LISTINCREMENT 10</span><br><span class="line">// 线性表存储空间的分配增量</span><br><span class="line">Tydef Struct&#123;</span><br><span class="line">    ElemType *elem; // 存储空间基址</span><br><span class="line">    int Length；//当前长度</span><br><span class="line">    int listsize；// 当前分配的存储容量，以sizeof(ElemType)为单位</span><br><span class="line">&#125;SqList // 俗称顺序表</span><br></pre></td></tr></table></figure></p>
<p>线性表的初始化操作<br>Status InitList_Sq(SqList&amp;L){<br>    //构造一个空的线性表<br>    L.elem = (ElemType<em>)malloc(LIST_INIT_SIZE</em>sizeof(ElemType));<br>    if(!L.elem) exit(OVERFLOW);<br>    L.length = 0;<br>    L.listsize = LIST_INIT_SIZE<br>    return OK<br>} // InitList Sq</p>
<p>线性表操作<br>LocateElem(L,e, compare())<br>init LocateElem_Sq(SqList L, ElemType e,Status(<em>compare)(ElemType, ElemType)){<br>    i=1; // i的初始值为第一元素的位序<br>    p=L.elem;// p的初值为第一元素的存储位置<br>    while（i&lt;= L.length &amp;&amp; !(</em>compare)(*p++, e)）<br>        ++i<br>    if(i&lt;=L.length) return i;<br>    else return 0;<br>} // LocateElem_Sq</p>
<p>ListInsert(&amp;L, i, e)的实现<br>Status ListInsert_Sq(SqList &amp;L,int pos, Elemtype e){<br>    if(pos&lt;1|pos&gt;L.length) return ERROR;// 插入位置不合法<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/16/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/python/" itemprop="url">python</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T15:35:10+08:00">
                2019-08-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-25T10:26:46+08:00">
                2019-09-25
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/16/python/" class="leancloud_visitors" data-flag-title="python">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  64
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于计算机来说，二进制在物理器件上来说是最容易实现的（高压电表示1 ， 低压电表示0 ），于是冯 诺依曼结构的计算机都使用了二进制</p>
<p>量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息</p>
<h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><p>在程序设计中，变量时一种存储数据的载体，计算机中的变量时实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多类型，除了数值外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型，Python中的数据类型很多，而且也允许我们自定义新的数据类型,以下为几种常见的数据类型。</p>
<ul>
<li>整型： Python中可以处理任意大小的整数(Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此Python3.x中整数就只有int这一种了)，而且支持二进制、八进制、十进制、和十六进制的表示法</li>
<li>浮点型： 浮点数也就是小数，之所以称为浮点数，也是因为科学计数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法(123.456)之外还支持科学计数法(如1.2346e2)</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如’hello’和“hello”,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式(用三个单引号或三个双引号开头，是三个单引号三个双引号结尾)</li>
<li>布尔型：布尔值只有True,False两种值，在Python中，可以直接用True、False表示布尔值(请注意大小写)，也可以通过布尔运算计算出来（例如3&lt;5 会产生布尔值True，而 2==1 会产生布尔值False）。</li>
<li>复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部i换成了j</li>
</ul>
<p>数字：int和float，Python要支持其他类型的数字，例如Decimal或者Fraction。Python也内置对复数的支持，使用后缀j和J就可以表示虚数的部分（例：3+5j）<br>字符串：</p>
<ul>
<li>可以使用单引号(‘……’)，双引号(“……”)</li>
<li>反斜杠\可以用来转义，如果不希望前置\的字符转义成特殊字符，可以使用原始字符串方式，在引号前添加r即可</li>
<li>字符串字面值可以跨行连续输入，一种方式是用三重引号：”””……”””或’’’……’’’.字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个\即可。</li>
<li>字符串可以用+进行连接（粘到一起），也可以用*进行重复</li>
<li>相邻的两个或多个字符串字面值(引号引起来的字符)将会自动连接到一起，把很长的字符串拆开分别输入的时候尤其有用：只能对两个字面值这样操作，变量或者表达式不行，如果想连接变量，或者连接变量和字面值，可以用+号</li>
<li>字符串是可以被索引(下标访问)的，第一个字符索引是0，单个字符并没有特殊的类型，只是一个长度为一的字符串：</li>
<li>索引也可以是负数，这种会从右边开始数，-0和0是一样的，所以负数索引从-1开始</li>
<li>除了索引，字符春还支持切片，索引可以得到单个字符，而切片可以获取子字符串</li>
</ul>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>对于每个变量我们需要给它取一个名字，在Python中，变量命名需要遵循以下这些必须遵守的硬性规则：</p>
<p>硬性规则：</p>
<ul>
<li>变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头</li>
<li>大小写敏感（大写的A和小写的a是两个不同的变量）</li>
<li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突</li>
</ul>
<p>PEP 8 要求;</p>
<ul>
<li>用小写字母拼写，多个单词用下划线连接</li>
<li>受保护的实例属性用单个下划线开头</li>
<li>私有的实例属性用两个下划线开头</li>
</ul>
<p>作为一个专业的程序员，给变量事实上是所有的标识符命名时做到见名知意也是非常重要的。</p>
<h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><p>使用input()函数获取键盘输入<br>使用int()进行类型转换<br>用占位符格式化输出的字符串<br>用type()检查变量的类型<br>在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是我们后面要讲的创建对象的构造方法）</p>
<ul>
<li>int(): 将一个数值或字符串转换成整数，可以指定进制</li>
<li>float(): 讲一个字符串转换成浮点数</li>
<li>str(): 将指定的对象转换成字符串形式，可以指定编码</li>
<li>chr(): 将整数转换成改编码对应的字符串(一个字符)</li>
<li>ord(): 将字符串（一个字符）转换成对应的编码(整数)</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[] [:]</td>
<td>下标 切片</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
</tr>
<tr>
<td>~ + -</td>
<td>按位取反,正负号</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘 除 模 整除</td>
</tr>
<tr>
<td>+ -</td>
<td>加 减</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>右移 左移</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>^</td>
<td></td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>小于等于 小于 大于 大于等于</td>
</tr>
<tr>
<td>== !=</td>
<td>等于， 不等于</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>in not in</td>
<td>成分运算符</td>
</tr>
<tr>
<td>not or and</td>
<td>逻辑运算符</td>
</tr>
<tr>
<td>= += -= <em>= /= %= //= *</em>= &amp;= `</td>
<td>= ^= &gt;&gt;= &lt;&lt;= `</td>
</tr>
</tbody></table>
<p>== 说实话表格的最后一个我没看懂 = = </p>
<blockquote>
<p>说明：在实际开发中，如果搞不懂运算符的优先级，可以使用括号来确保运算的执行顺序</p>
</blockquote>
<p>和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于一个执行的整体。</p>
<h4 id="构造程序逻辑"><a href="#构造程序逻辑" class="headerlink" title="构造程序逻辑"></a>构造程序逻辑</h4><p>分支和循环结构会帮助我们将程序中逻辑建立起来，将来我们的程序无论简单复杂，都是由顺序结构、分支结构、循环结构构成的</p>
<h4 id="函数和模块的使用"><a href="#函数和模块的使用" class="headerlink" title="函数和模块的使用"></a>函数和模块的使用</h4><p>写出高质量的代码首先要解决的就是重复代码的问题。</p>
<p>X1+X2+X3+X4 = 8<br>这个问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。</p>
<p><img src="/images/Cmn.png" alt="求"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入M和N的计算C(M,N)</span><br><span class="line"></span><br><span class="line">m = int(input(&apos;m = &apos;))</span><br><span class="line">n = int(input(&apos;m = &apos;))</span><br><span class="line">fm = 1</span><br><span class="line">for num in range(1, m+1):</span><br><span class="line">    fm* = num //求m的阶乘</span><br><span class="line"></span><br><span class="line">fn = 1</span><br><span class="line">for num in range(1, n+1):</span><br><span class="line">    fn *= num // 求n的阶乘</span><br><span class="line"></span><br><span class="line">fmn = 1</span><br><span class="line">for num in range(1, m-n+1):</span><br><span class="line">    fmn *= num // 求m-n的阶乘</span><br><span class="line"></span><br><span class="line">print(fm//fn/fmn)</span><br></pre></td></tr></table></figure>

<p>定义函数<br>在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上的函数的因变量</p>
<p>重构之后的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def factorial(num):</span><br><span class="line">    求阶乘</span><br><span class="line">    ：param num：非负整数</span><br><span class="line">    ：return：num 的阶乘</span><br><span class="line"></span><br><span class="line">    result = 1</span><br><span class="line">    for n range(1, num+1):</span><br><span class="line">        result *= n</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">    m = int(input(&apos;m= &apos;))</span><br><span class="line">    n = int(input(&apos;n= &apos;))</span><br><span class="line"></span><br><span class="line">    # 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数</span><br><span class="line"></span><br><span class="line">    print(factrial(m)//factrial(n)//factrial(m-n))</span><br></pre></td></tr></table></figure>

<p>说明：python的math模块中其实已经有一个factorial函数，事实上要计算阶乘可以直接会用这个现成的函数而不用自已定义。</p>
<p>函数的参数</p>
<p>函数是绝大多数编程语言中都支持的一个代码的构建块，但是python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是python对函数参数的处理，在python中，函数的参数可以有默认值，也支持可变参数，所以Python并不需要像其他语言一直支持函数的重载，因为我们在定义一个函数的时候可以让它有不同的使用方式</p>
<p><strong>重载</strong>: 就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数或者方法之间，相互称之为重载函数或方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from random import radiant</span><br><span class="line"></span><br><span class="line">def roll_dice(n = 2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    摇筛子</span><br><span class="line"></span><br><span class="line">    :param n :筛子的个数</span><br><span class="line">    :return: n颗筛子点数之和</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    total = 0</span><br><span class="line">    for _ in range(n):</span><br><span class="line">        total += randiant(1, 6)</span><br><span class="line">    return total</span><br><span class="line"></span><br><span class="line">def add(a=0, b=0, c=0):</span><br><span class="line">    return a+b+c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果没有指定参数那么使用默认值摇两颗筛子 n=2</span><br><span class="line">print(roll_dice())</span><br><span class="line"></span><br><span class="line">#摇三颗筛子</span><br><span class="line">print(roll_dice(3))</span><br><span class="line">print(add())</span><br><span class="line">print(add(1))</span><br><span class="line">print(add(1,2))</span><br><span class="line">print(add(1,2,3))</span><br><span class="line"></span><br><span class="line">#传递参数时可以不按照设定的顺序进行传递</span><br><span class="line">print(add(c=50,a=100,b=200))</span><br></pre></td></tr></table></figure>

<p>我们在给上面两个函数的参数都设定了默认值，这也就意味着如果在调用的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。</p>
<p>其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定的，我们作为函数的设计对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下：</p>
<h1 id="在参数名前面的-表示args是一个可变参数"><a href="#在参数名前面的-表示args是一个可变参数" class="headerlink" title="在参数名前面的*表示args是一个可变参数"></a>在参数名前面的*表示args是一个可变参数</h1><h1 id="即在调用add函数时可以传入0个或多个参数"><a href="#即在调用add函数时可以传入0个或多个参数" class="headerlink" title="即在调用add函数时可以传入0个或多个参数"></a>即在调用add函数时可以传入0个或多个参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def add(*args):</span><br><span class="line">    total = 0</span><br><span class="line">    for val in args:</span><br><span class="line">        total += val</span><br><span class="line">    return total</span><br><span class="line"></span><br><span class="line">print(add())</span><br><span class="line">print(add(1))</span><br><span class="line">print(add(1, 2))</span><br><span class="line">print(add(1, 2, 3))</span><br><span class="line">print(add(1, 3, 5, 7, 9))</span><br></pre></td></tr></table></figure>

<p>用模块管理函数</p>
<p>对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么就意味两个函数同名函数实际上只有一个是存在的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&apos;hello, world!&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&apos;goodbye, world!&apos;)</span><br></pre></td></tr></table></figure>

<p>当然上面的情况很容易就能避免，但是如果项目是由多人呢协作进行团队开发的时候，团队中可能有多个程序都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案很简单，Python中每个文件就代表了衣蛾模块module，我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。</p>
<p>module1.py</p>
<p>def foo():<br>    print(‘hello world!’)</p>
<p>module2.py</p>
<p>def foo():<br>    print(‘goodbye, world’)</p>
<p>test.py<br>    from module1 import foo<br>    # 输出hello, world！<br>    foo()<br><br>    from module2 import foo<br>    #输出”goodbye world!”<br>    foo()</p>
<p>也可以按照如下所示的方式来区分到底要使用哪一个foo函数</p>
<p>test.py<br>import module1 as m1<br>import module2 as m2</p>
<p>m1.foo()<br>m2.foo()</p>
<p>但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。</p>
<p>test.py</p>
<p>from module1 import foo<br>from module2 import foo</p>
<h1 id="输出goodbye，world！"><a href="#输出goodbye，world！" class="headerlink" title="输出goodbye，world！"></a>输出goodbye，world！</h1><p>foo()</p>
<p>test.py</p>
<p>from module2 import foo<br>from module1 import foo</p>
<h1 id="输出hello-world"><a href="#输出hello-world" class="headerlink" title="输出hello world"></a>输出hello world</h1><p>foo()</p>
<p>需要说明的是如果我们导入的模块除了定义函数之外还可以有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“_main_”</p>
<p>module3.py</p>
<p>def foo():<br>    pass</p>
<p>def bar():<br>    pass</p>
<h1 id="name-是Python中一个隐含的变量它代表了模块的名字"><a href="#name-是Python中一个隐含的变量它代表了模块的名字" class="headerlink" title="_name_是Python中一个隐含的变量它代表了模块的名字"></a>_name_是Python中一个隐含的变量它代表了模块的名字</h1><h1 id="只有被Python解释器执行的模块的名字才是main"><a href="#只有被Python解释器执行的模块的名字才是main" class="headerlink" title="只有被Python解释器执行的模块的名字才是main"></a>只有被Python解释器执行的模块的名字才是<em>main</em></h1><p>if <em>_name == ‘_main</em>‘:<br>    print(‘call foo()’)<br>    foo()<br>    print(‘call bar()’)<br>    bar()</p>
<p>test.py</p>
<pre><code>import module3

# 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是_main_</code></pre><p>当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们要定义和使用函数的一个非常重要的原因</p>
<h5 id="Python中有关变量作用域的问题"><a href="#Python中有关变量作用域的问题" class="headerlink" title="Python中有关变量作用域的问题"></a>Python中有关变量作用域的问题</h5><p>def foo():<br>    b = ‘Hello’</p>
<pre><code>def bar(): #Python中可以在函数内部再定义函数
    c = True
    print(a)
    print(b)
    print(c)

bar()
# print(c) NameError:name c is not defined</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    a = 100<br>    # print(b) #NameError: name ‘b’ is not defined<br>    foo()</p>
<p>上面的代码能够顺利的执行并且打印出100和‘Hello’，但我们注意到了在bar的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量(global variable),属于全局作用域，因为它没有定义在任何一个函数中，在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它。但是对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的，bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的，事实上，Python查找一个变量会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码已经看到了，所谓的内置作用域就是Python内置的那些隐含标识符min 、len等都属于内置作用域</p>
<p>下面的代码，希望通过函数调用修改全局变量a的值，但是实际上下面的代码是做不到的。<br>def foo():<br>    a = 200<br>    print(a)  # 200</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    a = 100<br>    foo()<br>    print(a) # 100</p>
<p>在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因为foo函数不在搜索全局作用域的中a，如果我们希望在foo函数中修改全局作用域中的a，代码如下所示：<br>    def foo():<br>        global a<br>        a = 200<br>        print(a)  # 200</p>
<pre><code>if __name__ == &apos;__main__&apos;:
    a = 100
    foo()
    print(a) # 200</code></pre><p>我们在使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域。</p>
<p>在实际开发中，我们应该应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能会导致对象占用内存长时间无法被垃圾回收。事实上减少对全局变量的使用，也是减低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其函数调用结束后依然可以访问，这时候就需要使用闭包。</p>
<p>我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。</p>
<p>def mian():<br>    # Todo: Add your code here<br>    # 局部作用域<br>    pass</p>
<p>if <strong>name</strong> = ‘<strong>main</strong>‘<br>    #全局作用域<br>    main()</p>
<h4 id="字符串和常用数据结构"><a href="#字符串和常用数据结构" class="headerlink" title="字符串和常用数据结构"></a>字符串和常用数据结构</h4><h5 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h5><p>今天的计算机更多的时间需要处理的数据可能都是以文本的方式存在的，如果我们希望通过Python程序操作这些文本信息，就必须要先了解字符串类型以及与它相关的知识。</p>
<p>所谓字符串，就是由零个或多个字符组成的有限序列，一般记为s = a1a2a3……an(0&lt;=n&lt;=∞)</p>
<p>我们可以通过下面的代码来了解字符串的使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    str1 = &apos;hello world!&apos;</span><br><span class="line">    # 通过len函数计算字符串的长度</span><br><span class="line">    print(len(str1))  # 13</span><br><span class="line">    # 获得字符串首字母大写的拷贝</span><br><span class="line">    print(str1.capitalize()) # Hello, world!</span><br><span class="line">    # 获得字符串变大写后的拷贝</span><br><span class="line">    print(str1.upper())  # HELLO, WORLD!</span><br><span class="line">    # 从字符串中查找子串所在位置</span><br><span class="line">    print(str1.find(&apos;or)) # 8</span><br><span class="line">    print(str1.find(&apos;shit&apos;)) # -1</span><br><span class="line">    # 与find类似但找不到子串时会引发异常</span><br><span class="line">    # print(str1.index(&apos;or&apos;))</span><br><span class="line">    # print(str1.index(&apos;shit&apos;))</span><br><span class="line">    # 检查字符串是否以指定的字符串开头</span><br><span class="line">    print(str1.startwith(&apos;He&apos;))  # False</span><br><span class="line">    print(str1.startwith(&apos;hel&apos;)) # True</span><br><span class="line">    # 检查字符串是否以指定的字符串结尾</span><br><span class="line">    print(str1.endswith(&apos;!&apos;)) # True</span><br><span class="line">    # 将字符串以指定的宽度居中并在两侧填充指定的字符</span><br><span class="line">    print(str1.center(50, &apos;*&apos;))</span><br><span class="line">    # 将字符串以指定的宽度靠右并在左侧填充指定的字符</span><br><span class="line">    print(str1.rjust(50, &apos;*&apos;))</span><br><span class="line">    str2 = &apos;abc123456&apos;</span><br><span class="line">    # 从字符串中取出指定位置的字符(下标计算)</span><br><span class="line">    print(str2[2])  # c</span><br><span class="line">    # 字符串切片(从指定的开始索引到指定的结束索引)</span><br><span class="line">    print(str2[2:5]) # c12</span><br><span class="line">    print(str2[2:])  # c123456</span><br><span class="line">    print(str2[2::2]) # c246</span><br><span class="line">    print(str2[::2]) # ac246</span><br><span class="line">    print(str2[::-1]) # 654321cba</span><br><span class="line">    print(str2[-3:-1]) # 45</span><br><span class="line">    # 检查字符串是否由数字构成</span><br><span class="line">    print(str2.isdigit()) # False</span><br><span class="line">    # 检查字符串是否以字母构成</span><br><span class="line">    print(str2.isalpha) # False</span><br><span class="line">    # 检查字符串是否是以数字和字母构成</span><br><span class="line">    print(str2.isalnum()) # True</span><br><span class="line">    str3 = &apos;  jackfrued@126.com&apos;</span><br><span class="line">    print(str3)</span><br><span class="line">    # 获得字符串修剪左右两侧空格的拷贝</span><br><span class="line">    print(str3.strip())</span><br><span class="line"></span><br><span class="line">    if __name__ == &apos;__main__&apos;:</span><br><span class="line">        main()</span><br><span class="line"></span><br><span class="line">    除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数的时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。</span><br><span class="line"></span><br><span class="line">##### 使用列表</span><br><span class="line">    下面的列表演示了如何定义列表，使用下标访问列表元素以及添加和删除元素的操作</span><br><span class="line">    def main()</span><br><span class="line">        list1 = [1,3,5,7,100]</span><br><span class="line">        print(list1)</span><br><span class="line">        list2 = [&apos;hello&apos;] * 5</span><br><span class="line">        print(list2)</span><br><span class="line">        # 计算列表长度元素个数</span><br><span class="line">        print(len(list1))</span><br><span class="line">        # 下标(索引)运算</span><br><span class="line">        print(list1[0])</span><br><span class="line">        print(list1[4])</span><br><span class="line">        # print(list1[5]) # IndexError: list index out of range</span><br><span class="line">        print(list1[-1])</span><br><span class="line">        print(list1[-3])</span><br><span class="line">        list1[2] = 300</span><br><span class="line">        print(list1)</span><br><span class="line">        # 添加元素</span><br><span class="line">        list1.append(200)</span><br><span class="line">        list1.insert(1, 400)</span><br><span class="line">        list1 += [1000, 2000]</span><br><span class="line">        print(list1)</span><br><span class="line">        print(len(list1))</span><br><span class="line">        # 删除元素</span><br><span class="line">        list1.remove(3)</span><br><span class="line">        if 1234 in list1:</span><br><span class="line">            list1.remove(1234)</span><br><span class="line">        del list1[0]</span><br><span class="line">        print(list1)</span><br><span class="line">        # 清空列表元素</span><br><span class="line">        list1.clear()</span><br><span class="line">        print(list1)</span><br><span class="line"></span><br><span class="line">        if __name__ == &apos;__main__&apos;</span><br><span class="line">            main()</span><br></pre></td></tr></table></figure>

<p>和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示：<br>def main():<br>    fruits = [‘grape’, ‘apple’, ‘strawberry’, ‘waxberry’]<br>    fruits += [‘pitaya’, ‘pear’, ‘mango’]<br>    # 循环遍历列表元素<br>    for fruit in fruits:<br>        print(fruit.title(), end=’ ‘)<br>    print()<br>    # 列表切片<br>    fruits2 = fruits[1:4]<br>    print(fruits2)<br>    # fruits3 = fruits # 没有复制列表只是创建了新的引用<br>    # 可以通过完整切片操作来复制列表<br>    fruits3 = fruits[:]<br>    print(fruits3)<br>    fruits4 = fruits[-3:-1]<br>    print(fruits4)<br>    # 可以通过反向切片操作来获得倒转后的列表的拷贝<br>    fruits5 = fruits[::-1]<br>    print(fruits5)</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p>
<p>下面的代码实现了对列表的排序操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    list1 = [&apos;orange&apos;, &apos;apple&apos;, &apos;zoo&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;]</span><br><span class="line">    list2 = sorted(list1)</span><br><span class="line">    # sorted函数返回列表排序后的拷贝不会修改传入的列表</span><br><span class="line">    # 函数的设计就应该像sorted函数一样尽可能不产生副作用</span><br><span class="line">    list3 = sorted(list1, reverse=True)</span><br><span class="line">    # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序</span><br><span class="line">    list4 = sorted(list1, key=len)</span><br><span class="line">    print(list1) # [&apos;orange&apos;, &apos;apple&apos;, &apos;zoo&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;]</span><br><span class="line">    print(list2) # [&apos;apple&apos;, &apos;blueberry&apos;, &apos;internationalization&apos;, &apos;orange&apos;, &apos;zoo&apos;]</span><br><span class="line">    print(list3) # [&apos;zoo&apos;, &apos;orange&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;, &apos;apple&apos;]</span><br><span class="line">    print(list4) # [&apos;zoo&apos;, &apos;apple&apos;, &apos;orange&apos;, &apos;blueberry&apos;, &apos;internationalization&apos;]</span><br><span class="line">    # 给列表对象发出排序消息直接在列表对象上进行排序</span><br><span class="line">    list1.sort(reverse=True)</span><br><span class="line">    print(list1) # [&apos;zoo&apos;, &apos;orange&apos;, &apos;internationalization&apos;, &apos;blueberry&apos;, &apos;apple&apos;]</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__mian__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>还可以使用列表的生成式语法来创建列表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    f = [x for x in range(1, 10)] </span><br><span class="line">    print(f) # [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">    f = [x + y for x in &apos;ABCD&apos; for y in &apos;1234567&apos;]</span><br><span class="line">    print(f) </span><br><span class="line">    # [&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;A4&apos;, &apos;A5&apos;, &apos;A6&apos;, &apos;A7&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;B4&apos;, &apos;B5&apos;, &apos;B6&apos;, &apos;B7&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;, &apos;C4&apos;, &apos;C5&apos;, &apos;C6&apos;, &apos;C7&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;, &apos;D4&apos;, &apos;D5&apos;, &apos;D6&apos;, &apos;D7&apos;]</span><br><span class="line">    # 用列表的生成表达式语法创建列表容器</span><br><span class="line">    # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间</span><br><span class="line">    f = [x ** 2 for x in range(1, 1000)]</span><br><span class="line">    print(sys.getsizeof(f)) # 查看对象占用内存的字节数</span><br><span class="line">    # 9024</span><br><span class="line">    print(f)</span><br><span class="line">    # [1,4,9,16,25……,998001]</span><br><span class="line">    # 请注意下面的代码创建的不是一个列表而是一个生成器对象</span><br><span class="line">    # 通过生成器可以获取到数据但它不占用额外的空间存储数据</span><br><span class="line">    # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)</span><br><span class="line">    f = (x ** 2 for x in range(1, 1000))</span><br><span class="line">    print(sys.getsizeof(f)) # 相比生成式生成器不占存储数据的空间</span><br><span class="line">    # 120</span><br><span class="line">    print(f)</span><br><span class="line">    # 1</span><br><span class="line">    # 4</span><br><span class="line">    # ...</span><br><span class="line">    # 998001</span><br><span class="line">    for val in f:</span><br><span class="line">        print(val)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现衣蛾生成斐波那契数列的生成器。所谓的斐波那契数列可以通过下面的递归的方法来进行定义：<br>F0 = 0；<br>F1 = 1；<br>Fn = Fn-1 + Fn-2(n &gt;= 2)</p>
<h5 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h5><p>Python的元组与列表类似，不同之处在于元组的元素不能修改，在前面的d代码中我们已经不止一次使用过元组了，顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    # 定义元组</span><br><span class="line">    t = (&apos;张三&apos;, &apos;24&apos;, True, &apos;上海&apos;)</span><br><span class="line">    print(t)</span><br><span class="line">    # 获取元组中的元素</span><br><span class="line">    print(t[0])</span><br><span class="line">    print(t[3])</span><br><span class="line">    # 遍历元组中的值</span><br><span class="line">    for member in t:</span><br><span class="line">        print(member)</span><br><span class="line">    # 重新给元组赋值</span><br><span class="line">    # t[0] = &apos;王大锤&apos; # typeError</span><br><span class="line">    # 变量t重新引用了新的元组原来的元组将被辣鸡回收</span><br><span class="line">    t = (&apos;王大锤&apos;, 20, True, &apos;云南昆明&apos;)</span><br><span class="line">    print(t)</span><br><span class="line">    # 将元组转换成列表</span><br><span class="line">    person = list(t)</span><br><span class="line">    print(person)</span><br><span class="line">    # 列表是可以修改它的元素</span><br><span class="line">    person[0] = &apos;李四&apos;</span><br><span class="line">    person[1] = &apos;25&apos;</span><br><span class="line">    print(person)</span><br><span class="line"></span><br><span class="line">    # 将列表转换成元组</span><br><span class="line">    fruits_list = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;]</span><br><span class="line">    fruits_tuple = tuple(fruits_list)</span><br><span class="line">    print(fruits_tuple)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？<br>1、元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境中可能会更喜欢使用的是那些不变对象(一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护，另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销，一个不变对象可以方便的被共享访问)。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。<br>2、元组在创建时间和占用空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间</p>
<h5 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h5><p>Python中的集合跟数学上的集合是一致的，<strong>不允许有重复元素</strong>，而且可以进行交集、并集、差集等运算</p>
<p>##<br>Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以两个下划线作为开头，</p>
<p>Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对他们的访问，事实上你知道更换名字的规则仍然可以访问到他们，所以更多的时候它是一种暗示或隐喻</p>
<h1 id="面向对象的支柱"><a href="#面向对象的支柱" class="headerlink" title="面向对象的支柱"></a>面向对象的支柱</h1><p>面向对象有三大支柱：封装 继承 多态。<br>封装：隐藏一切可以隐藏的实现细节，只向外界暴露提供简单的变成接口。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的视图）。而不需要知道方法内部实现细节</p>
<p>@property装饰器<br>之前我们讨论过python中的属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将<br>属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter访问器，和setter修改器方法进行对应的操作。如果要做到这点，就可以考虑使用<br>@property包装getter和setter方法，使得对属性的访问即安全又方便。</p>
<p>class Person(object):<br>    def <strong>init</strong>(self, name, age):<br>        self._name = name<br>        self._age = age</p>
<pre><code># 访问器 - getter方法
@property
def name(self):
    return self._name

# 访问器 - getter方法
@property
def age(self):
    return self._age

# 修改器 - setter方法
@age.setter
def age(self, age):
    self._age = age

def play(self):
    if self._age &lt;= 16:
        print(&apos;%s正在玩飞行棋&apos; % self._name)
    else:
        print(&apos;%s正在斗地主&apos; % self._name)</code></pre><p>def main():<br>    person = Person(‘王法’, 12)<br>    person.play()<br>    person.age() = 22<br>    person.paly()<br>    # person.name = ‘sss’ Error: can’t set attribute</p>
<p>if <strong>name</strong> == ‘<strong>mian</strong>‘:<br>    main()</p>
<h5 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="slots 魔法"></a><strong>slots</strong> 魔法</h5><p>Python是一门动态语言，动态语言允许我们在程序运行时给对象绑定新的属性和方法，当然也可以对已经绑定的属性和方法进行解绑定，但是如果我们需要限定自定义类型<br>的对象只能绑定某些属性，可以通过类中定义<strong>slots</strong>变量来进行限定。需要注意的是<strong>slots</strong>的限定只对当前类的对象生效，对子类并不起任何作用。<br>class Person(object)<br>    # 限定Person对象只能绑定<em>name,<em>age和 _gender属性<br>    __slots</em></em> = (‘<em>name’, ‘<em>age’, ‘_gender’)<br><br>    def __init</em></em>(self, name, age):<br>        self._name = name<br>        self._age = age<br><br>    @property<br>    def name(self):<br>        return self._name<br><br>    @property<br>    def age(self):<br>        return self._age<br><br>    @age.setter<br>    def age(self, age):<br>        self._age = age<br><br>    def play(self):<br>        if self._age &lt;= 16:<br>            print(‘%s正在玩飞行棋’ % self._name)<br>        else:<br>            print(‘%s正在斗地主’ % self._name)</p>
<p>def main():<br>    person = Person(‘王大锤’, 22)<br>    person.play()<br>    person._gender = ‘男’</p>
<h5 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h5><p>之前我们在类中定音的方法都是对象方法，也就是说这些方法都是发送给对象的消息，实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义<br>一个三角形类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边未必能构造出三角形对象，因此我们可以先写一个方法<br>来验证三条边是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来， 因为不知道三条边能不能构成三角形，所以这个方法是属于三角形类而不属于三角形对象的。我们可以使用静态方法来解决这类问题。</p>
<p>和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象，类本身也是一个对象，有的地方也称之为类的元数据对象，通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象</p>
<h5 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h5><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系</p>
<ul>
<li>is-a关系也叫继承或泛化，比如学生和人的关系。手机和电子产品的关系都属于继承关系</li>
<li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系，关联关系如果是整体和部分的关联，那么我们称为聚合关系，如果整体进一步负责了部分的生命周期，整体和部分是不可分割的，同时同在也同时消亡，那么这种就是最强的关联关系，我们称之为合成关系</li>
<li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中的参数使用到了汽车，那么司机和汽车的关系就是依赖关系</li>
</ul>
<p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段<br>复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常生活中都会使用到的技术手段</p>
<p>继承和多态<br>可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写，提供继承信息的我们称之为父类，也叫超类或基类，得到继承信息的我们称为子类，也叫派生类或衍生类，子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称为里氏替换原则</p>
<p>‘’’<br>继承<br>‘’’</p>
<p>class Person(object):<br>    “”” 人 “””<br>    def <strong>init</strong>(self, name, age)；<br>        self._name = name<br>        self._age = age</p>
<pre><code>@property
def name(self):
    return self._name

@property
def age(self):
    return self._age

@age.setter
def age(self, age):
    self._age = age

def play(self):
    print(&apos;%s正在愉快的玩耍&apos; % self._name)

def watch_av(self):
    if self._age &gt;= 18:
        print(&apos;%s正在看枪战&apos; % self._name)
    else:
        print(&apos;%s只能观看熊出没&apos; % self._name)</code></pre><p>class Student(Person):<br>    “”””学生”””<br>    def <strong>init</strong>(self, name, age, grade):<br>        super().<strong>init</strong>(name, age)<br>        self._grade = grade</p>
<pre><code>@property
def grade(self):
    return self._grade

@grade.setter
def grade(self, grade):
    self._grade = grade

def study(self, course):
    print(&apos;%s的%s正在学习%s。&apos; %(self._grade, self._name, course))</code></pre><p>class Teacher(Person):<br>    “”””老师”””</p>
<pre><code>def __init__(self, name, age, title):
    super().__init__(name, age)
    self._title = title

@property
def title(self):
    return self._title

@title.setter
def title(self, title):
    self._title = title

def teach(self, course):
    print(&apos;%s%s正在讲%s&apos; % (self._name, self._title, course))</code></pre><p>def mian():<br>    stu = Student(‘王大锤’, 15, ‘初三’)<br>    stu.study(‘数学’)<br>    stu.watch_av()<br>    t = Teacher(‘李四’, 24, ‘教授’)<br>    t.teach(‘Python程序设计’)<br>    t.watch_av()</p>
<p>if name == ‘<strong>main</strong>‘:<br>    main()    </p>
<p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写override。通过方法重写我们可以让父类的同一个行为在不同的子类中有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态poly-morphism</p>
<p>from abc import ABCMeta, abstractmethod</p>
<p>class Pet(object, metaclass=ABCMeta):<br>    “””宠物”””<br>    def <strong>init</strong>(self, nickname):<br>        self._nickname = nickname</p>
<pre><code>@abstractmethod
def make_voice(self):
    &quot;&quot;&quot;&quot;发出声音&quot;&quot;&quot;
    pass</code></pre><p>calss Dog(Pet):<br>    “””狗”””</p>
<pre><code>def make_voice(self):
    print(&apos;%s: 汪汪汪……&apos; % self._nickname)</code></pre><p>class Cat(Pet):<br>    “””猫”””</p>
<pre><code>def make_voice(self):
    print(&apos;%s: 喵……喵&apos; % self._nickname)</code></pre><p>def main():<br>    pets = [Dog(‘旺福’), Cat(‘凯蒂’), Dog(‘大黄’)]<br>    for pet in pets:<br>        pet.make_voice()</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p>
<p>在上面的代码上，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它，Python从语法层面并没有像Java和C#那样<br>提供对抽象类的支持，但是我们通过abc模块额ABCMeta元类和abstractmethod包装器来达到抽象类的效果如果一个类中存在抽象方法那么这个类就不能被实例化（创建对象），上面的代码中<br>Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事）</p>
<p>图形用户界面的游戏开发<br>基于tkinter模块的GUI</p>
<p>GUI是图形用户界面的缩写，图形化的用户界面面对使用过计算机的人来说并不陌生，Python默认的GUI开发模块时tkinter（在Python 3以前的版本中名为Tkinter），提供了跨平台的GUI控件</p>
<p>基本上使用tkinter开发GUI应用需要以下5个步骤:<br>    1、导入tkinter模块中我们需要的东西<br>    2、创建一个顶层窗口对象并用它来承载整个GUI应用<br>    3、在顶层窗口对象上添加GUI组件<br>    4、通过代码将这些GUI组件的功能组织起来<br>    5、进入主事件循环 main loop</p>
<p>需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标，键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环<br>一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer开发者提供空间的大小和摆放位置、<br>Packer自动将控件填充到合适的位置和Grid基于网格坐标来摆放控件</p>
<p>使用Pygame进行游戏开发<br>Pygame是一个开源的Python模块，专门用于多媒体应用如电子游戏的开发，其中包含对图像、声音、视频、事件、碰撞等的支持，Pygame建立在SDL的基础上，SDL是一套跨平台的多媒体开发库，用C<br>语言实现，被广泛应用于游戏、模拟器、播放器等的开发，而Pygame让游戏开发者不在被底层语言束缚，可以更多的关注游戏的功能和逻辑。</p>
<p>体会如何使用面向对象程序设计，学会用这种编程思想去解决现实中的问题</p>
<p>在窗口中绘图</p>
<p>可以通过pygame中draw模块的函数在窗口上绘图，可以绘制的图形包括：线条 矩形 多边形 圆 椭圆 圆弧 等，需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点(0, 0)<br>,向右是x轴的正向，向下是y轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是像素。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将将图片放大若干倍<br>就可以看到这些点，pygame中表示颜色用的是色光三原色表示法，即通过一个元组或列表来指定颜色的RGB值，每个值都在0~255之间，因为是每个原色都用一个8位bit的值来表示<br>三种颜色相当于一共由24位构成，这也就是常说的24位颜色表示法</p>
<p>加载图像</p>
<p>如果需要直接加载图像到窗口上，可以使用pygame中image模块的函数来加载图像，再通过之前获得的窗口对象的blit方法渲染图像，代码如下所示：</p>
<p>实现动画效果</p>
<p>就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果，如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在<br>循环中修改小球的位置在刷新整个窗口即可</p>
<p>碰撞检测</p>
<p>通常一个游戏中会有很多对象出现，而这些对象之间的碰撞在所难免，比如炮弹击中了飞机，箱子撞击了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame<br>的sprite动画精灵，模块就提供了对碰撞检测的支持，这里我们暂不介绍sprite模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查<br>球心距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球</p>
<p>事件处理</p>
<p>可以在事件循环中对鼠标事件进行处理，通过事件对象的type属性可以判定事件类型，再通过pos属性就可以获得鼠标点击的位置，如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似</p>
<p>刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程知识后，用一个后台线程来处理这些是更好的选择，希望获得更好的用户体验，可以在游戏红加入背景音乐<br>以及在球与球碰撞时播放音效，利用pygame的mixer和music模块，我们可以很容易做到这一点，3D游戏，pygame就显得力不从心了，对3D游戏开发如果有兴趣的读者可以看看Panda3D</p>
<p>pygame官方网站：<a href="https://www.pygame.org/news" target="_blank" rel="noopener">https://www.pygame.org/news</a><br>Panda3D官方网站：<a href="https://www.panda3d.org/" target="_blank" rel="noopener">https://www.panda3d.org/</a></p>
<h6 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h6><p>实际开发中尝尝会遇到对数据进行持久化操作的场景，而实现数据持久化最直接简单的方式就是将数据保存在文件中。说到文件这个词，要先讨论下文件系统</p>
<p>在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名，操作模式，编码信息等来获得操作文件的对象，接下来就可以对文件进行<br>读写操作了，这里说的操作模式是指要打开什么的文件，字符文件还是二进制文件以及做什么样的操作，读、写还是追加，具体如下：</p>
<p>操作模式 | 具体含义<br>        | </p>
<p>‘r’| 读取(默认)<br>‘w’| 写入(会先截断之前的内容)<br>‘x’| 写入，如果文件已经存在会产生异常<br>‘a’| 追加， 将内容写入到已有文件的末尾<br>‘b’| 二进制模式<br>‘t’| 文本模式(默认)<br>‘+’| 更新(既可以读又可以写)</p>
<p>读写文本文件</p>
<pre><code>读取文本文件时，需要在使用open函数时指定好带路径的文件名，可以使用相对路径或绝对路径，并将文件模式设置为&apos;r&apos;，如果不指定默认也是&apos;r&apos;,然后通过encoding</code></pre><p>参数指定编码如果不指定，默认值是Node，那么在读取文件时使用的是操作系统默认的编码，如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的<br>那么可能因为无法解码字符而导致读取失败</p>
<p>如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况异常状况导致程序崩溃，为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生<br>状况的代码进行适当的处理</p>
<p>在Python中，我们可以将那些在运行时可能会出现的状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。<br>文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError,而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try<br>后面跟了三个except分别处理这三种不同的异常。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块代码不论程序正常还是异常都会执行<br>到甚至是调用了sys模块的exit函数退出python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常，因此我们通常把finally块称为总是执行代码块，它最适合用来<br>做释放外部资源的操作，如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境是自动释放文件资源。</p>
<p>除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用realines方法将文件按行读取到一个列表容器中</p>
<p>要将文本信息写入文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为’w’即可，注意如果需要对文本内容进行追加式写入，应该将模式设置为’a’。如果要写入的文件不存在<br>会自动创建文件而不是引发异常。</p>
<p>读写二进制文件<br>    知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能</p>
<p>读写JSON文件<br>    如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是JavaScript Object Notation的缩写，它本来是JavaScript语言中<br>创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的，目前JSON基本上已经<br>取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的参考JSON官方网站：<a href="http://json.org/，可参考每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个" target="_blank" rel="noopener">http://json.org/，可参考每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个</a><br>JSON的简单例子</p>
<p>{<br>    “name”: “骆昊”,<br>    “age”: 38,<br>    “qq”: 957658,<br>    “friends”: [“王大锤”, “白元芳”],<br>    “cars”: [<br>        {“brand”: “BYD”, “max_speed”: 180},<br>        {“brand”: “Audi”, “max_speed”: 280},<br>        {“brand”: “Benz”, “max_speed”: 320}<br>    ]<br>}</p>
<p>JSON和Python中的字典其实是一样的，JSON的数据类型和Python的数据类型是很容易找到对应关系。</p>
<p>JSON | Python<br>object | dict<br>array | list, tuple<br>string | str<br>number(int/real)  int/float<br>true/false | True/False<br>null | None</p>
<p>json模块主要有四个比较重要的函数：<br>dump - 将Python对象按照JSON格式序列化到文件中<br>dumps - 将Python对象处理成JSON格式的字符串<br>load - 将文件中的JSON数据反序列化成对象<br>loads -将字符串的内容反序列化成Python对象</p>
<p>这里出现了两个概念，一个叫序列化，一个叫反序列化，“序列化”serialization在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式<br>这样在需要的时候能够恢复到原本的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一<br>系列字节中提取数据结构的操作，就是反序列化（deserialization）</p>
<p>目前绝大多数网络数据服务，或者网络api都是基于HTTP协议提供JSON格式的数据，<br>HTTP协议入门：<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a><br>了解国内的网络数据服务： 聚合数据： <a href="https://www.juhe.cn/" target="_blank" rel="noopener">https://www.juhe.cn/</a>  阿凡达数据：<a href="https://www.avatardata.cn/" target="_blank" rel="noopener">https://www.avatardata.cn/</a>  <a href="http://apis.io/" target="_blank" rel="noopener">http://apis.io/</a></p>
<p>如何使用requests模块，封装的足够好的第三方网络访问模块，访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题<br>天行数据：<a href="https://www.tianapi.com/" target="_blank" rel="noopener">https://www.tianapi.com/</a> 提供国内新闻数据接口，其中的APIKey需要自己到网站申请</p>
<p>Python中的异常处理总结：<br><a href="https://segmentfault.com/a/1190000007736783" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007736783</a></p>
<p>在Python中要实现序列化和反序列化除了使用json模块，还可以使用pickle和shelve模块，但是这两个模块时使用特有的序列化协议来序列化数据，序列化后的数据只能被Python识别，关于这两个模块<br>可以自己看网络上的资料</p>
<h5 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h5><pre><code>正则表达式相关知识

在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的复杂规则的字符串的需要，正则表达式就是用于描述规则的工具，换句话说正则表达式是一种工具
它定义了字符串的匹配模式，如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉。如果你在windows操作系统中
使用过文件查找并且在指定文件名时使用过通配符（*和？），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述
你的需求，当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是代价的，就如同学习一门编程语言一样，比如你可以编写正则表达式
，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号&apos;-&apos;，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这就是国内的座机号码，最初计算机是为了做
数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要
今天几乎所有编程语言都提供了对正则表达式操作的支持。Python通过标准库中的re模块来支持正则表达式操作

我们从某个地方可能是一个文本，也可能是网络是一则新闻，获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位数字，注意并不是随机的11位数字，因

正则入门：https://deerchao.cn/tutorials/regex/regex.htm

Python对正则表达式的支持
Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数

函数 | 说明
compile(pattern, flags=0) | 编译正则表达式返回正则表达式对象
match(pattern, string, flags=0) | 用正则表达式匹配字符串 成功返回匹配对象 否则返回None
search(pattern, string, flags = 0) | 搜索字符串中第一次出现正则表达式的模式，成功返回匹配对象 否则返回None
split(pattern, string, maxsplit = 0, flags= 0) | 用正则表达式指定的模式分隔符拆分字符串 返回列表
sub(pattern, repl, string, count=0, flags=0) | 用指定的字符串替换原字符串中与正则表达式匹配的模式，可以用count指定替换的次数
fullmatch(pattern, string, flags=0) | match函数的完全匹配从字符串开头到结尾版本
findall(pattern, string, flags=0) | 查找字符串所有与正则表达式匹配的模式 返回字符串的列表
finditer(pattern, string, flags=0) | 查找字符串所有与正则表达式匹配的模式 返回一个迭代器
purge() | 清除隐式编译的正则表达式的缓存
re.I /re.IGNORECASE | 忽略大小写匹配标记
re.M /re.MULTILINE | 多行匹配标记

说明：上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么通过compile
函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</code></pre><p>提示：上面在书写正则表达式时使用了原始字符串的写法，在字符串前面加上r，所谓原始字符串就是字符串中的每个字符就是它原始意义，说的更直接一点就是字符串中没有所谓的转义字符。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\，例如表示数字的\d要书写成\d，这样不仅写起来方便，阅读的时候也会很吃力</p>
<p>说明：re模块的正则表达式相关函数红都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写，是否进行多行匹配，是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M</p>
<p>如果要从事爬虫类应用的开发，那么正则表达式是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，在实际开发爬虫应用的时候，有很多人会选择BeautifulSoup和Lxml来进行匹配和信息的提取，前者简单方便但是性能差，后者既好用性能也好，但是安装稍显麻烦</p>
<h5 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h5><p>今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持多任务的操作系统，这使得我们可以同时运行多个程序，也可以将程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验，因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的并发编程，应该是程序员必备技能之一。</p>
<p>概念<br>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配空间，每个进程都有自己的地址空间，数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为他们合理的分配资源，进程可以通过fork或spaw的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制IPC Interprocess Communication来实现数据共享，具体的方式包括管道，信号。套接字、共享内存区等</p>
<p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，他们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易，当然在单核CPU系统下，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具如macOS中的活动监视器，Windows中的任务管理器里看。</p>
<p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的cpu执行时间，导致其他程序无法获得足够的CPU执行时间，另一方面站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对初学者更加的困难</p>
<p>Python既支持多进程又支持多线程，因此使用Pyhton实现并发编程主要有三种方式：多线程、多进程、多进程+多线程</p>
<p>Python中的多进程<br>Unix和Linux操作系统上提供了fork()系统来调用创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID，fork()函数非常特殊它会返回两次，父进程中可以通过<br>fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0,。Python的OS模块体统了fork()函数，由于windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process<br>类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池Pool，用于进程间通信的队列Queue的管道Pipe等</p>
<p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，<br>如何实现两个进程间通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个</p>
<p>当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知<br>要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共性的队列，底层是通过管道和信号量semaphore机制来实现的</p>
<p>可以直接使用Threading模块的Thread类来创建线程，但是我们之前讲过一个重要的概念继承，我们可以从已有的类创建新类，因此也通过成Thread类的方式来创建自定义的线程类<br>然后在创建线程对象并启动线程</p>
<p>因为多个进程可以共享进程内的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可，但是当多个线程共享同一个变量<br>(我们通常称之为资源)的时候，很有可能产生不可控的结果从而导致程序失控甚至崩溃。如果一个资源被多个线程竞争使用，我们通常称之为临界资源<br>对临界资源的访问需要加上保护，否则资源会处于“混乱”的状态，下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的<br>情况下我们很有可能会得到错误的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">因为多个进程可以共享进程内的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可，但是当多个线程共享同一个变量</span><br><span class="line">(我们通常称之为资源)的时候，很有可能产生不可控的结果从而导致程序失控甚至崩溃。如果一个资源被多个线程竞争使用，我们通常称之为临界资源</span><br><span class="line">对临界资源的访问需要加上保护，否则资源会处于“混乱”的状态，下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的</span><br><span class="line">情况下我们很有可能会得到错误的结果</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from time import sleep</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">class Account(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._balance = 0</span><br><span class="line"></span><br><span class="line">    def deposit(self, money):</span><br><span class="line">        # 计算存款后的余额</span><br><span class="line">        new_balance = self._balance + money</span><br><span class="line">        # 模拟受理存款业务需要0.01秒的时间</span><br><span class="line">        sleep(0.01)</span><br><span class="line">        # 修改账户余额</span><br><span class="line">        self._balance = new_balance</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def balance(self):</span><br><span class="line">        return self._balance</span><br><span class="line"></span><br><span class="line">class AddMoneyThread(Thread):</span><br><span class="line">    def __init__(self, account, money):</span><br><span class="line">        super().__init__() </span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    # 创建100个存款的线程向同一个账户中存钱</span><br><span class="line">    for _ in range(100):</span><br><span class="line">        t = AddMoneyThread(account, 1)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    # 等所有存款的线程都执行完毕</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(&apos;账户余额为：￥%d元&apos; % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果远远小于100，之所以出现这种情况是因为我们没有对银行账户这个临界资源加以保护，多个线程同时<br>向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果<br>。在这种情况下，锁就可以排上用场了，我们可以通过锁来保护临界资源，只有获得锁的线程才能访问临界资源，而其他没有得到锁的线程只能被阻塞起来，知道获得锁的线程释放了锁，<br>其他线程才有机会获得锁，进而访问被保护的临界资源，</p>
<p>下面的代码演示了如何使用锁，来保护对银行账户的操作，从而获得正确的结果</p>
<p>多进程还是多线程<br>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢，假设正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先<br>花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5个小时，这种方式称为单任务模型。如果你打算切换到所任务模型，可以先1分钟语文，在切换到数学作业，<br>做1分钟，在切换到英语，以此类推，只要切换速度快，这种方式就和单核CPU执行所任务是一样的。以旁观者来看，你就是正在同时写5科作业</p>
<p>但是切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的 语文书本，钢笔（这叫保存现场），然后打开数学课本，找出圆规直尺，这叫（准备新环境，），这才能开始做数学作业。<br>操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态， 内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等）<br>，才能开始执行，这个切换过程虽然很快，但是也需要耗费时间，如果有几千个任务同时进行，操作系统可能主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响<br>，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会是的系统性能急剧下降，最终导致所有任务都做不好</p>
<p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型，计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等<br>，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。。计算密集型任务由于要消耗CPU资源，这类任务用Python<br>这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前有提到Python中有嵌入C/C++代码的机制</p>
<p>除了计算密集型任务，其他的涉及到网络，存储介质I/O的任务，这类任务的特点是CPU消耗很少，任务的大部分时间都是在等待I/O操作完成，因为I/O的速度远远低于CPU和内存的速度，对于<br>I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率运转，有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用</p>
<h5 id="单线程和异步I-O"><a href="#单线程和异步I-O" class="headerlink" title="单线程和异步I/O"></a>单线程和异步I/O</h5><p>现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O.如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程来执行多任务，这种全新的模型称为事件驱动模型。Ngnix就是至此异步I/O<br>d的web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程，数量与CPU核心数相同，充分利用多核CPU，用Node.js开发的服务器端程序也使用了这种工作模式，<br>可获得极高的性能</p>
<p>应用案例，见Python的应用案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import tkinter</span><br><span class="line">import tkinter.messagebox</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    class DownloadTaskHandler(Thread):</span><br><span class="line"></span><br><span class="line">        def run(self):</span><br><span class="line">            time.sleep(10)</span><br><span class="line">            tkinter.messagebox.showinfo(&apos;提示&apos;, &apos;下载完成&apos;)</span><br><span class="line">            # 启用下载按钮</span><br><span class="line">            button1.config(state=tkinter.NORMAL)</span><br><span class="line"></span><br><span class="line">    def download():</span><br><span class="line">        # 禁用下载按钮</span><br><span class="line">        button1.config(state=tkinter.DISABLED)</span><br><span class="line">        # 通过daemon参数将线程设置为守护进程(主程序退出就不再保留执行)</span><br><span class="line">        # 在线程中处理耗时间的下载任务</span><br><span class="line">        DownloadTaskHandler(daemon=True).start()</span><br><span class="line"></span><br><span class="line">    def show_about():</span><br><span class="line">        tkinter.messagebox.showinfo(&apos;关于&apos;, &apos;作者：闸门&apos;)</span><br><span class="line">    </span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.title(&apos;单线程&apos;)</span><br><span class="line">    top.geometry(&apos;200x150&apos;)</span><br><span class="line">    top.wm_attributes(&apos;-topmost&apos;, 1)</span><br><span class="line"></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    button1 = tkinter.Button(panel, text=&apos;下载&apos;, command=download)</span><br><span class="line">    button1.pack(side=&apos;left&apos;)</span><br><span class="line">    button2= tkinter.Button(panel, text=&apos;关于&apos;, command=show_about)</span><br><span class="line">    button2.pack(side=&apos;right&apos;)</span><br><span class="line">    panel.pack(side=&apos;bottom&apos;)</span><br><span class="line"></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">使用多进程对复杂任务进行分而治之</span><br><span class="line">我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from time import time</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    total = 0</span><br><span class="line">    number_list = [x for x in range(1, 100000001)]</span><br><span class="line">    start = time()</span><br><span class="line">    for number in number_list:</span><br><span class="line">        total += number</span><br><span class="line">    print(total)</span><br><span class="line">    end = time()</span><br><span class="line">    print(&apos;Execution time:%.3fs&apos; % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/order/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/order/" itemprop="url">order</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T17:53:19+08:00">
                2019-08-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-09-06T17:33:38+08:00">
                2019-09-06
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/15/order/" class="leancloud_visitors" data-flag-title="order">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>严：41-28:51<br>排序</p>
<h3 id="排序基本概念"><a href="#排序基本概念" class="headerlink" title="排序基本概念"></a>排序基本概念</h3><pre><code>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录系列调整为“有序”的记录序列
例如：52,49,80,36,14,58,61,23,97,75
调整为：14,23,36,49,52,58,61,75,80,97

一般情况下:
假设含n个记录的序列为{R1,R2，……Rn}
其相应的关键字序列为{K1，K2，……Kn}

这些关键字相互之间可以进行比较，即在他们之间存在这样一个关系
    Kp1 &lt; Kp2 …… &lt; Kpn</code></pre><h4 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h4><pre><code>若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序
反之，若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序问题</code></pre><h4 id="内部排序的方法"><a href="#内部排序的方法" class="headerlink" title="内部排序的方法"></a>内部排序的方法</h4><pre><code>内部排序的过程是一个逐步扩大记录的有序序列长度的过程
逐步扩大记录有序序列长度的方法大致有以下几类：
插入类：将无序子序列中的一个或几个记录插入到有序序列中，从而增加记录的有序子序列的长度
交换类： 通过交换无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度
选择类: 从记录的无序子序列中选择关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度
归并类：通过归并两个或两个以上的记录有序子序列，逐步增加记录有序序列的方法
其他方法</code></pre><h3 id="插入排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#插入排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="插入排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>插入排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><pre><code>一趟直接插入排序的基本思想：
有序序列R[1……i-1] | 无序序列R[i……n]
                R[i]
将无序序列中的R[i]插入到有序序列中变成：
有序序列R[1……i] | 无序序列R[i+1……n] </code></pre><p>实现“一趟插入排序”可分为三步进行：【想不通为什么这么简单的概念为什么要用这么复杂的方法来表示，通俗一点，数据结构不是会更容易学一点么，哎，总是一套一套的让人烦啊，要不怎么都不喜欢学习呢。】<br>1、在R[1……i-1]中查找R[i]的插入位置；R[1……j]&lt;=R[i]&lt;=R[j+1……i-1]<br>2、将R[j+2……i-1]中的所有记录均后移一个位置<br>3、将R[i]复制到R[j+1]的位置上</p>
<h4 id="一、直接插入排序"><a href="#一、直接插入排序" class="headerlink" title="一、直接插入排序"></a>一、直接插入排序</h4><pre><code>利用顺序查找实现在R[1……i-1]中查找R[i]的插入位置
算法的实现要点：
1、从R[i-1]起向前进行顺序查找
监视哨设置在R[0];
R[0] = R[i]; // 设置哨兵
for(j = i-1; R[0].key&lt;R[j].key; --j); // 从后往前找
循环结束表明R[i]的插入位置为j+1
2、对于在查找构成中找到的那些关键字不小于R[j].key的记录，并在查找的同时实现记录向后移动
for(j=i-1; R[0].key&lt;R[j].key; --j);
R[j+1] = R[j]
3、i = 2,3，……n实现整个序列的排序
for(i=2; i&lt;=n; ++i)
    if(R[i].key &lt; R[i-1].key){
        将R[i]插入到R[1……i-1]中
    }


void InsertionSort(Elem R[], int n){
    // 对记录序列R[1……n]作直接插入排序
    for(i=2; i&lt;=n; ++i){
        if(R[i].key&lt;R[i-1].key){
            R[0] = R[i]; // 复制为监视哨
            for(j=i-1; R[0].key&lt;R[j].key; --j)
                R[j+1] = R[j]; // 记录后移
            R[j+1] = R[0]; // 插入到正确位置
        }
    }
}

直接插入排序的时间分析：
实现排序的基本操作有两个：
1、比较序列中两个关键字的大小
2、移动记录
对于直接插入排序：
最好的情况(关键字在记录序列中顺序有序)：从小到大
    比较的次数：
    ∑(n, i=2) 1 = n -1
    移动的次数：
    0
最坏的情况(关键字在记录序列中逆序有序)：从大到小
    比较的次数：
    ∑(n, i=2)=(n+2)(n-1)/2</code></pre><h3 id="希尔排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#希尔排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="希尔排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>希尔排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><h3 id="选择排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#选择排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="选择排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>选择排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><h3 id="快速排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#快速排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="快速排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>快速排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><h3 id="合并排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#合并排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="合并排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>合并排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><h3 id="基数排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#基数排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="基数排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>基数排序，算法基本思想，算法代码，基本的时间复杂度分析</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/search/" itemprop="url">search</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T17:53:05+08:00">
                2019-08-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-10-08T18:02:45+08:00">
                2019-10-08
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/15/search/" class="leancloud_visitors" data-flag-title="search">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>查找 Searching P34</p>
<p>怎么视频里说的是查找表：<br>查找表：是由同一类型的数据元素（或记录）构成的集合<br>对查找表经常进行的操作：</p>
<ul>
<li>查询某个“特定的”数据元素是否在查找表中</li>
<li>检索某个“特定的”数据元素的各种属性</li>
<li>在查找表中插入一个数据元素</li>
<li>从查找表中删去某个数据元素</li>
</ul>
<p>静态查找表：仅作查询和检索操作的查找表<br>动态查找表：在查询之后，还需要将查询结果为不在查找表中的数据元素插入查找表，或者从查找表中删除其查询结果为在查找表中的数据元素</p>
<h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><blockquote>
<p>查找：根据某个给定关键字K，从集合R中找出关键字与K相同的记录<br>  <strong>静态查找</strong>： 集合中记录是固定的<br>    没有插入删除操作，只有查找<br>  <strong>动态查找</strong>： 集合中记录是动态变化的<br>    除查找，还可能发生插入和删除</p>
</blockquote>
<p>9.1 静态查找表</p>
<p>ADT StaticSearchTable {<br>    数据对象D：D是具有相同特性的数据元素的集合，每个数据元素含有类型相同的关键字，可唯一标识数据元素<br>    数据关系R：数据元素同属一个集合<br>    基本操作P：<br>        Create(&amp;ST, n);<br>        Destory(&amp;ST);<br>        Search(ST, key);<br>            初始条件：静态查找表ST存在，key为和查找表中的元素的关键字类型相同的给定值<br>            操作结果：若ST中存在其关键字等于key的数据元素，则函数值为该元素的值或在表中的位置，否则为空<br>        Traverse(ST, Visit());<br>            初始条件：静态查找表ST存在，Visit是对元素操作的应用函数<br>            操作结果：按某种次序对ST的每个元素调用函数Visit()一次且仅一次，一旦Visit()失败，则操作失败<br>}</p>
<p>假设静态查找表的顺序存储结构为<br>typedef struct {<br>    ElemType *elem;<br>    // 数据元素存储空间基础，建表时<br>    // 按实际长度分配，0号单元留空<br>    int length; // 表的长度<br>} SSTable</p>
<p>一、顺序查找表<br>    以顺序表或线性表表示 静态查找表<br>    int Search_Seq(SSTable ST, KeyType key){<br>        // 在顺序表ST中顺序查找其关键字等于key的数据元素，若找到，则函数值为该元素在表中的位置，否则为0<br>        ST.elem[0].key = key; // 哨兵<br>        for(i=ST.length; ST.elem[i].key!= key; –i); // 从后往前找 找不到时， i为0<br>        return i;<br>    } // Search_Seq<br>    查找成功i&gt;0, 查找不成功i=0<br>二、有序查找表 二分查找<br>    上述顺序查找表的查找算法简单，但平均查找长度较大，特别不适用于表长较大的查找表。<br>三、静态查找表<br>四、索引顺序表</p>
<p>9.2 动态查找树表 P36</p>
<p>9.3 哈希表</p>
<h3 id="对线性关系结构的查找"><a href="#对线性关系结构的查找" class="headerlink" title="对线性关系结构的查找"></a>对线性关系结构的查找</h3><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>静态查找：<br>int SequentialSearch(List Tbl, ElementType K){<br>    // 在Element[1]~Element[n]中查找关键字为K的数据元素<br>    int i;<br>    Tbl -&gt; Element[0] = K; // 建立哨兵<br>    for(i = Tbl-&gt;Length; Tbl-&gt;Elemnt[i]!=K; i–);<br>    return i; // 查找成功返回所在单元下标，不成功返回0<br>}</p>
<p>typedef struct LNode *List;<br>struct LNode{<br>    Elementtype Element[MAXSIZE];<br>    int Length;<br>}</p>
<p>顺序查找的一种实现(无”无哨兵”)</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>有序查找表</p>
<p>int Search_Bin(SSTale ST, KeyType key){<br>    low = 1; high = ST.length; // 置区间初值<br>    while(low &lt;= high){<br>        mid = (low + high) /2;<br>        if(EQ(key, ST.elem[mid].key))<br>            return mid; // 找到待查元素<br>        else if(LT(key, ST.elem[mid].key))<br>            high = mid - 1; // 继续在前半区进行查找<br>        else low = mid + 1; // 继续在后半区进行查找<br>    }<br>    return 0; // 顺序表中不存在待查元素<br>} // Search_Bin</p>
<p>分析折半查找的平均查找长度<br>先看一个具体的情况 ，假设n = 11</p>
<p>| i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |<br>|Ci |</p>
<p>一般情况下，表长为n的折半查找的判定树的深度和含有n个结点的完全二叉树的深度相同</p>
<p>不等概率查找的情况下，折半查找不是最好的查找方法</p>
<h3 id="Hash查找法"><a href="#Hash查找法" class="headerlink" title="Hash查找法"></a>Hash查找法</h3><h3 id="常见的Hash函数（直接定址发，随机数法）"><a href="#常见的Hash函数（直接定址发，随机数法）" class="headerlink" title="常见的Hash函数（直接定址发，随机数法）"></a>常见的Hash函数（直接定址发，随机数法）</h3><h3 id="hash冲突的概念"><a href="#hash冲突的概念" class="headerlink" title="hash冲突的概念"></a>hash冲突的概念</h3><h3 id="解决冲突的方法（开散列方法、拉链法、闭散列方法、开址定址法）"><a href="#解决冲突的方法（开散列方法、拉链法、闭散列方法、开址定址法）" class="headerlink" title="解决冲突的方法（开散列方法、拉链法、闭散列方法、开址定址法）"></a>解决冲突的方法（开散列方法、拉链法、闭散列方法、开址定址法）</h3><h3 id="二次聚集现象"><a href="#二次聚集现象" class="headerlink" title="二次聚集现象"></a>二次聚集现象</h3><h3 id="BST树定义，性质，ADT，及其实现"><a href="#BST树定义，性质，ADT，及其实现" class="headerlink" title="BST树定义，性质，ADT，及其实现"></a>BST树定义，性质，ADT，及其实现</h3><h3 id="BST树查找，插入，删除算法"><a href="#BST树查找，插入，删除算法" class="headerlink" title="BST树查找，插入，删除算法"></a>BST树查找，插入，删除算法</h3><h3 id="平衡树（AVL）的定义，性质，ADT及其实现"><a href="#平衡树（AVL）的定义，性质，ADT及其实现" class="headerlink" title="平衡树（AVL）的定义，性质，ADT及其实现"></a>平衡树（AVL）的定义，性质，ADT及其实现</h3><h3 id="平衡树查找、插入算法"><a href="#平衡树查找、插入算法" class="headerlink" title="平衡树查找、插入算法"></a>平衡树查找、插入算法</h3><h3 id="平衡因子的概念"><a href="#平衡因子的概念" class="headerlink" title="平衡因子的概念"></a>平衡因子的概念</h3><h3 id="优先队列与堆"><a href="#优先队列与堆" class="headerlink" title="优先队列与堆"></a>优先队列与堆</h3><h3 id="堆的定义，堆的生成"><a href="#堆的定义，堆的生成" class="headerlink" title="堆的定义，堆的生成"></a>堆的定义，堆的生成</h3><h3 id="调整算法，范围查询"><a href="#调整算法，范围查询" class="headerlink" title="调整算法，范围查询"></a>调整算法，范围查询</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/Graph/" itemprop="url">Graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T17:51:53+08:00">
                2019-08-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-10-08T18:02:48+08:00">
                2019-10-08
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/15/Graph/" class="leancloud_visitors" data-flag-title="Graph">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>图：社交网络 关系(边) 六度空间理论(SIX DEGREES OF SEPARATION)<br><img src="/images/map_01.png" alt="图的引例"></p>
<p>表示多对多的关系：把线性表 树的关系都包含在内了</p>
<blockquote>
<p>P24 </p>
</blockquote>
<h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><pre><code>图的抽象数据类型定义：数据对象 数据关系 操作集
ADT Graph {
    数据对象V：V是具有相同特性的数据元素的集合，称为顶点集
    数据关系R：
        R={VR}
        VR={&lt;v, w&gt;| v,w∈V且P(v, w),&lt;v, w&gt;表示从v到w的弧，谓词P(v,w)定义了弧&lt;v, w&gt;的意义或信息}
}</code></pre><p>表示“多对多的关系”<br>包含：<br>    - 一组顶点：通常是V(Vertex)表示顶点集合<br>    - 一组边: 通常用E(Edge)表示边的集合，表示顶点与顶点的某种关系<br>        边是顶点对：(v,w) ∈ E，边是无向边，其中v，w ∈ V              v——w<br>        有向边：&lt;v,w&gt;表示从v指向w的边（单行边）                      v——&gt;w<br>        *不考虑重边和自回路</p>
<p>抽象数据类型定义：三要素， </p>
<ul>
<li><p>类型名称：图(Graph)</p>
</li>
<li><p>数据对象集：G(V,E)由一个非空[在说到一个图的时候可以一条边没有，但是不能连一个顶点也没有，必须至少有一个顶点]的有限顶点集合V和一个有限边集合E组成。</p>
</li>
<li><p>操作集：对于任意图 G ∈ Graph, 以及 v ∈ V, e ∈ E<br>  Graph Create(); 建立并返回空图;<br>  Graph InsertVertex(Graph G, Vertex v): 将v插入G;<br>  Graph InsertEdge(Graph G, Edge e): 将e插入G;<br>  void DFS(Graph G, Vertex v): 从顶点v出发深度优先遍历图G;<br>  void BFS(Graph G, Vertex v): 从顶点v出发宽度优先遍历图G;<br>  void ShortestPath(Graph G, Vertex v, int Dist[]): 计算图G中顶点v到任意其他顶点的最短距离<br>  void MST(Graph G): 计算图G的最小生产树<br>  ……</p>
<h4 id="常见术语-P24"><a href="#常见术语-P24" class="headerlink" title="常见术语 P24"></a>常见术语 P24</h4><blockquote>
<p>名词和术语</p>
</blockquote>
</li>
<li><p>弧头、弧尾、弧、有向图<br>  若&lt;v, w&gt;∈ VR，<br>  则&lt;v, w&gt;表示从顶点v到顶点w的一条<strong>弧</strong><br>  称顶点v为<strong>弧尾</strong>，称顶点w为<strong>弧头</strong><br>  由顶点集合弧集构成的图称作<strong>有向图</strong></p>
</li>
<li><p>边、无向图<br>  若&lt;v, w&gt;∈ VR，必有&lt;w, v&gt;∈ VR，<br>  则称(v, w)为顶点v和顶点w之间存在一条<strong>边</strong><br>  由顶点集合边集构成的图称作<strong>无向图</strong></p>
</li>
<li><p>网、子图<br>  弧或边带权的图分别称作<strong>有向网</strong>或<strong>无向网</strong><br>  设图G={V, {VR}}和图G’={V’, {VR’}}, 且V’∈V, VR’∈ VR, 则称G’为G的<strong>子图</strong></p>
</li>
<li><p>完全图、稀疏图、稠密图<br>  假设图中有n个顶点，e条边，则</p>
<pre><code>含有e = n(n-1) /2条边的无向图称作**完全图**
含有e = n(n-1)条弧的有向图称为**有向完全图**
若边或弧的个数 e &lt; nlogn,则称作**稀疏图**，否则称作**稠密图**</code></pre></li>
<li><p>邻接点、 度、 入度、出度<br>  假若顶点v和顶点w之间存在一条边，则称顶点v和w互为<strong>邻接点</strong>，边(v, w)和顶点v和w相<strong>关联</strong><br>  和顶点v关联的边的数目定义为边的<strong>度</strong></p>
<p>  对有向图来说：<br>  以顶点v为弧尾的弧的数目定义为顶点的<strong>出度</strong><br>  以顶点V为弧头的弧的数目定义为顶点的<strong>入度</strong></p>
<pre><code>**度(TD)= 出度(OD) + 入度(ID)**</code></pre></li>
<li><p>路径、路径长度、简单路径、简单回路<br>  设图G=(V, {VR})中的一个顶点序列{u=vi,0,vi,1,……,vi,m=w}中,(vi,j-1, vi,j)∈ VR  1《j《m,<br>  则称从顶点u到顶点w之间存在一条<strong>路径</strong>，路径上边的数目称作<strong>路径长度</strong><br>  若序列中的顶点不重复出现，则称作<strong>简单路径</strong><br>  若u=w，则称这条路径为<strong>回路</strong>或<strong>简单回路</strong></p>
</li>
<li><p>连通图、连通分量，强连通图、强连通分量<br>  若图G中任意两个顶点之间都有路径相通，则此图为<strong>连通图</strong><br>  若无向图为非连通图，则图中各个极大连通子图称作此图的<strong>连通分量</strong></p>
<p>  对于有向图，<br>  若任意两个顶点之间都存在一条有向路径，则称此有向图为<strong>强连通图</strong><br>  否则，其各个强连通子图称作它的<strong>强连通分量</strong></p>
</li>
<li><p>生成树和生成森林<br>  假设一个连通图有n顶点和e条边，其中n-1条边和n个顶点构成一个极小连通子图，称该极小连通子图为此连通图的<strong>生成树</strong></p>
<p>  对于非连通图，<br>  则称各个连通分量的生成树的集合为此非连通图的<strong>生成森林</strong></p>
</li>
</ul>
<blockquote>
<p>图的基本操作P25：</p>
<ul>
<li>结构的建立和销毁：CreateGraph(&amp;G, V, VR) Destory(&amp;G)</li>
<li>插入或删除顶点：<br>  InsertVex(&amp;G, v)：在图G中增添新顶点v<br>  Detele(&amp;G, v)：删除G中顶点v及其相关的弧</li>
<li>对顶点的访问操作：<br>  LocateVex(G, u) :若G中存在顶点u，则返回该顶点在图中的位置，否则返回其他信息<br>  GetVex(G, v)：返回v的值<br>  PutVex(&amp;G, v, value)：对v赋值value</li>
<li>插入或删除弧：<br>  InsertArc(&amp;G, v, w)：在G中添加弧&lt;v, w&gt;,若G是无向的，则还增添对称弧&lt;w, v&gt;<br>  DeleteArc(&amp;G, v, w): 在G中删除弧&lt;v, w&gt;,若G是无向的，则还删除对称弧&lt;w, v&gt;</li>
<li>对邻接点的操作：<br>  FirstAdjVex(G, v)：返回v的第一个邻接点。若该顶点在G中没有邻接点，则返回’空’<br>  NextAdjVex(G, v, w)：返回v的相对于w的下一个邻接点，若w是v的最后一个邻接点，则返回空</li>
<li>遍历：<br>  DFSTraverse(G, v, Visit()): 从顶点v起深度优先遍历图G，并对每个顶点调用函数Visit一次且仅一次<br>  BFS(G, v, Visit())：从顶点v起广度优先遍历图G，并对每个顶点调用函数Visit一次且仅一次</li>
</ul>
</blockquote>
<h3 id="图的存储结构：邻接矩阵，邻接表"><a href="#图的存储结构：邻接矩阵，邻接表" class="headerlink" title="图的存储结构：邻接矩阵，邻接表"></a>图的存储结构：邻接矩阵，邻接表</h3><blockquote>
<p>图的存储表示</p>
<ul>
<li>一、图的数组(邻接矩阵)存储表示<br>怎么在程序中表示一个图？<br>typedef struct AreCell {<br>  VRType adj; // VRtype是顶点关系类型，对无权图，用1或0表示相邻否，对带权图，则为权值类型<br>  InfoType *info;// 该弧相关信息的指针<br>} AreCell</li>
</ul>
</blockquote>
<p>AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br>typedef struct{<br>    VertexType vex[MAX_VERTEX_NUM];<br>    AdjMatrix arcs;<br>    int vexnum, arcnum;<br>    GraphKind kind;<br>} MGraph</p>
<ul>
<li>二、图的邻接表存储表示<br>typedef struct AreNode{<br>  int adjvex; // 该弧所指向的顶点的位置<br>  struct AreNode *nextarc;// 指向下一条弧的指针<br>  InfoType *info;// 该弧相关信息的指针<br>} AreNode;</li>
</ul>
<p>typedef struct VNode {<br>    VertexType data; // 顶点信息<br>    AreNode *firstarc; // 指向第一条依附该顶点的弧<br>} VNode, AdjList[MAX_VERTEX_NUM];</p>
<p>typedef struct {<br>    AdjList verrices;<br>    Int vexnum, arcnum;<br>    int kind; // 图的种类标志<br>}</p>
<ul>
<li>三、有向图的十字链表存储表示 【大纲不考】<br>// 定义弧<br>typedef struct Arebox {<br>  int tailvex, headvex;//该弧的尾和头顶点的位置<br>  struct ArcBox <em>hlink,</em>tlink; // 分别指向下一个弧头相同和弧尾相同弧的指针域<br>  InfoType *info; // 该弧相关信息的指针<br>} AreBox</li>
</ul>
<p>typedef struct VexNode {<br>    VertexType data;<br>    ArcBox *firstin, *firstout;<br>} VexNode</p>
<p>typedef struct {<br>    VexNode xlist[MAX_VERTEX_NUM];<br>    int vexnum, arcnum; // 有向图的当前顶点数和弧数<br>} Graph</p>
<p>-四、无向图的邻接多重表存储表示<br>typedef struct Ebox{<br>    Visit mark; //访问标记<br>    int ivex, jvex; //该边依附对的两个顶点的位置<br>    struct Ebox *ilink, *jlink; // 该边信息指针<br>}EBox</p>
<p>typedef struct VexBox {<br>    VertexType data;<br>    EBox *firstedge; // 指向第一条依附该顶点的边<br>} VexBox</p>
<p>typedef struct{<br>    VexBox adjmulist[MAX_VERTEX_NUM];<br>    int vernum, edgenum;<br>}Graph</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵G[N][N]-N个顶点从0到N-1编号（二维数组表示图）：<br>  G[i][j] = 1  若<vi vj>是G中边<br>            0  否则<br>  问题，对于无向图的存储，怎样可以省一半的空间？<br>邻接矩阵的好处<br>  直观、简单、好理解<br>  方便检查任意一对顶点间是否存在边<br>  方便找任一顶点的所有邻接点（有边直接相连的顶点）<br>  方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数称为入度）<br>  如何计算度？</vi></p>
<ul>
<li><p>无向图：对应行（或列）非0元素的个数</p>
</li>
<li><p>有向图：对应行非0元素的个数是“出度”(发出)，对应列非0元素的个数是“入度”（指向）</p>
<p>邻接矩阵有什么不好？<br>浪费空间-存稀疏图（点很多而边很少）有大量无效元素<br>对稠密图（特别树是完全图，顶点之间都有一条边，边数是极大的）还是很合算的。<br>浪费时间-统计稀疏图中一共有多少条边</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素<br>邻接表的顺序是不唯一的，元素以什么顺序出现也是不唯一的。<br><img src="/images/linjiebiao.png" alt="邻接表"><br>一条边会存两遍，对于网路，结构中要增加权重的域<br>邻接表一定要够稀疏才划算。</p>
</li>
</ul>
<p>邻接表<br>    方便找任一顶点的所有邻接点<br>    节约稀疏图的空间<br>        需要N个头指针+2E个结点（每个结点至少2个域）<br>    方便计算任一定点的度？<br>        对无向图：是的<br>        对有向图：只能计算“出度”【正邻接表存的是邻接矩阵的每一行存成一个链表】：需要构造“逆邻接表”【存的是邻接矩阵的每一列存成一个链表】（存指向自己的边）来方便计算入度<br>    方便检查任意一对顶点间是否存在边？<br>        No</p>
<p>表示图的方法并不只有邻接表和邻接矩阵还有别的方法，至于用什么方法来表示图，取决于你要解决的问题。</p>
<h3 id="图的遍历-P25-44-11"><a href="#图的遍历-P25-44-11" class="headerlink" title="图的遍历 P25:44:11"></a>图的遍历 P25:44:11</h3><blockquote>
<p>从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。</p>
</blockquote>
<p>每个顶点访问一遍，不能有重复的访问。为什么要对图做遍历呢？</p>
<h4 id="深度优先遍历-P26-Depth-Frist-Search，DFS"><a href="#深度优先遍历-P26-Depth-Frist-Search，DFS" class="headerlink" title="深度优先遍历 P26 Depth Frist Search，DFS"></a>深度优先遍历 P26 Depth Frist Search，DFS</h4><blockquote>
<p>  从图中某个顶点V0出发，访问此顶点，然后依次从V0的各个<strong>未被访问</strong>的邻接点出发深度优先搜索遍历图，直至图中所有和V0有路径相通的顶点都被访问到，若此时图中尚有顶点未被访问，则<br>    另选图中一个未曾被访问的顶点做起始点，重复上述过程，直至图中所有顶点都被访问到为止</p>
</blockquote>
<pre><code>非连通图：
void DFSTraverse(Graph G, Status(*Visit(int v))){
    // 对图G作深度优先遍历
    VisitFunc = Visit;
    for(v=0; v&lt;G.vexnum; ++v)
        visited[v] = FALSE;//访问标志数组初始化
    for(v=0; v&lt;G.vexnum; ++v)
    if(!visited[v]) DFS(G,v); // 对尚未访问的顶点调用DFS
}

void DFS(Graph G, int v) {
    visited[v] = TRUE;
    VisitFunc(v);
    for(w=FirstAdjVex(G, x); W!=0; w=NextAdjVex(G, v, w))
        if(!visited[w]) DFS(G, w);// 对v的尚未访问的邻接顶点w递归调用DFS
}</code></pre><p><img src="/images/shenduyouxian.png" alt="深度优先遍历"><br>若又N个顶点，E条边，时间复杂度是<br>用邻接表存储图。有O（N+E）<br>用邻接矩阵存储图，有O（N^2）</p>
<h4 id="广度优先遍历-P26：26-00-Breadth-First-Search-BFS-一圈一圈的搜"><a href="#广度优先遍历-P26：26-00-Breadth-First-Search-BFS-一圈一圈的搜" class="headerlink" title="广度优先遍历 P26：26:00 Breadth First Search,BFS 一圈一圈的搜"></a>广度优先遍历 P26：26:00 Breadth First Search,BFS 一圈一圈的搜</h4><blockquote>
<p>从图中的某个顶点V0出发，并在访问此顶点之后一次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有的V0有路径<br>    相通的顶点都被访问到，若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重读上述过程，直至图中所有的顶点都被访问到为止</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void BFSTraverse(Graph G, Status(*Visit)(int v))&#123;</span><br><span class="line">    for(v=0; v&lt;G, vexnum; ++v)</span><br><span class="line">        visited[v] = FALSE;</span><br><span class="line">        InitQueue(Q); // 置空的辅助队列Q</span><br><span class="line">    for(v=0; v&lt;G.vexnum; v++)</span><br><span class="line">        if(!visited[v])&#123; // 尚未访问</span><br><span class="line">            Enqueue(Q, v);</span><br><span class="line">            visited[u] = TRUE;</span><br><span class="line">            Visit[u]</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        while(!QueueEmpty(Q))&#123;</span><br><span class="line">            DeQueue(Q, u);// 队头元素出队并置为u 访问u</span><br><span class="line">            for(w=FirstAdjVex(G, u); w!=0; w=NextAdjVex(G, u, w))</span><br><span class="line">                if(!visited[w]) &#123;EnQueue(Q, w)&#125;;</span><br><span class="line">                visited[w] = TRUE;</span><br><span class="line">                Visited(w);// u的尚未访问的邻接顶点w入队列Q</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动画图示一定要看，非常清楚P26:47:00</p>
<h4 id="遍历应用举例-P27-大纲没有补考可略过"><a href="#遍历应用举例-P27-大纲没有补考可略过" class="headerlink" title="遍历应用举例 P27-大纲没有补考可略过"></a>遍历应用举例 P27-大纲没有补考可略过</h4><ul>
<li><p>1.求一条从顶点i到顶点s的简单路径[深度优先搜索遍历]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void DFSearch(int v, int s, char *PATH)&#123;</span><br><span class="line">    // 从第v个顶点出发递归深度优先遍历图G</span><br><span class="line">    // 求得一条从v到s的简单路径，并记录在PATH中</span><br><span class="line">    visited[v] = TRUE; // 访问第v个顶点</span><br><span class="line">    Append(PATH, getVertex(v));</span><br><span class="line">    for(w=FirstAdjVex(v); w!=0 &amp;&amp; !found; w=NextAdjVex(v))</span><br><span class="line">        if(w=s)&#123;</span><br><span class="line">            found=TRUE; Append(PATH, w)</span><br><span class="line">        &#125;else if(!visited[w])&#123;</span><br><span class="line">            DFSearch(w, LP);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    if(!found) Delete(PATH)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求两个顶点之间的一条路径长度最短的路径</p>
<blockquote>
<p>基于广度优先搜索遍历，并修改链队列的结点结构及其入队列和出队列的算法</p>
</blockquote>
</li>
<li><p>将链队列的结点改为“双链”结点，即结点中包含next和priou两个指针</p>
</li>
<li><p>修改入队列的操作，插入新的对尾结点时，另起priou域的指针，指向刚出队列的结点，即当前的对头指针所指结点</p>
</li>
<li><p>修改出队列的操作，出队列时，仅移动对头指针，而不将对头结点从链表中删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef DuLinkList QueuePtr;</span><br><span class="line">void InitQueue(LinkQueue&amp; Q)&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">    Q.front -&gt; next = Q.rear-&gt;next = NULL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EnQueue(LinkQueue&amp; Q, QelemType e)&#123;</span><br><span class="line">    p = (QueuePtr) malloc (sizeof(QNode));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next=NUll;</span><br><span class="line">    p-&gt;priou = Q.front</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void DeQueue(LinkQueue&amp; Q, QelemType&amp; e)&#123;</span><br><span class="line">    Q.front = Q.front-&gt;next;</span><br><span class="line">    e = Q.front-&gt;data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="最小生成树基本概念-P27：24-16"><a href="#最小生成树基本概念-P27：24-16" class="headerlink" title="最小生成树基本概念 P27：24:16"></a>最小生成树基本概念 P27：24:16</h3><blockquote>
<p>问题： 假设要在n个城市之间建立通讯联络网，则连通n个城市只需要修建n-1条线路，如何在最节省经费的前提下建立这个通讯网？<br>         该问题等价于：<br>         构造网的一颗最小生成树，即：在e条带权的边中选取n-1条（不构成回路），即“权值之和”为最小</p>
</blockquote>
<p>解决最小生成树问题：<br>    算法一：普利姆算法</p>
<h3 id="Prim算法-P27：30-00-41-49"><a href="#Prim算法-P27：30-00-41-49" class="headerlink" title="Prim算法 P27：30:00-41:49"></a>Prim算法 P27：30:00-41:49</h3><blockquote>
<p>可取图中任意一个顶点v作为生成树的根，之后若要往生成树上添加顶点w，则在顶点v和顶点w之间必定存在一条边，并且该边的权值在连通顶点v和w之间的边中取值最小<br>    一般情况下，假设n个顶点分成两个集合：U(包含已落成在生产树上的结点)和V-U(尚未落在生成树上的顶点)，则在所有连通图U中顶点和V-U中顶点的边中选取权值最小的边<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//记录从顶点集U到V-U的代价最小的边的辅助数组;</span><br><span class="line">struct &#123;</span><br><span class="line">    VertexType adjvex;</span><br><span class="line">    VRType lowcost:</span><br><span class="line">&#125; closege[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line">k=LocateVex(G, u);</span><br><span class="line">for(j=0; j&lt;G.vexnum; ++j) // 辅助数组初始化</span><br><span class="line">    if(j!=k) closedge[j] = ()</span><br><span class="line"></span><br><span class="line">for(j=0; j&lt;G.vexnum; ++j)&#123;</span><br><span class="line">    // 在其余顶点中选择</span><br><span class="line">    k = minimum(closedge); //求出T的下一个结点(k)</span><br><span class="line">    printf(closedge[k].adjvex,G.vexs[k]);</span><br><span class="line">    closedge[k].lowcost = 0; // 第k顶点并入U集</span><br><span class="line">    for(j=0; j&lt;G.vexnum; ++j)</span><br><span class="line">        if(G.arcs[k][j].adj &lt; closege[j].lowcost)</span><br><span class="line">            closedge[j] = (G.vexs[k],G.arcs[k][j].adj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><blockquote>
<p>克鲁斯卡尔算法:<br>    为使生成树上边的权值之和最小，显然，其中每一条边的权值应该尽可能的小，克鲁斯卡尔算法的做法就是：先构造一个只含n个顶点的子图SG，然后从权值最小的边开始，若它的添加不使SG中产生回路，则在SG上加上这条边，如此重复，直至加上n-1条边为止</p>
</blockquote>
<p>算法：</p>
<ul>
<li>构造非连通图ST = (V, {}) –[只含顶点不含边];<br>  k = i = 0;<br>  while (k &lt; n-1){<pre><code>++i;
// 从边集E中选取第i条权值最小的边(u, v);若(u,v)加入ST后不使ST中产生回路，则输出边(u, v); 且k++;</code></pre>  }</li>
</ul>
<h2 id="由于普利姆算法的时间复杂度为O-n-2-则适用于稠密图，而克鲁斯卡尔算法需对e条边按权值进行排序，其时间复杂度为O-eloge-则适用于稀疏图。"><a href="#由于普利姆算法的时间复杂度为O-n-2-则适用于稠密图，而克鲁斯卡尔算法需对e条边按权值进行排序，其时间复杂度为O-eloge-则适用于稀疏图。" class="headerlink" title="由于普利姆算法的时间复杂度为O(n^2),则适用于稠密图，而克鲁斯卡尔算法需对e条边按权值进行排序，其时间复杂度为O(eloge),则适用于稀疏图。"></a>由于普利姆算法的时间复杂度为O(n^2),则适用于稠密图，而克鲁斯卡尔算法需对e条边按权值进行排序，其时间复杂度为O(eloge),则适用于稀疏图。</h2><blockquote>
<p>P28 以下内容与大纲无关</p>
<ul>
<li>重(双)连通图和关节点<br>问题：若从一个连通图中删去任何一个顶点及其相关联的边，它仍是一个连通图，则该连通图被称为<strong>重(双)连通图</strong>，可参考实际应用背景：网络的搭建<pre><code>若连通图中的某个顶点和其相关联的边被删去之后，该连通图被分割成两个或两个以上的连通分量，则称此顶点为**关节点**</code></pre></li>
</ul>
</blockquote>
<p>没有关节点的连通图为<strong>双连通图</strong></p>
<ul>
<li><p>关节点的特征：<br>  假设从某个顶点V0出发对连通图进行深度优先搜索遍历，则可得到一颗深度优先生成树，树上包含图的所有顶点。<br>  若生成树的根结点，有两个或两个以上的分支，则此顶点（生成树的根）必为关节点<br>  对生成树上的任意一个“顶点”，若其某棵子树的根或子树的其他“顶点”没有和其祖先相通的回边，则该“顶点”必为关节点</p>
</li>
<li><p>如何求关节点？</p>
<ul>
<li><p>1) 看根是不是关结点： 设V0为深度优先遍历的出发点<br>p=G.vertices[0].firstarc;<br>v=p-&gt;adjvex;<br>DFSArticul(G, v); // 从第v顶点出发深度优先搜索<br>if(count &lt; G.vexnum){</p>
<pre><code>// 从根结点的第一个邻接点出发访问的结点个数小于总的结点树则说明
// 生成树的跟有至少两棵子树
printf(0, G.vertices[0].data); // 根是关节点</code></pre><p>}</p>
</li>
<li><p>2) 对生成树上的顶点定义一个函数：这个没看懂<br>low(v) = Min{visited[v], low[w], visited[k]}<br>visited[v]：访问序号<br>low[w]: 子树结点的最小访问次序<br>visited[k]: 回边的最小访问次序</p>
<p>k是与v有回边相通的顶点， k是v的祖先<br>对顶点v，若(在生成树上)存在一个子树根w，且low[w]&gt;=visited[v],在顶点v为关结点</p>
</li>
</ul>
</li>
</ul>
<p>对深度优先搜索遍历算法做如下修改：</p>
<ul>
<li>visited[v]的值改为遍历过程中的顶底的访问次序count值</li>
<li>遍历过程中求得：<br>  low[v] = Min{visited[v], low[w], visited[k]}</li>
<li>从子树遍历返回时：<br>  判别low[w] &gt;=visited[v]: 子树根的最小访问次序 根结点的访问次序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">**min = visited[v0] = ++count;**</span><br><span class="line">// 设定low[v0]的初始值count记顶点访问次序</span><br><span class="line">for(p=G.vertices[0].firstarc; p; p=p-&gt;nextarc)&#123;</span><br><span class="line">    w = p-&gt;adjvex; // w为v0的邻接顶点</span><br><span class="line">    if(visited[w] == 0)&#123; // w未被访问</span><br><span class="line">        DFSArticul(G, w); // 返回前求得low[w]</span><br><span class="line">        if(low[w] &lt; min) min = low[w];</span><br><span class="line">        if(low[w]&gt;=visited[v0])</span><br><span class="line">            printf(v0, G.vertices[v0].data); // 输出关节点</span><br><span class="line">    &#125;</span><br><span class="line">    else // w是回边上的顶点</span><br><span class="line">        **if(visited[w] &lt; min) min = visited[w];**</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**low[v0] = min**</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最短路径问题-P28-33-00"><a href="#最短路径问题-P28-33-00" class="headerlink" title="最短路径问题 P28:33:00"></a>最短路径问题 P28:33:00</h3><ul>
<li>上面有谈到过最短路径问题</li>
<li>从源头到其余各点的最短路径<br>算法的基本思想是：依路径长度递增的次序求得各条路径：<br>假设从源点到其余各点之间的最短路径，则在这些路径中，必然存在一条长度最短者</li>
<li>在这条路径上，必定只含一条权值最小的弧，由此只要在所有从源点出发的弧中查找权值最小者</li>
<li>长度次短的路径可能有两种情况：<pre><code>它可能是从源点直接到该点的路径
也可能是从源点a再到a到该点</code></pre></li>
<li>其余依次类推</li>
</ul>
<p>假设Dist[k]表示当前所求得的从源点打顶点k的最短路径，则一般情况下：<br>    Dist[k] = &lt;源点到顶点k的弧上的权值&gt; 或者 &lt;源点到其他顶点的路径长度&gt; + &lt;其他顶点到顶点k弧上的权值&gt;</p>
<p>求两个顶点之间的最短路径：<br>算法的基本思想是：<br>从vi到vj的所有存在的路径中，选出一条长度最短的路径<br>    若&lt;vi,vj&gt;存在，则存在路径{vi, vj} // 路径中不含其他顶点<br>    若&lt;vi,v1&gt;&lt;v1, vj&gt;存在，则存在路径{vi, v1, vj} // 路径中所含顶点序号不大于1<br>    若{vi，……，v2}，{v2，……，vj} 存在，则存在一条路径{vi,……,v2,……vj} // 路径中所含顶点序号不大于2</p>
<p>依次类推，则vi至vj的最短路径应是上述这些路径中，路径长度最小者。</p>
<h3 id="广度优先遍历算法："><a href="#广度优先遍历算法：" class="headerlink" title="广度优先遍历算法："></a>广度优先遍历算法：</h3><h3 id="Dijkstra算法-P29"><a href="#Dijkstra算法-P29" class="headerlink" title="Dijkstra算法 P29"></a>Dijkstra算法 P29</h3><h3 id="Floyd算法-P29"><a href="#Floyd算法-P29" class="headerlink" title="Floyd算法 P29"></a>Floyd算法 P29</h3><h3 id="拓扑排序-P29-17-25"><a href="#拓扑排序-P29-17-25" class="headerlink" title="拓扑排序 P29 17:25"></a>拓扑排序 P29 17:25</h3><blockquote>
<p>问题：假设以有向图表示一个施工图或程序的数据流图，则图中不允许出现回路<br>如何<strong>检查有向图中是否存在回路</strong>的方法之一，是对有向图进行<strong>拓扑排序</strong></p>
</blockquote>
<h5 id="何谓“拓扑排序”？"><a href="#何谓“拓扑排序”？" class="headerlink" title="何谓“拓扑排序”？"></a>何谓“拓扑排序”？</h5><pre><code>对有向图进行如下操作：
按照有向图给出的次序关系，将图中顶点排成一个线性序列，对于有向图中没有限定次序关系的顶点，则可以人为加上任意的次序关系
由此得到顶点的线性序列称之为**拓扑有序序列**</code></pre><h5 id="如何进行拓扑排序？"><a href="#如何进行拓扑排序？" class="headerlink" title="如何进行拓扑排序？"></a>如何进行拓扑排序？</h5><ul>
<li>一、从有向图中选取一个没有前驱的顶点，并输出之</li>
<li>二、从有向图中删除此顶点以及所有以它为尾的弧</li>
</ul>
<p>重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止<br>没有前驱的顶点 = 入度为零的顶点<br>删除顶点及以它为尾的弧 = 弧头顶点的入度减1</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>取入度为零的顶点v；<br>while(v&lt;&gt;0){<br>    printf(v);<br>    ++m;<br>    w:=FirstAdj(v);<br>    while(w&lt;&gt;0){<br>        inDegree[w]–;<br>        w:=nextAdj(v, w);<br>    }<br>    // 取下一个入度为零的顶点v;<br>}</p>
<p>if m &lt; n printf(‘图中有回路’)<br>为避免每次都要搜索入度为零的顶点，在算法中设置一个栈，以保存入度为零的顶点<br>CountInDegree(G, indegree); // 对各顶点求入度<br>InitStack(S);<br>for(i=0; i&lt;G.vexnum; ++i)<br>    if(!indegree[i] Push(S, i)); // 入度为零的顶点入栈<br>count = 0; // 对输出顶点计数<br>while(!EmptyStack(S)){<br>    Pop(S,v);<br>    ++count;<br>    printf(v);<br>    for(w=FirstAdj(v); w; w=NextAdj(G,v,w))<br>        –indegree(w);<br>        if(!indegree[w])<br>            Push(S, w);<br>            // 新产生的入度为零的顶点入栈<br>}</p>
<p>if(count &lt; G.vexnum)<br>    printf(“图中有回路”)</p>
<p>P29:33:00 拓扑排序的动画演示</p>
<hr>
<h3 id="关键路径【大纲没有可以不考虑但是有时间可以了解下】"><a href="#关键路径【大纲没有可以不考虑但是有时间可以了解下】" class="headerlink" title="关键路径【大纲没有可以不考虑但是有时间可以了解下】"></a>关键路径【大纲没有可以不考虑但是有时间可以了解下】</h3><p>问题：假设以有向网表示一个施工流图，弧上的权值表示完成该项子工程所需时间<br>问：哪些子工程项是关键工程？<br>即：将影响整个工程完成期限的子工程项</p>
<p>整个工程完成的时间为：从有向图的源点到汇点的最长路径<br>“关键活动”指的是：该弧上的权值增加将使有向图中的最长路径的长度增加</p>
<p>如何求关键活动？<br>“事件（顶点）”的最早发生时间ve(j)<br>ve(j)= 从源点到顶点j的最长路径长度</p>
<p>“事件（顶点）”的最迟发生时间vl(k)<br>vl(k) = 从顶点k到汇点的最短路径长度</p>
<p>假设第i条弧为 &lt;j, k&gt;则第i项活动：<br>活动（弧）的最早开始时间ee(i)<br>ee(i) = ve(j)<br>活动(弧)的最迟开始时间el(i)<br>el(i) = vl(k) - dut(&lt;j, k&gt;)</p>
<p>事件发生时间的计算公式:<br>    ve(源点) = 0;<br>    ve(k) = Max{ve(j) + dut(&lt;j, k&gt;)}</p>
<pre><code>vl(汇点) = ve(汇点)
vl(j) = Min{vl(k) - dut(&lt;j, k&gt;)}</code></pre><p>算法的实现要点：<br>显然，求ve的顺序应该是按拓扑有序的次序，<br>而， 求vl的顺序应该是按拓扑逆序的次序<br>因为 拓扑逆序序列即为拓扑有序序列的逆序列<br>因此 应该在拓扑排序的过程中，另设一个“栈”几下拓扑有序序列 出栈就是拓扑逆序序列</p>
<p>P30 ：0:00 动画演示关键路径算法</p>
<p>拓扑排序：<br>1、每个点求入度<br>2、把入度为0的点入栈P(拓扑排序入度为0的栈) // 栈p出栈的序列就是拓扑有序序列，出栈入栈Q为拓扑有序序列，栈Q出栈的顺序有拓扑逆序序列，<br>3、出栈结点的所有的邻接点，入度减1<br>4、入度为0的点再入栈P（多个）<br>5、然后出栈，出栈结点邻接点，入度减1 ，迭代，入度为0的入栈，</p>
<h2 id="6、重复3-4，5-一直到最后"><a href="#6、重复3-4，5-一直到最后" class="headerlink" title="6、重复3,4，5 一直到最后"></a>6、重复3,4，5 一直到最后</h2><p>1、熟悉图的各种存储结构及其构造算法，了解实际问题的求解效率与采用何种存储结构和算法有密切联系<br>2、熟练掌握图的两种搜索路径的遍历：<br>    遍历的逻辑定义、深度优先搜索的两种形式（递归和非递归）和广度优先搜索的算法。在学习中应注意图的遍历算法与树的遍历算法之间的类似和差异<br>3、应用图的遍历算法求解各种简单路径问题<br>4、理解教科书中讨论的各种图的算法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/13/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/13/linux/" itemprop="url">linux$</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T11:53:26+08:00">
                2019-08-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-13T15:26:27+08:00">
                2019-08-13
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/13/linux/" class="leancloud_visitors" data-flag-title="linux$">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h3><blockquote>
<p>工作中用到的linux命令记录</p>
</blockquote>
<h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><p><strong>盘符切换命令 cd</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /root/Docements # 切换到目录/root/Docements</span><br><span class="line">cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录  </span><br><span class="line">cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</span><br></pre></td></tr></table></figure>

<p><strong>创建目录 mkdir</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项]... 目录... </span><br><span class="line"> -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask</span><br><span class="line"> -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; </span><br><span class="line"> -v, --verbose  每次创建新目录都显示信息</span><br></pre></td></tr></table></figure>

<p><strong>删除命令 rm</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</span><br><span class="line">-i ：互动模式，在删除前会询问用户是否操作</span><br><span class="line">-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</span><br><span class="line"></span><br><span class="line">删除文件夹</span><br><span class="line">rm -ir filedir 这个命令需要确认每个文件是否要被删除，文件过多会很繁琐</span><br><span class="line">rm -rf filedir 这个命令会直接删除文件夹，不会给出警告信息和提示</span><br></pre></td></tr></table></figure>

<p><strong>移动命令 mv</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br><span class="line">-i ：若目标文件已经存在，就会询问是否覆盖</span><br><span class="line">-u ：若目标文件已经存在，且比目标文件新，才会更新</span><br></pre></td></tr></table></figure>

<p><strong>复制命令 cp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a ：将文件的特性一起复制</span><br><span class="line">-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</span><br><span class="line">-r ：递归持续复制，用于目录的复制行为</span><br><span class="line">-u ：目标文件与源文件有差异时才会复制</span><br></pre></td></tr></table></figure>

<p><strong>查看文件夹内容 LS</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ </span><br><span class="line">-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ </span><br><span class="line">-d ：仅列出目录本身，而不是列出目录内的档案数据 </span><br><span class="line">-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) </span><br><span class="line">-F ：根据档案、目录等信息，给予附加数据结构，例如： </span><br><span class="line">*：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； </span><br><span class="line">-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； </span><br><span class="line">-i ：列出 inode 位置，而非列出档案属性； </span><br><span class="line">-l ：长数据串行出，包含档案的属性等等数据； </span><br><span class="line">-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) </span><br><span class="line">-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； </span><br><span class="line">-R ：连同子目录内容一起列出来； </span><br><span class="line">-S ：以档案容量大小排序！ </span><br><span class="line">-t ：依时间排序 </span><br><span class="line">--color=never ：不要依据档案特性给予颜色显示； </span><br><span class="line">--color=always ：显示颜色 </span><br><span class="line">--color=auto ：让系统自行依据设定来判断是否给予颜色 </span><br><span class="line">--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 </span><br><span class="line">--time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) </span><br><span class="line">而非内容变更时间 (modification time)</span><br></pre></td></tr></table></figure>

<p><strong>查看当前工作目录的完整路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd -P # 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径</span><br></pre></td></tr></table></figure>

<p><strong>压缩解压命令 tar</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c ：新建打包文件</span><br><span class="line">-t ：查看打包文件的内容含有哪些文件名</span><br><span class="line">-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</span><br><span class="line">-j ：通过bzip2的支持进行压缩/解压缩</span><br><span class="line">-z ：通过gzip的支持进行压缩/解压缩</span><br><span class="line">-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</span><br><span class="line">-f filename ：filename为要处理的文件</span><br><span class="line">-C dir ：指定压缩/解压缩的目录dir</span><br></pre></td></tr></table></figure>

<p><strong>压缩文件或文件夹为.gz gzip</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> gzip[参数][文件或者目录]</span><br><span class="line">-a or --ascii 　使用ASCII文字模式。 </span><br><span class="line">-c or --stdout or --to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 </span><br><span class="line">-d or --decompress or ----uncompress 　解开压缩文件。 </span><br><span class="line">-f or --force 　强行压缩文件。不理会文件名称 or 硬连接是否存在以及该文件是否为符号连接。 </span><br><span class="line">-h or --help 　在线帮助。 </span><br><span class="line">-l or --list 　列出压缩文件的相关信息。 </span><br><span class="line">-L or --license 　显示版本与版权信息。 </span><br><span class="line">-n or --no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 </span><br><span class="line">-N or --name 　压缩文件时，保存原来的文件名称及时间戳记。 </span><br><span class="line">-q or --quiet 　不显示警告信息。 </span><br><span class="line">-r or --recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </span><br><span class="line">-S&lt;压缩字尾字符串&gt; or ----suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 </span><br><span class="line">-t or --test 　测试压缩文件是否正确无误。 </span><br><span class="line">-v or --verbose 　显示指令执行过程。 </span><br><span class="line">-V or --version 　显示版本信息。 </span><br><span class="line">-num 用指定的数字num调整压缩的速度，-1 or --fast表示最快压缩方法（低压缩比），-9 or --best表示最慢压缩方法（高压缩比）。系统缺省值为6。</span><br></pre></td></tr></table></figure>

<p><strong>远程登录Linux主机 ssh命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-l login_name] [-p port] [user@]hostname</span><br></pre></td></tr></table></figure>

<p><strong>Linux下进行远程拷贝文件的命令 scp命令</strong></p>
<blockquote>
<p>scp secure copy, 与cp命令类似，但是cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [原路径] [目标路径]</span><br><span class="line"></span><br><span class="line">-1 强制scp命令使用协议ssh1 </span><br><span class="line">-2 强制scp命令使用协议ssh2 </span><br><span class="line">-4 强制scp命令只使用IPv4寻址 </span><br><span class="line">-6 强制scp命令只使用IPv6寻址 </span><br><span class="line">-B 使用批处理模式（传输过程中不询问传输口令或短语） </span><br><span class="line">-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） </span><br><span class="line">-p 保留原文件的修改时间，访问时间和访问权限。 </span><br><span class="line">-q 不显示传输进度条。 </span><br><span class="line">-r 递归复制整个目录。 </span><br><span class="line">-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 </span><br><span class="line">-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 </span><br><span class="line">-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 </span><br><span class="line">-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 </span><br><span class="line">-l limit 限定用户所能使用的带宽，以Kbit/s为单位。 </span><br><span class="line">-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， </span><br><span class="line">-P port 注意是大写的P, port是指定数据传输用到的端口号 </span><br><span class="line">-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure>

<p><strong>远程登录操作 telnet命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">telnet[参数][主机]</span><br><span class="line"></span><br><span class="line">-8 允许使用8位字符资料，包括输入与输出。</span><br><span class="line">-a 尝试自动登入远端系统。</span><br><span class="line">-b&lt;主机别名&gt; 使用别名指定远端主机名称。</span><br><span class="line">-c 不读取用户专属目录里的.telnetrc文件。</span><br><span class="line">-d 启动排错模式。</span><br><span class="line">-e&lt;脱离字符&gt; 设置脱离字符。</span><br><span class="line">-E 滤除脱离字符。</span><br><span class="line">-f 此参数的效果和指定&quot;-F&quot;参数相同。</span><br><span class="line">-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</span><br><span class="line">-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</span><br><span class="line">-K 不自动登入远端主机。</span><br><span class="line">-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</span><br><span class="line">-L 允许输出8位字符资料。</span><br><span class="line">-n&lt;记录文件&gt; 指定文件记录相关信息。</span><br><span class="line">-r 使用类似rlogin指令的用户界面。</span><br><span class="line">-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。</span><br><span class="line">-x 假设主机有支持数据加密的功能，就使用它。</span><br><span class="line">-X&lt;认证形态&gt; 关闭指定的认证形态。</span><br></pre></td></tr></table></figure>

<p><strong>远程下载命令 wget命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">wget [参数] [URL地址]</span><br><span class="line"></span><br><span class="line">启动参数：</span><br><span class="line">-V, –version 显示wget的版本后退出</span><br><span class="line">-h, –help 打印语法帮助</span><br><span class="line">-b, –background 启动后转入后台执行</span><br><span class="line">-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc</span><br><span class="line"></span><br><span class="line">记录和输入文件参数：</span><br><span class="line">-o, –output-file=FILE 把记录写到FILE文件中</span><br><span class="line">-a, –append-output=FILE 把记录追加到FILE文件中</span><br><span class="line">-d, –debug 打印调试输出</span><br><span class="line">-q, –quiet 安静模式(没有输出)</span><br><span class="line">-v, –verbose 冗长模式(这是缺省设置)</span><br><span class="line">-nv, –non-verbose 关掉冗长模式，但不是安静模式</span><br><span class="line">-i, –input-file=FILE 下载在FILE文件中出现的URLs</span><br><span class="line">-F, –force-html 把输入文件当作HTML格式文件对待</span><br><span class="line">-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀</span><br><span class="line">–sslcertfile=FILE 可选客户端证书</span><br><span class="line">–sslcertkey=KEYFILE 可选客户端证书的KEYFILE</span><br><span class="line">–egd-file=FILE 指定EGD socket的文件名</span><br><span class="line"></span><br><span class="line">下载参数：</span><br><span class="line">–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)</span><br><span class="line">-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).</span><br><span class="line">-O –output-document=FILE 把文档写到FILE文件中</span><br><span class="line">-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀</span><br><span class="line">-c, –continue 接着下载没下载完的文件</span><br><span class="line">–progress=TYPE 设定进程条标记</span><br><span class="line">-N, –timestamping 不要重新下载文件除非比本地文件新</span><br><span class="line">-S, –server-response 打印服务器的回应</span><br><span class="line">–spider 不下载任何东西</span><br><span class="line">-T, –timeout=SECONDS 设定响应超时的秒数</span><br><span class="line">-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒</span><br><span class="line">–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒</span><br><span class="line">–random-wait 在下载之间等待0…2*WAIT秒</span><br><span class="line">-Y, –proxy=on/off 打开或关闭代理</span><br><span class="line">-Q, –quota=NUMBER 设置下载的容量限制</span><br><span class="line">–limit-rate=RATE 限定下载输率</span><br><span class="line"></span><br><span class="line">目录参数：</span><br><span class="line">-nd –no-directories 不创建目录</span><br><span class="line">-x, –force-directories 强制创建目录</span><br><span class="line">-nH, –no-host-directories 不创建主机目录</span><br><span class="line">-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…</span><br><span class="line">–cut-dirs=NUMBER 忽略 NUMBER层远程目录</span><br><span class="line"></span><br><span class="line">HTTP 选项参数：</span><br><span class="line">–http-user=USER 设定HTTP用户名为 USER.</span><br><span class="line">–http-passwd=PASS 设定http密码为 PASS</span><br><span class="line">-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)</span><br><span class="line">-E, –html-extension 将所有text/html文档以.html扩展名保存</span><br><span class="line">–ignore-length 忽略 `Content-Length’头域</span><br><span class="line">–header=STRING 在headers中插入字符串 STRING</span><br><span class="line">–proxy-user=USER 设定代理的用户名为 USER</span><br><span class="line">–proxy-passwd=PASS 设定代理的密码为 PASS</span><br><span class="line">–referer=URL 在HTTP请求中包含 `Referer: URL’头</span><br><span class="line">-s, –save-headers 保存HTTP头到文件</span><br><span class="line">-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION</span><br><span class="line">–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)</span><br><span class="line">–cookies=off 不使用 cookies</span><br><span class="line">–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie</span><br><span class="line">–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中</span><br><span class="line"></span><br><span class="line">FTP 选项参数：</span><br><span class="line">-nr, –dont-remove-listing 不移走 `.listing’文件</span><br><span class="line">-g, –glob=on/off 打开或关闭文件名的 globbing机制</span><br><span class="line">–passive-ftp 使用被动传输模式 (缺省值).</span><br><span class="line">–active-ftp 使用主动传输模式</span><br><span class="line">–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)</span><br><span class="line"></span><br><span class="line">递归下载参数：</span><br><span class="line">-r, –recursive 递归下载－－慎用!</span><br><span class="line">-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)</span><br><span class="line">–delete-after 在现在完毕后局部删除文件</span><br><span class="line">-k, –convert-links 转换非相对链接为相对链接</span><br><span class="line">-K, –backup-converted 在转换文件X之前，将之备份为 X.orig</span><br><span class="line">-m, –mirror 等价于 -r -N -l inf -nr</span><br><span class="line">-p, –page-requisites 下载显示HTML文件的所有图片</span><br><span class="line"></span><br><span class="line">递归下载中的包含和不包含(accept/reject)：</span><br><span class="line">-A, –accept=LIST 分号分隔的被接受扩展名的列表</span><br><span class="line">-R, –reject=LIST 分号分隔的不被接受的扩展名的列表</span><br><span class="line">-D, –domains=LIST 分号分隔的被接受域的列表</span><br><span class="line">–exclude-domains=LIST 分号分隔的不被接受的域的列表</span><br><span class="line">–follow-ftp 跟踪HTML文档中的FTP链接</span><br><span class="line">–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表</span><br><span class="line">-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表</span><br><span class="line">-H, –span-hosts 当递归时转到外部主机</span><br><span class="line">-L, –relative 仅仅跟踪相对链接</span><br><span class="line">-I, –include-directories=LIST 允许目录的列表</span><br><span class="line">-X, –exclude-directories=LIST 不被包含目录的列表</span><br><span class="line">-np, –no-parent 不要追溯到父目录</span><br><span class="line">wget -S –spider url 不下载只显示过程</span><br></pre></td></tr></table></figure>

<p><strong>查看和配置网络设备 ifconfig命令</strong></p>
<blockquote>
<p>当网络环境发生变化可通过此命令对网络进行相应的配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网络设备] [参数]</span><br><span class="line"></span><br><span class="line">up 启动指定网络设备/网卡。</span><br><span class="line">down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。</span><br><span class="line">arp 设置指定网卡是否支持ARP协议。</span><br><span class="line">-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包</span><br><span class="line">-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包</span><br><span class="line">-a 显示全部接口信息</span><br><span class="line">-s 显示摘要信息（类似于 netstat -i）</span><br><span class="line">add 给指定网卡配置IPv6地址</span><br><span class="line">del 删除指定网卡的IPv6地址</span><br><span class="line">&lt;硬件地址&gt; 配置网卡最大的传输单元</span><br><span class="line">mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)</span><br><span class="line">netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。</span><br><span class="line">tunel 建立隧道</span><br><span class="line">dstaddr 设定一个远端地址，建立点对点通信</span><br><span class="line">-broadcast&lt;地址&gt; 为指定网卡设置广播协议</span><br><span class="line">-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议</span><br><span class="line">multicast 为网卡设置组播标志</span><br><span class="line">address 为网卡设置IPv4地址</span><br><span class="line">txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度</span><br></pre></td></tr></table></figure>

<h2 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h2><p><strong>chmod</strong></p>
<p><strong>使用vi编辑器的命令 vi/vim命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /var/log/aa.log # 打开 /var/log/aa.log文件并编辑</span><br></pre></td></tr></table></figure>

<p><strong>连接文件或标准输入并打印 cat命令</strong></p>
<blockquote>
<p>这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] [文件]...</span><br><span class="line">-A, --show-all           等价于 -vET</span><br><span class="line">-b, --number-nonblank    对非空输出行编号</span><br><span class="line">-e                       等价于 -vE</span><br><span class="line">-E, --show-ends          在每行结束处显示 $</span><br><span class="line">-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号</span><br><span class="line">-s, --squeeze-blank  有连续两行以上的空白行，就代换</span><br></pre></td></tr></table></figure>

<p><strong>查看文件内容 more命令</strong></p>
<blockquote>
<p>more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页查看文件的内容，还支持直接条转行等功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] </span><br><span class="line">命令参数：</span><br><span class="line">+n 从笫n行开始显示</span><br><span class="line">-n 定义屏幕大小为n行</span><br><span class="line">+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 </span><br><span class="line">-c 从顶部清屏，然后显示</span><br><span class="line">-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-l 忽略Ctrl+l（换页）字符</span><br><span class="line">-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class="line">-s 把连续的多个空行显示为一行</span><br><span class="line">-u 把文件内容中的下画线去掉</span><br><span class="line">常用操作命令：</span><br><span class="line">Enter 向下n行，需要定义。默认为1行</span><br><span class="line">Ctrl+F 向下滚动一屏</span><br><span class="line">空格键 向下滚动一屏</span><br><span class="line">Ctrl+B 返回上一屏</span><br><span class="line">= 输出当前行的行号</span><br><span class="line">：f 输出文件名和当前行的行号</span><br><span class="line">V 调用vi编辑器</span><br><span class="line">!命令 调用Shell，并执行命令 </span><br><span class="line">q 退出more</span><br></pre></td></tr></table></figure>

<p><strong>查看文件内容 less命令</strong></p>
<blockquote>
<p>命令用法比起more更加的有弹性，在more的时候，我们并没有办法向前面翻，只能往后看，但是使用less时，就可以使用【pageup】【pagedown】等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容，除此之外less还有更多的搜索功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">less [参数]  文件 </span><br><span class="line">-b &lt;缓冲区大小&gt; 设置缓冲区的大小</span><br><span class="line">-e 当文件显示结束后，自动离开</span><br><span class="line">-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</span><br><span class="line">-g 只标志最后搜索的关键词</span><br><span class="line">-i 忽略搜索时的大小写</span><br><span class="line">-m 显示类似more命令的百分比</span><br><span class="line">-N 显示每行的行号</span><br><span class="line">-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">-Q 不使用警告音</span><br><span class="line">-s 显示连续空行为一行</span><br><span class="line">-S 行过长时间将超出部分舍弃</span><br><span class="line">-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">/字符串：向下搜索“字符串”的功能</span><br><span class="line">?字符串：向上搜索“字符串”的功能</span><br><span class="line">n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">b 向后翻一页</span><br><span class="line">d 向后翻半页</span><br><span class="line">h 显示帮助界面</span><br><span class="line">Q 退出less 命令</span><br><span class="line">u 向前滚动半页</span><br><span class="line">y 向前滚动一行</span><br><span class="line">空格键 滚动一行</span><br><span class="line">回车键 滚动一页</span><br><span class="line">[pagedown]： 向下翻动一页</span><br><span class="line">[pageup]： 向上翻动一页</span><br></pre></td></tr></table></figure>

<p><strong>从指定点开始将文件写到标准输出 tail命令</strong></p>
<blockquote>
<p>从指定点开始将文件写到标准输出，使用tail命令的-f选项可以方便的查阅正在改变的日志文件，tail -f filename会把filename里最尾部的内容显示在屏幕上，并且不断刷新最新的文件内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tail[必要参数][选择参数][文件] </span><br><span class="line"></span><br><span class="line">-f 循环读取</span><br><span class="line">-q 不显示处理信息</span><br><span class="line">-v 显示详细的处理信息</span><br><span class="line">-c&lt;数目&gt; 显示的字节数</span><br><span class="line">-n&lt;行数&gt; 显示行数</span><br><span class="line">--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. </span><br><span class="line">-q, --quiet, --silent 从不输出给出文件名的首部 </span><br><span class="line">-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</span><br></pre></td></tr></table></figure>

<p><strong>用于比较两个文件或目录的不同 diff</strong></p>
<blockquote>
<p>diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效，以逐行的方式，比较文本文件的异同处，如果指定比较的是目录的时候，diff命令会比较两个目录下名字相同的文本文件，列出不同的二进制文件、公共子目录和只在一个目录出现的文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">diff[参数][文件1或目录1][文件2或目录2]</span><br><span class="line"></span><br><span class="line"># diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的</span><br><span class="line"># 文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</span><br><span class="line"></span><br><span class="line">-a or --text 　#diff预设只会逐行比较文本文件。</span><br><span class="line">-b or --ignore-space-change 　#不检查空格字符的不同。</span><br><span class="line">-B or --ignore-blank-lines 　#不检查空白行。</span><br><span class="line">-c 　#显示全部内文，并标出不同之处。</span><br><span class="line">-C or --context 　#与执行&quot;-c-&quot;指令相同。</span><br><span class="line">-d or --minimal 　#使用不同的演算法，以较小的单位来做比较。</span><br><span class="line">-D or ifdef 　#此参数的输出格式可用于前置处理器巨集。</span><br><span class="line">-e or --ed 　#此参数的输出格式可用于ed的script文件。</span><br><span class="line">-f or -forward-ed 　#输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span><br><span class="line">-H or --speed-large-files 　#比较大文件时，可加快速度。</span><br><span class="line">-l or --ignore-matching-lines 　#若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符 or 字符串，则不显示这两个文件的差异。</span><br><span class="line">-i or --ignore-case 　#不检查大小写的不同。</span><br><span class="line">-l or --paginate 　#将结果交由pr程序来分页。</span><br><span class="line">-n or --rcs 　#将比较结果以RCS的格式来显示。</span><br><span class="line">-N or --new-file 　#在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span><br><span class="line">-p 　#若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span><br><span class="line">-P or --unidirectional-new-file 　#与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span><br><span class="line">-q or --brief 　#仅显示有无差异，不显示详细的信息。</span><br><span class="line">-r or --recursive 　#比较子目录中的文件。</span><br><span class="line">-s or --report-identical-files 　#若没有发现任何差异，仍然显示信息。</span><br><span class="line">-S or --starting-file 　#在比较目录时，从指定的文件开始比较。</span><br><span class="line">-t or --expand-tabs 　#在输出时，将tab字符展开。</span><br><span class="line">-T or --initial-tab 　#在每行前面加上tab字符以便对齐。</span><br><span class="line">-u,-U or --unified= 　#以合并的方式来显示文件内容的不同。</span><br><span class="line">-v or --version 　#显示版本信息。</span><br><span class="line">-w or --ignore-all-space 　#忽略全部的空格字符。</span><br><span class="line">-W or --width 　#在使用-y参数时，指定栏宽。</span><br><span class="line">-x or --exclude 　#不比较选项中所指定的文件 or 目录。</span><br><span class="line">-X or --exclude-from 　#您可以将文件 or 目录类型存成文本文件，然后在=中指定此文本文件。</span><br><span class="line">-y or --side-by-side 　#以并列的方式显示文件的异同之处。</span><br></pre></td></tr></table></figure>

<p><strong>确定主机与外部链接状态 ping命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ping [参数] [主机名或IP地址]</span><br><span class="line">-d 使用Socket的SO_DEBUG功能。</span><br><span class="line">-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。</span><br><span class="line">-n 只输出数值。</span><br><span class="line">-q 不显示任何传送封包的信息，只显示最后的结果。</span><br><span class="line">-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。</span><br><span class="line">-R 记录路由过程。</span><br><span class="line">-v 详细显示指令的执行过程。</span><br><span class="line">&lt;p&gt;-c 数目：在发送指定数目的包后停止。</span><br><span class="line">-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。</span><br><span class="line">-I 网络界面：使用指定的网络界面送出数据包。</span><br><span class="line">-l 前置载入：设置在送出要求信息之前，先行发出的数据包。</span><br><span class="line">-p 范本样式：设置填满数据包的范本样式。</span><br><span class="line">-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。</span><br><span class="line">-t 存活数值：设置存活数值TTL的大小。</span><br></pre></td></tr></table></figure>

<p><strong>为某一个文件在另一个位置建立一个同步的链接</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</span><br><span class="line"></span><br><span class="line">软链接：</span><br><span class="line">1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</span><br><span class="line">2.软链接可以 跨文件系统 ，硬链接不可以</span><br><span class="line">3.软链接可以对一个不存在的文件名进行链接</span><br><span class="line">4.软链接可以对目录进行链接</span><br><span class="line"></span><br><span class="line">硬链接:</span><br><span class="line">1.硬链接，以文件副本的形式存在。但不占用实际空间。</span><br><span class="line">2.不允许给目录创建硬链接</span><br><span class="line">3.硬链接只有在同一个文件系统中才能创建</span><br><span class="line"></span><br><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br><span class="line"></span><br><span class="line">必要参数:</span><br><span class="line">-b 删除，覆盖以前建立的链接</span><br><span class="line">-d 允许超级用户制作目录的硬链接</span><br><span class="line">-f 强制执行</span><br><span class="line">-i 交互模式，文件存在则提示用户是否覆盖</span><br><span class="line">-n 把符号链接视为一般目录</span><br><span class="line">-s 软链接(符号链接)</span><br><span class="line">-v 显示详细的处理过程</span><br><span class="line"></span><br><span class="line">选择参数:</span><br><span class="line">-S “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”</span><br><span class="line">-V “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/pm2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/pm2/" itemprop="url">pm2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T17:00:25+08:00">
                2019-08-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-15T14:12:50+08:00">
                2019-08-15
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/12/pm2/" class="leancloud_visitors" data-flag-title="pm2">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  440
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>pm2 安装为root用户安装，现切换为普通user用户使用pm2报错，正在解决：<br>解决方案一：SUDO，赋予普通用户临时root权限，并限制监控user操作，实现服务的可控。<br>SUDO（substitude user do）使得系统管理员可以授权特定用户或用户组作为临时root执行命令，同时还能对命令及其参数提供审核跟踪。可以针对单个命令、仅在需要时授予临时权限，减少因为执行错误命令损坏系统，sudo也能以其他用户身份执行命令并且记录用户执行的命令，以及失败的权限申请。<br>手册参考：[ps:全英文]<br><a href="https://gratisoft.us/sudo/man.html" target="_blank" rel="noopener">https://gratisoft.us/sudo/man.html</a><br><a href="https://gratisoft.us/sudo/man/1.8.6/sudoers.man.html" target="_blank" rel="noopener">https://gratisoft.us/sudo/man/1.8.6/sudoers.man.html</a></p>
</blockquote>
<p><a href="https://wiki.archlinux.org/index.php/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p>
<p>pm2 非root用户权限设置</p>
<h3 id="检查状态-日志-指标"><a href="#检查状态-日志-指标" class="headerlink" title="检查状态 日志 指标"></a>检查状态 日志 指标</h3><p><strong>列出托管应用程序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 [list|ls|status]</span><br></pre></td></tr></table></figure>

<p><strong>显示日志</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">显示实时日志：</span><br><span class="line">pm2 logs</span><br><span class="line">显示就日志：</span><br><span class="line">pm2 logs --lines 200</span><br><span class="line">基于终端仪表盘：</span><br><span class="line">pm2 monit</span><br></pre></td></tr></table></figure>

<p><strong>管理应用程序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pm2 restart app</span><br><span class="line">pm2 reload app</span><br><span class="line">pm2 stop app</span><br><span class="line">pm2 delete app</span><br></pre></td></tr></table></figure>

<p><strong>集群模式</strong></p>
<blockquote>
<p>对于node.js应用程序，PM2包括一个自动负载均衡器，它将共享每个进程这件的所有http[s]/websocket/tcp/udp连接</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要以集群模式启动应用程序:</span><br><span class="line">pm2 start app.js -i max</span><br></pre></td></tr></table></figure>

<p><strong>用户不在sudoers文件中的解决方法</strong><br>1、查看/etc/sudoers文件权限，如果为只读权限，修改为可写权限<br>ls -l /etc/sudoers</p>
<p>2、修改sudoers文件的权限不只是只读<br>chmod 777 /etc/sudoers</p>
<p>3、编辑sudoers文件，添加user用户为所有可执行权限</p>
<p>4、修改回sudoers权限为440<br>chmod 440 sudoers</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/bekjae.jpg" alt="KOKI HOO">
            
              <p class="site-author-name" itemprop="name">KOKI HOO</p>
              <p class="site-description motion-element" itemprop="description">PEACE&LOVE</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KOKI HOO</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">44.6k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jD3hLxRDgCSdorrir1RFkW3R-gzGzoHsz", "9AOQX6uUKthSSONK5UO95RGd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
