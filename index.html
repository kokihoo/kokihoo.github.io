<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="PEACE&amp;LOVE">
<meta property="og:type" content="website">
<meta property="og:title" content="KOKI">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="KOKI">
<meta property="og:description" content="PEACE&amp;LOVE">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KOKI">
<meta name="twitter:description" content="PEACE&amp;LOVE">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>KOKI</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a5ecac7771fad0fda5191a255b9e3f5c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KOKI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/19/xulun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/xulun/" itemprop="url">xulun</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T11:08:35+08:00">
                2019-08-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-19T18:02:48+08:00">
                2019-08-19
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DATA-STRUCTURE/" itemprop="url" rel="index">
                    <span itemprop="name">DATA STRUCTURE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/19/xulun/" class="leancloud_visitors" data-flag-title="xulun">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据结构讨论的范畴"><a href="#数据结构讨论的范畴" class="headerlink" title="数据结构讨论的范畴"></a>数据结构讨论的范畴</h3><p>####<br>数据结构与程序设计密切相关</p>
<blockquote>
<p>程序设计：为计算机处理问题编制一组指令集</p>
<ul>
<li>怎么处理，处理的策略是什么，这是算法要讨论的问题</li>
<li>对处理的信息怎么表示，问题的数据模型是什么<br>算法：处理问题的策略<br>数据结构: 问题的数学模型</li>
</ul>
</blockquote>
<p>  例如：数值计算的程序设计问题：</p>
<p>  结构静力分析计算——线性代数方程组<br>  全球天气预报——环流模式方程</p>
<p>  例一：求一组（n个）整数中的最大值：<br>  算法：？基本操作是“比较两个数的大小”<br>  模型：？<br>  例二： 计算机对弈<br>  算法：？对弈的规则和策略<br>  模型: ?<br>  例三：足协的数据库管理<br>  算法：？需要管理的项目？如何管理？用户界面<br>  模型：？</p>
<p>数据结构描述显示世界实体的数学模型（非数值计算）及其上的操作在计算机中的表示和实现。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="数据与数据结构"><a href="#数据与数据结构" class="headerlink" title="数据与数据结构"></a>数据与数据结构</h4><ul>
<li>数据：（数据操作对象）所有能被输入到计算机中，且被计算机处理的符号的集合计算机操作的对象的总称，是计算机处理的信息的某种特定的符号表示形式。</li>
<li>数据元素：数据中的一个“个体”，数据结构中讨论的基本单位，是数据项的集合</li>
<li>数据项：数据结构中讨论的最小单位，数据元素是数据项的集合。<br>例如：运动员（数据元素） 包含6个数据项：姓名 俱乐部名称 出生日期（由，年月日三个数据项组成，出生日期称为组合项） 参加日期 职务 业绩 </li>
<li>数据结构：带<strong>结构</strong>的数据元素的集合<br>例如：一个含12位数的十进制数可以用三个4位十进制数表示<br>3214,6587,9345 - al(3214)，a2(6587),a3(9345)<br>在a1，a2，a3之间存在“次序”关系<br>&lt;a1, a2&gt;、&lt;a2, a3&gt;<br>次序颠倒：a1 a2 a3（3214,6587,9345） 不等于 a2 a1 a3（6587,3214,9345）</li>
</ul>
<p>又例：2行3列的二维数组{a1，a2，a3，a4，a5，a6}<br>    a1 |a2 |a3<br>    a4 |a5 |a6<br>    行的次序关系：row= {&lt;a1, a2&gt;,&lt;a2, a3&gt;,&lt;a3, a4&gt;,&lt;a4, a5&gt;,&lt;a5, a6&gt;}<br>    列的次序关系：clo = {&lt;a1, a4&gt;,&lt;a2, a5&gt;,&lt;a3, a6&gt;}</p>
<pre><code>a1 a3 a5        a1 a2 a3
a2 a4 a6 不等于  a4 a5 a6</code></pre><p>再例，一维数组{a1，a2，a3，a4，a5，a6}中存在次序关系：{&lt;ai,ai+1&gt;| i = 1,2,3,4,5}}</p>
<p>数据的逻辑关系可以归纳为以下四类：<br>线性结构：<img src="/images/line.png" alt="线性结构"><br>树形结构：<img src="/images/tree.png" alt="树性结构"><br>图形结构：<img src="/images/graph.png" alt="图性结构"><br>集合结构：<img src="/images/cluster.png" alt="集合结构"></p>
<p>数据结构的形式定义为：<br>    数据结构是一个二元组<br>        Data_Structures = (D,S)，其中：D是数据元素的有限集，S是D上关系的有限集</p>
<p>数据的存储结构-逻辑结构在存储器中的映象</p>
<p>数据元素的映象方法：<br>用二进制位（bit）的位串表示数据元素：<br>（321）10 = （501）8 = （101000001）2；<br>A = （101）8 = （001000001）2；</p>
<p>关系的映象方法：表示&lt;x, y&gt;的方法</p>
<p>顺序映象：以存储位置的相邻表示后继关系<br>    y的存储位置和x的存储位置之间差一个常量C，C是一个隐含值，整个存储结构中只含数据元素本身的信息，没有附加信息<br>    ————<br>    x|y<br>    ————</p>
<p>链式映象：以附加信息（指针）表示后继关系，需要用一个和X在一起的附加信息指示y的存储位置</p>
<p>在不同的编程环境中,存储结构有不同的描述方法<br>当用高级程序设计语言进行编程时，通常可用高级标称语言语言中提供的数据类型描述之</p>
<p>例如：以三个带有次序关系的整数表示一个长整数时，可利用C语言中提供的整数数组类型，定义长整数为：<br>    typedef int Long_int[3]</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><pre><code>在用高级程序语言填写的程序中，必须对程序中出现的每个变量或表达式，明确说明它们所属的数据类型。

数据类型是一个值的集合和定义在此集合上的一组操作的总称。【数值型 结构型】</code></pre><h4 id="抽象数据类型-Abstract-Data-Type-简称ADT"><a href="#抽象数据类型-Abstract-Data-Type-简称ADT" class="headerlink" title="抽象数据类型 Abstract Data Type 简称ADT"></a>抽象数据类型 Abstract Data Type 简称ADT</h4><pre><code>是指一个数据模型以及定义在此数据模型上的一组操作
ADT有两个重要特征：
**数据抽象**：用ADT描述程序处理的实体时，强调的是其本质的特征、其所能完成的功能以及它和外部用户的接口（即外界使用它的方法）
例如：抽象数据类型复数的定义：
    ADT Complex {
        数据对象：D = {e1，e2 | e2，e2∈RealSet}
        数据关系：R1 = {&lt;e1,e2&gt;| e1是复数的实数部分，e2的复数的虚数部分}
        基本操作：
            - InitComplex(&amp;Z，v1，v2) 操作结果：构造复数Z，其实部和虚部分别被赋以参数v1和v2的值。
            - DestoryComplex(&amp;Z) 操作结果：复数Z被销毁
            - GetReal(Z, &amp;realPart) 初始条件：复数已存在。 操作结果: 用realPart返回复数Z的实部值
            - GetImag(Z, &amp;ImagPart) 初始条件：复数已存在。 操作结果： 用ImagPart返回复数Z的虚部值
            - Add(z1,z2,&amp;sum) 初始条件z1，z2是复数。操作结果：用sum返回两个复数z1，z2的和值                        
    } ADT Complex
**数据封装**：将实体的外部特性和其内部实现细节分离，并且对外部用户隐藏其实现细节

抽象数据类型的描述方法：
    抽象数据类型可用（D，S，P）三元组表示：其中D是数据对象，S是D上的关系集，P是对D的基本操作集
抽象数据类型的表示和实现：抽象数据类型需要通过固有数据类型（高级编程语言中已实现的数据类型）来实现</code></pre><h3 id="算法及其量度"><a href="#算法及其量度" class="headerlink" title="算法及其量度"></a>算法及其量度</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><pre><code>算法是为了解决某类问题而规定的一个有限长的操作序列，一个算法必须满足一下五个重要特性：
有穷性 确定性 可行性 有输入 有输入
1、有穷性： 对于任意一组合法输入值，在执行有穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成
2、确定性：对于每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行，并且在任何条件下，算法都只有一条执行路径。
3、可行性：算法中的所有操作必须足够基本，都可以通过已经实现的基本操作运算有限次实现之
4、有输入：作为算法加工对象的量值，通常体现为算法中的一组变量。有些输入量需要在算法执行过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法中
5、有输出：它是一组与输入与确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法的功能</code></pre><h4 id="算法设计的原则"><a href="#算法设计的原则" class="headerlink" title="算法设计的原则"></a>算法设计的原则</h4><pre><code>1、正确性 ，首先算法应当满足以特定的规格说明方式给出的需求，其次，对算法是否正确的理解可以有一下四个层次：
            a 程序中不含语法错误
            b 程序对于几组输入数据能够得出满足要求的结果
            c 程序对于精心选择的、典型。苛刻且带有刁难性的几组输入数据能够得出满足要求的结果（边界，临界）
            d 程序对于一切合法的输入数据都能得到满足要求的结果
2、可读性 算法主要是为了人的阅读和交流，其次才是为了计算机执行，因此算法应该易于人的理解，另一方面，晦涩难读的程序易于隐藏较多错误而难以调试
3、健壮性 当输入的数据非法时，算法应当恰当地做出反映或进行相应处理，而不是莫名其妙的输出结果，并且，处理出错的方法不应是中断程序的执行，而应是返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理
4、高效率与低存储量需求 通常效率指的是算法执行时间，存储量指的是算法执行过程中所需的最大存储空间，两者都与问题的规模有关。</code></pre><h4 id="算法效率的衡量方法和准则"><a href="#算法效率的衡量方法和准则" class="headerlink" title="算法效率的衡量方法和准则"></a>算法效率的衡量方法和准则</h4><p>通常有两种衡量算法效率的方法：<br>事后统计法：<br>    缺点：<br>        - 必须执行程序<br>        - 其它因素掩盖算法本质<br>事前分析估算法</p>
<blockquote>
<p>和算法执行时间相关的因素</p>
<ul>
<li>算法选用的策略</li>
<li>问题的规模</li>
<li>编写程序的语言</li>
<li>编译程序产生的机器代码的质量</li>
<li>计算机执行指令的速度<br>一个特定算法的“运行工作量”的大小，只依赖于问题的规模（通常用整数n表示），或者说它是问题规模的函数</li>
</ul>
</blockquote>
<p>假如，随着问题规模n的增长，算法执行时间的增长率和f（n）的增长率相同，则可记作：<br>    T（n） = O（f（n））<br>    称T（n）为算法的（渐近）时间复杂度</p>
<p>如何估算算法的时间复杂度？<br>    算法 = 控制结构 + 若干原操作（固有数据类型的操作）<br>    算法的执行时间 = ∑原操作（i）的执行次数 * 原操作（i）的执行时间<br>    算法的执行时间与原操作执行次数之和成正比</p>
<pre><code>从算法中选取一种对于所研究的问题来说是**基本操作**的原操作，以该基本操作**在算法中重复执行的次数作为算法中重复执行的次数**，作为算法运行时间的衡量准则</code></pre><p>例一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line"> for(j=1; j&lt;=n; ++j)&#123;</span><br><span class="line">     c[i,j] = 0;</span><br><span class="line">     for(k=1; k&lt;=n; ++k)</span><br><span class="line">        c[i,j] += a[i,k]*b[k,j] // 此处乘法操作为基本操作</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 基本操作：乘法操作<br> 时间复杂度：O(n^3)</p>
<p>例二 选择排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void select_sort(int a[], int n)&#123;</span><br><span class="line">    // 将a中整数序列重新排序成自小到大有序的整数序列</span><br><span class="line">    for(i = 0; i&lt; n-1; ++i)&#123; // 循环n次</span><br><span class="line">        j = i;</span><br><span class="line">        for(k = i+1; k&lt;n ; ++k) // n-1+n-2+n-3 + …… +1= n(n-1)/2</span><br><span class="line">            if(a[k] &lt; a[j]) j = k;</span><br><span class="line">        if(j!=i) a[j] &lt;--&gt; a[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // select_sort</span><br></pre></td></tr></table></figure>

<p>控制结构是两层循环:<br>基本操作: 比较(数据元素)操作<br>时间复杂度：O(n^2)</p>
<p>语句的执行次数为语句的频度</p>
<p>例三 冒泡排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void bubble_sort(int a[], int n)&#123;</span><br><span class="line">    // 将a中整数序列重新排列成自小至大</span><br><span class="line">    // 有序的整数序列</span><br><span class="line">    for(i=n-1, change = TRUE; i&gt;1&amp;&amp;change; --i)&#123;</span><br><span class="line">        change = FALSE;</span><br><span class="line">        for(j=0; j&lt;i; ++j)</span><br><span class="line">            if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">                a[j] &lt;--&gt; a[j+1];</span><br><span class="line">                change = TRUE</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; // bubble_sort</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/16/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/python/" itemprop="url">python</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T15:35:10+08:00">
                2019-08-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-21T17:16:16+08:00">
                2019-08-21
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/16/python/" class="leancloud_visitors" data-flag-title="python">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于计算机来说，二进制在物理器件上来说是最容易实现的（高压电表示1 ， 低压电表示0 ），于是冯 诺依曼结构的计算机都使用了二进制</p>
<p>量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息</p>
<h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><p>在程序设计中，变量时一种存储数据的载体，计算机中的变量时实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多类型，除了数值外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型，Python中的数据类型很多，而且也允许我们自定义新的数据类型,以下为几种常见的数据类型。</p>
<ul>
<li>整型： Python中可以处理任意大小的整数(Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此Python3.x中整数就只有int这一种了)，而且支持二进制、八进制、十进制、和十六进制的表示法</li>
<li>浮点型： 浮点数也就是小数，之所以称为浮点数，也是因为科学计数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法(123.456)之外还支持科学计数法(如1.2346e2)</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如’hello’和“hello”,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式(用三个单引号或三个双引号开头，是三个单引号三个双引号结尾)</li>
<li>布尔型：布尔值只有True,False两种值，在Python中，可以直接用True、False表示布尔值(请注意大小写)，也可以通过布尔运算计算出来（例如3&lt;5 会产生布尔值True，而 2==1 会产生布尔值False）。</li>
<li>复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部i换成了j</li>
</ul>
<p>数字：int和float，Python要支持其他类型的数字，例如Decimal或者Fraction。Python也内置对复数的支持，使用后缀j和J就可以表示虚数的部分（例：3+5j）<br>字符串：</p>
<ul>
<li>可以使用单引号(‘……’)，双引号(“……”)</li>
<li>反斜杠\可以用来转义，如果不希望前置\的字符转义成特殊字符，可以使用原始字符串方式，在引号前添加r即可</li>
<li>字符串字面值可以跨行连续输入，一种方式是用三重引号：”””……”””或’’’……’’’.字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个\即可。</li>
<li>字符串可以用+进行连接（粘到一起），也可以用*进行重复</li>
<li>相邻的两个或多个字符串字面值(引号引起来的字符)将会自动连接到一起，把很长的字符串拆开分别输入的时候尤其有用：只能对两个字面值这样操作，变量或者表达式不行，如果想连接变量，或者连接变量和字面值，可以用+号</li>
<li>字符串是可以被索引(下标访问)的，第一个字符索引是0，单个字符并没有特殊的类型，只是一个长度为一的字符串：</li>
<li>索引也可以是负数，这种会从右边开始数，-0和0是一样的，所以负数索引从-1开始</li>
<li>除了索引，字符春还支持切片，索引可以得到单个字符，而切片可以获取子字符串</li>
</ul>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>对于每个变量我们需要给它取一个名字，在Python中，变量命名需要遵循以下这些必须遵守的硬性规则：</p>
<p>硬性规则：</p>
<ul>
<li>变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头</li>
<li>大小写敏感（大写的A和小写的a是两个不同的变量）</li>
<li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突</li>
</ul>
<p>PEP 8 要求;</p>
<ul>
<li>用小写字母拼写，多个单词用下划线连接</li>
<li>受保护的实例属性用单个下划线开头</li>
<li>私有的实例属性用两个下划线开头</li>
</ul>
<p>作为一个专业的程序员，给变量事实上是所有的标识符命名时做到见名知意也是非常重要的。</p>
<h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><p>使用input()函数获取键盘输入<br>使用int()进行类型转换<br>用占位符格式化输出的字符串<br>用type()检查变量的类型<br>在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是我们后面要讲的创建对象的构造方法）</p>
<ul>
<li>int(): 将一个数值或字符串转换成整数，可以指定进制</li>
<li>float(): 讲一个字符串转换成浮点数</li>
<li>str(): 将指定的对象转换成字符串形式，可以指定编码</li>
<li>chr(): 将整数转换成改编码对应的字符串(一个字符)</li>
<li>ord(): 将字符串（一个字符）转换成对应的编码(整数)</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[] [:]</td>
<td>下标 切片</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
</tr>
<tr>
<td>~ + -</td>
<td>按位取反,正负号</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘 除 模 整除</td>
</tr>
<tr>
<td>+ -</td>
<td>加 减</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>右移 左移</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>^</td>
<td></td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>小于等于 小于 大于 大于等于</td>
</tr>
<tr>
<td>== !=</td>
<td>等于， 不等于</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>in not in</td>
<td>成分运算符</td>
</tr>
<tr>
<td>not or and</td>
<td>逻辑运算符</td>
</tr>
<tr>
<td>= += -= <em>= /= %= //= *</em>= &amp;= `</td>
<td>= ^= &gt;&gt;= &lt;&lt;= `</td>
</tr>
</tbody></table>
<p>== 说实话表格的最后一个我没看懂 = = </p>
<blockquote>
<p>说明：在实际开发中，如果搞不懂运算符的优先级，可以使用括号来确保运算的执行顺序</p>
</blockquote>
<p>和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于一个执行的整体。</p>
<h4 id="构造程序逻辑"><a href="#构造程序逻辑" class="headerlink" title="构造程序逻辑"></a>构造程序逻辑</h4><p>分支和循环结构会帮助我们将程序中逻辑建立起来，将来我们的程序无论简单复杂，都是由顺序结构、分支结构、循环结构构成的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/order/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/order/" itemprop="url">order</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T17:53:19+08:00">
                2019-08-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-15T18:02:43+08:00">
                2019-08-15
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/15/order/" class="leancloud_visitors" data-flag-title="order">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  152
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>排序</p>
<h3 id="排序基本概念"><a href="#排序基本概念" class="headerlink" title="排序基本概念"></a>排序基本概念</h3><h3 id="插入排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#插入排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="插入排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>插入排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><h3 id="希尔排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#希尔排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="希尔排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>希尔排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><h3 id="选择排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#选择排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="选择排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>选择排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><h3 id="快速排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#快速排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="快速排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>快速排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><h3 id="合并排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#合并排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="合并排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>合并排序，算法基本思想，算法代码，基本的时间复杂度分析</h3><h3 id="基数排序，算法基本思想，算法代码，基本的时间复杂度分析"><a href="#基数排序，算法基本思想，算法代码，基本的时间复杂度分析" class="headerlink" title="基数排序，算法基本思想，算法代码，基本的时间复杂度分析"></a>基数排序，算法基本思想，算法代码，基本的时间复杂度分析</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/search/" itemprop="url">search</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T17:53:05+08:00">
                2019-08-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-15T18:00:39+08:00">
                2019-08-15
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/15/search/" class="leancloud_visitors" data-flag-title="search">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  155
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>查找</p>
<h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><h3 id="对线性关系结构的查找"><a href="#对线性关系结构的查找" class="headerlink" title="对线性关系结构的查找"></a>对线性关系结构的查找</h3><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h3 id="Hash查找法"><a href="#Hash查找法" class="headerlink" title="Hash查找法"></a>Hash查找法</h3><h3 id="常见的Hash函数（直接定址发，随机数法）"><a href="#常见的Hash函数（直接定址发，随机数法）" class="headerlink" title="常见的Hash函数（直接定址发，随机数法）"></a>常见的Hash函数（直接定址发，随机数法）</h3><h3 id="hash冲突的概念"><a href="#hash冲突的概念" class="headerlink" title="hash冲突的概念"></a>hash冲突的概念</h3><h3 id="解决冲突的方法（开散列方法、拉链法、闭散列方法、开址定址法）"><a href="#解决冲突的方法（开散列方法、拉链法、闭散列方法、开址定址法）" class="headerlink" title="解决冲突的方法（开散列方法、拉链法、闭散列方法、开址定址法）"></a>解决冲突的方法（开散列方法、拉链法、闭散列方法、开址定址法）</h3><h3 id="二次聚集现象"><a href="#二次聚集现象" class="headerlink" title="二次聚集现象"></a>二次聚集现象</h3><h3 id="BST树定义，性质，ADT，及其实现"><a href="#BST树定义，性质，ADT，及其实现" class="headerlink" title="BST树定义，性质，ADT，及其实现"></a>BST树定义，性质，ADT，及其实现</h3><h3 id="BST树查找，插入，删除算法"><a href="#BST树查找，插入，删除算法" class="headerlink" title="BST树查找，插入，删除算法"></a>BST树查找，插入，删除算法</h3><h3 id="平衡树（AVL）的定义，性质，ADT及其实现"><a href="#平衡树（AVL）的定义，性质，ADT及其实现" class="headerlink" title="平衡树（AVL）的定义，性质，ADT及其实现"></a>平衡树（AVL）的定义，性质，ADT及其实现</h3><h3 id="平衡树查找、插入算法"><a href="#平衡树查找、插入算法" class="headerlink" title="平衡树查找、插入算法"></a>平衡树查找、插入算法</h3><h3 id="平衡因子的概念"><a href="#平衡因子的概念" class="headerlink" title="平衡因子的概念"></a>平衡因子的概念</h3><h3 id="优先队列与堆"><a href="#优先队列与堆" class="headerlink" title="优先队列与堆"></a>优先队列与堆</h3><h3 id="堆的定义，堆的生成"><a href="#堆的定义，堆的生成" class="headerlink" title="堆的定义，堆的生成"></a>堆的定义，堆的生成</h3><h3 id="调整算法，范围查询"><a href="#调整算法，范围查询" class="headerlink" title="调整算法，范围查询"></a>调整算法，范围查询</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/Graph/" itemprop="url">Graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T17:51:53+08:00">
                2019-08-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-18T23:48:40+08:00">
                2019-08-18
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/15/Graph/" class="leancloud_visitors" data-flag-title="Graph">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>图：社交网络 关系(边) 六度空间理论(SIX DEGREES OF SEPARATION)<br><img src="/images/map_01.png" alt="图的引例"></p>
<p>表示多对多的关系：把线性表 树的关系都包含在内了</p>
<h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><p>表示“多对多的关系”<br>包含：<br>    - 一组顶点：通常是V(Vertex)表示顶点集合<br>    - 一组边: 通常用E(Edge)表示边的集合，表示顶点与顶点的某种关系<br>        边是顶点对：(v,w) ∈ E，边是无向边，其中v，w ∈ V              v——w<br>        有向边：&lt;v,w&gt;表示从v指向w的边（单行边）                      v——&gt;w<br>        *不考虑重边和自回路</p>
<p>抽象数据类型定义：三要素， </p>
<ul>
<li>类型名称：图(Graph)</li>
<li>数据对象集：G(V,E)由一个非空[在说到一个图的时候可以一条边没有，但是不能连一个顶点也没有，必须至少有一个顶点]的有限顶点集合V和一个有限边集合E组成。</li>
<li>操作集：对于任意图 G ∈ Graph, 以及 v ∈ V, e ∈ E<br>  Graph Create(); 建立并返回空图;<br>  Graph InsertVertex(Graph G, Vertex v): 将v插入G;<br>  Graph InsertEdge(Graph G, Edge e): 将e插入G;<br>  void DFS(Graph G, Vertex v): 从顶点v出发深度优先遍历图G;<br>  void BFS(Graph G, Vertex v): 从顶点v出发宽度优先遍历图G;<br>  void ShortestPath(Graph G, Vertex v, int Dist[]): 计算图G中顶点v到任意其他顶点的最短距离<br>  void MST(Graph G): 计算图G的最小生产树<br>  ……<h4 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h4>无</li>
</ul>
<h3 id="图的存储结构：邻接矩阵，邻接表"><a href="#图的存储结构：邻接矩阵，邻接表" class="headerlink" title="图的存储结构：邻接矩阵，邻接表"></a>图的存储结构：邻接矩阵，邻接表</h3><p>怎么在程序中表示一个图？</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵G[N][N]-N个顶点从0到N-1编号（二维数组表示图）：<br>  G[i][j] = 1  若<vi vj>是G中边<br>            0  否则<br>  问题，对于无向图的存储，怎样可以省一半的空间？<br>邻接矩阵的好处<br>  直观、简单、好理解<br>  方便检查任意一对顶点间是否存在边<br>  方便找任一顶点的所有邻接点（有边直接相连的顶点）<br>  方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数称为入度）<br>  如何计算度？</vi></p>
<ul>
<li><p>无向图：对应行（或列）非0元素的个数</p>
</li>
<li><p>有向图：对应行非0元素的个数是“出度”(发出)，对应列非0元素的个数是“入度”（指向）</p>
<p>邻接矩阵有什么不好？<br>浪费空间-存稀疏图（点很多而边很少）有大量无效元素<br>对稠密图（特别树是完全图，顶点之间都有一条边，边数是极大的）还是很合算的。<br>浪费时间-统计稀疏图中一共有多少条边</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素<br>邻接表的顺序是不唯一的，元素以什么顺序出现也是不唯一的。<br><img src="/images/linjiebiao.png" alt="邻接表"><br>一条边会存两遍，对于网路，结构中要增加权重的域<br>邻接表一定要够稀疏才划算。</p>
</li>
</ul>
<p>邻接表<br>    方便找任一顶点的所有邻接点<br>    节约稀疏图的空间<br>        需要N个头指针+2E个结点（每个结点至少2个域）<br>    方便计算任一定点的度？<br>        对无向图：是的<br>        对有向图：只能计算“出度”【正邻接表存的是邻接矩阵的每一行存成一个链表】：需要构造“逆邻接表”【存的是邻接矩阵的每一列存成一个链表】（存指向自己的边）来方便计算入度<br>    方便检查任意一对顶点间是否存在边？<br>        No</p>
<p>表示图的方法并不只有邻接表和邻接矩阵还有别的方法，至于用什么方法来表示图，取决于你要解决的问题。</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>每个顶点访问一遍，不能有重复的访问。为什么要对图做遍历呢？</p>
<h4 id="深度优先遍历-Depth-Frist-Search，DFS"><a href="#深度优先遍历-Depth-Frist-Search，DFS" class="headerlink" title="深度优先遍历 Depth Frist Search，DFS"></a>深度优先遍历 Depth Frist Search，DFS</h4><p>迷宫：<br>树的先序遍历推广<br><img src="/images/shenduyouxian.png" alt="深度优先遍历"><br>若又N个顶点，E条边，时间复杂度是<br>用邻接表存储图。有O（N+E）<br>用邻接矩阵存储图，有O（N^2）</p>
<h4 id="广度优先遍历-Breadth-First-Search-BFS-一圈一圈的搜"><a href="#广度优先遍历-Breadth-First-Search-BFS-一圈一圈的搜" class="headerlink" title="广度优先遍历 Breadth First Search,BFS 一圈一圈的搜"></a>广度优先遍历 Breadth First Search,BFS 一圈一圈的搜</h4><p>相当于树里面的层次遍历<br><img src="/images/guangdubianli.png" alt="广度优先遍历"><br>若有N个顶点、E条边，时间复杂度是<br>用邻接表存储图。有O（N+E）<br>用邻接矩阵存储图，有O（N^2）</p>
<p>为什么要需要两种遍历？<br>图不连通怎么办？</p>
<ul>
<li>连通：如果从v到w存在一条（无向）路径，则称v和w是连通的。</li>
<li>路径：v到w的路径是一系列顶点（V，v1，v2……，vn，w）的集合，其中任一对相邻的顶点间都有图中的边</li>
<li>路径的长度：是路径中的边数（如果带权，杂事所有边的权重和）。</li>
<li>简单路径：v到w之间的所有顶点都不同，则称简单路径</li>
<li>回路：起点等于终点的路径</li>
<li>连通图： 图中任意两顶点均连通。</li>
<li>连通分量：无向图的极大连通子图<br>  极大顶点数：再加1个顶点就不连通了。<br>  极大边数：包含子图中所有顶点相连的所有边<br>  <img src="/images/liantongfenliang.png" alt="连通分量"></li>
</ul>
<p>有向图：有强连通和弱连通的概念</p>
<ul>
<li>强连通：有向图中顶点v和w之间存在双向路径，则称v和w是强连通</li>
<li>强连通图：有向图中任意两顶点均强连通</li>
<li>弱连通：去掉有向图中的方向，均连通，叫弱连通</li>
<li>强连通分量：有向图的极大强连通子图    </li>
</ul>
<p><img src="/images/qiangliantong.png" alt="强连通分量"></p>
<p>应用实例：拯救007</p>
<h3 id="最小生成树基本概念"><a href="#最小生成树基本概念" class="headerlink" title="最小生成树基本概念"></a>最小生成树基本概念</h3><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><h3 id="广度优先遍历算法"><a href="#广度优先遍历算法" class="headerlink" title="广度优先遍历算法"></a>广度优先遍历算法</h3><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/13/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/13/linux/" itemprop="url">linux$</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T11:53:26+08:00">
                2019-08-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-13T15:26:27+08:00">
                2019-08-13
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/13/linux/" class="leancloud_visitors" data-flag-title="linux$">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h3><blockquote>
<p>工作中用到的linux命令记录</p>
</blockquote>
<h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><p><strong>盘符切换命令 cd</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /root/Docements # 切换到目录/root/Docements</span><br><span class="line">cd ./path          # 切换到当前目录下的path目录中，“.”表示当前目录  </span><br><span class="line">cd ../path         # 切换到上层目录中的path目录中，“..”表示上一层目录</span><br></pre></td></tr></table></figure>

<p><strong>创建目录 mkdir</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项]... 目录... </span><br><span class="line"> -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask</span><br><span class="line"> -p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; </span><br><span class="line"> -v, --verbose  每次创建新目录都显示信息</span><br></pre></td></tr></table></figure>

<p><strong>删除命令 rm</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</span><br><span class="line">-i ：互动模式，在删除前会询问用户是否操作</span><br><span class="line">-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</span><br><span class="line"></span><br><span class="line">删除文件夹</span><br><span class="line">rm -ir filedir 这个命令需要确认每个文件是否要被删除，文件过多会很繁琐</span><br><span class="line">rm -rf filedir 这个命令会直接删除文件夹，不会给出警告信息和提示</span><br></pre></td></tr></table></figure>

<p><strong>移动命令 mv</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br><span class="line">-i ：若目标文件已经存在，就会询问是否覆盖</span><br><span class="line">-u ：若目标文件已经存在，且比目标文件新，才会更新</span><br></pre></td></tr></table></figure>

<p><strong>复制命令 cp</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a ：将文件的特性一起复制</span><br><span class="line">-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</span><br><span class="line">-r ：递归持续复制，用于目录的复制行为</span><br><span class="line">-u ：目标文件与源文件有差异时才会复制</span><br></pre></td></tr></table></figure>

<p><strong>查看文件夹内容 LS</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来～ </span><br><span class="line">-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录，一起列出来～ </span><br><span class="line">-d ：仅列出目录本身，而不是列出目录内的档案数据 </span><br><span class="line">-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) </span><br><span class="line">-F ：根据档案、目录等信息，给予附加数据结构，例如： </span><br><span class="line">*：代表可执行档； /：代表目录； =：代表 socket 档案； |：代表 FIFO 档案； </span><br><span class="line">-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； </span><br><span class="line">-i ：列出 inode 位置，而非列出档案属性； </span><br><span class="line">-l ：长数据串行出，包含档案的属性等等数据； </span><br><span class="line">-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) </span><br><span class="line">-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； </span><br><span class="line">-R ：连同子目录内容一起列出来； </span><br><span class="line">-S ：以档案容量大小排序！ </span><br><span class="line">-t ：依时间排序 </span><br><span class="line">--color=never ：不要依据档案特性给予颜色显示； </span><br><span class="line">--color=always ：显示颜色 </span><br><span class="line">--color=auto ：让系统自行依据设定来判断是否给予颜色 </span><br><span class="line">--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 </span><br><span class="line">--time=&#123;atime,ctime&#125; ：输出 access 时间或 改变权限属性时间 (ctime) </span><br><span class="line">而非内容变更时间 (modification time)</span><br></pre></td></tr></table></figure>

<p><strong>查看当前工作目录的完整路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd -P # 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径</span><br></pre></td></tr></table></figure>

<p><strong>压缩解压命令 tar</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c ：新建打包文件</span><br><span class="line">-t ：查看打包文件的内容含有哪些文件名</span><br><span class="line">-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</span><br><span class="line">-j ：通过bzip2的支持进行压缩/解压缩</span><br><span class="line">-z ：通过gzip的支持进行压缩/解压缩</span><br><span class="line">-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</span><br><span class="line">-f filename ：filename为要处理的文件</span><br><span class="line">-C dir ：指定压缩/解压缩的目录dir</span><br></pre></td></tr></table></figure>

<p><strong>压缩文件或文件夹为.gz gzip</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> gzip[参数][文件或者目录]</span><br><span class="line">-a or --ascii 　使用ASCII文字模式。 </span><br><span class="line">-c or --stdout or --to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 </span><br><span class="line">-d or --decompress or ----uncompress 　解开压缩文件。 </span><br><span class="line">-f or --force 　强行压缩文件。不理会文件名称 or 硬连接是否存在以及该文件是否为符号连接。 </span><br><span class="line">-h or --help 　在线帮助。 </span><br><span class="line">-l or --list 　列出压缩文件的相关信息。 </span><br><span class="line">-L or --license 　显示版本与版权信息。 </span><br><span class="line">-n or --no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 </span><br><span class="line">-N or --name 　压缩文件时，保存原来的文件名称及时间戳记。 </span><br><span class="line">-q or --quiet 　不显示警告信息。 </span><br><span class="line">-r or --recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </span><br><span class="line">-S&lt;压缩字尾字符串&gt; or ----suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 </span><br><span class="line">-t or --test 　测试压缩文件是否正确无误。 </span><br><span class="line">-v or --verbose 　显示指令执行过程。 </span><br><span class="line">-V or --version 　显示版本信息。 </span><br><span class="line">-num 用指定的数字num调整压缩的速度，-1 or --fast表示最快压缩方法（低压缩比），-9 or --best表示最慢压缩方法（高压缩比）。系统缺省值为6。</span><br></pre></td></tr></table></figure>

<p><strong>远程登录Linux主机 ssh命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-l login_name] [-p port] [user@]hostname</span><br></pre></td></tr></table></figure>

<p><strong>Linux下进行远程拷贝文件的命令 scp命令</strong></p>
<blockquote>
<p>scp secure copy, 与cp命令类似，但是cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [原路径] [目标路径]</span><br><span class="line"></span><br><span class="line">-1 强制scp命令使用协议ssh1 </span><br><span class="line">-2 强制scp命令使用协议ssh2 </span><br><span class="line">-4 强制scp命令只使用IPv4寻址 </span><br><span class="line">-6 强制scp命令只使用IPv6寻址 </span><br><span class="line">-B 使用批处理模式（传输过程中不询问传输口令或短语） </span><br><span class="line">-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） </span><br><span class="line">-p 保留原文件的修改时间，访问时间和访问权限。 </span><br><span class="line">-q 不显示传输进度条。 </span><br><span class="line">-r 递归复制整个目录。 </span><br><span class="line">-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 </span><br><span class="line">-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 </span><br><span class="line">-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 </span><br><span class="line">-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 </span><br><span class="line">-l limit 限定用户所能使用的带宽，以Kbit/s为单位。 </span><br><span class="line">-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， </span><br><span class="line">-P port 注意是大写的P, port是指定数据传输用到的端口号 </span><br><span class="line">-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure>

<p><strong>远程登录操作 telnet命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">telnet[参数][主机]</span><br><span class="line"></span><br><span class="line">-8 允许使用8位字符资料，包括输入与输出。</span><br><span class="line">-a 尝试自动登入远端系统。</span><br><span class="line">-b&lt;主机别名&gt; 使用别名指定远端主机名称。</span><br><span class="line">-c 不读取用户专属目录里的.telnetrc文件。</span><br><span class="line">-d 启动排错模式。</span><br><span class="line">-e&lt;脱离字符&gt; 设置脱离字符。</span><br><span class="line">-E 滤除脱离字符。</span><br><span class="line">-f 此参数的效果和指定&quot;-F&quot;参数相同。</span><br><span class="line">-F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</span><br><span class="line">-k&lt;域名&gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</span><br><span class="line">-K 不自动登入远端主机。</span><br><span class="line">-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</span><br><span class="line">-L 允许输出8位字符资料。</span><br><span class="line">-n&lt;记录文件&gt; 指定文件记录相关信息。</span><br><span class="line">-r 使用类似rlogin指令的用户界面。</span><br><span class="line">-S&lt;服务类型&gt; 设置telnet连线所需的IP TOS信息。</span><br><span class="line">-x 假设主机有支持数据加密的功能，就使用它。</span><br><span class="line">-X&lt;认证形态&gt; 关闭指定的认证形态。</span><br></pre></td></tr></table></figure>

<p><strong>远程下载命令 wget命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">wget [参数] [URL地址]</span><br><span class="line"></span><br><span class="line">启动参数：</span><br><span class="line">-V, –version 显示wget的版本后退出</span><br><span class="line">-h, –help 打印语法帮助</span><br><span class="line">-b, –background 启动后转入后台执行</span><br><span class="line">-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc</span><br><span class="line"></span><br><span class="line">记录和输入文件参数：</span><br><span class="line">-o, –output-file=FILE 把记录写到FILE文件中</span><br><span class="line">-a, –append-output=FILE 把记录追加到FILE文件中</span><br><span class="line">-d, –debug 打印调试输出</span><br><span class="line">-q, –quiet 安静模式(没有输出)</span><br><span class="line">-v, –verbose 冗长模式(这是缺省设置)</span><br><span class="line">-nv, –non-verbose 关掉冗长模式，但不是安静模式</span><br><span class="line">-i, –input-file=FILE 下载在FILE文件中出现的URLs</span><br><span class="line">-F, –force-html 把输入文件当作HTML格式文件对待</span><br><span class="line">-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀</span><br><span class="line">–sslcertfile=FILE 可选客户端证书</span><br><span class="line">–sslcertkey=KEYFILE 可选客户端证书的KEYFILE</span><br><span class="line">–egd-file=FILE 指定EGD socket的文件名</span><br><span class="line"></span><br><span class="line">下载参数：</span><br><span class="line">–bind-address=ADDRESS 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)</span><br><span class="line">-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).</span><br><span class="line">-O –output-document=FILE 把文档写到FILE文件中</span><br><span class="line">-nc, –no-clobber 不要覆盖存在的文件或使用.#前缀</span><br><span class="line">-c, –continue 接着下载没下载完的文件</span><br><span class="line">–progress=TYPE 设定进程条标记</span><br><span class="line">-N, –timestamping 不要重新下载文件除非比本地文件新</span><br><span class="line">-S, –server-response 打印服务器的回应</span><br><span class="line">–spider 不下载任何东西</span><br><span class="line">-T, –timeout=SECONDS 设定响应超时的秒数</span><br><span class="line">-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒</span><br><span class="line">–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒</span><br><span class="line">–random-wait 在下载之间等待0…2*WAIT秒</span><br><span class="line">-Y, –proxy=on/off 打开或关闭代理</span><br><span class="line">-Q, –quota=NUMBER 设置下载的容量限制</span><br><span class="line">–limit-rate=RATE 限定下载输率</span><br><span class="line"></span><br><span class="line">目录参数：</span><br><span class="line">-nd –no-directories 不创建目录</span><br><span class="line">-x, –force-directories 强制创建目录</span><br><span class="line">-nH, –no-host-directories 不创建主机目录</span><br><span class="line">-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…</span><br><span class="line">–cut-dirs=NUMBER 忽略 NUMBER层远程目录</span><br><span class="line"></span><br><span class="line">HTTP 选项参数：</span><br><span class="line">–http-user=USER 设定HTTP用户名为 USER.</span><br><span class="line">–http-passwd=PASS 设定http密码为 PASS</span><br><span class="line">-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)</span><br><span class="line">-E, –html-extension 将所有text/html文档以.html扩展名保存</span><br><span class="line">–ignore-length 忽略 `Content-Length’头域</span><br><span class="line">–header=STRING 在headers中插入字符串 STRING</span><br><span class="line">–proxy-user=USER 设定代理的用户名为 USER</span><br><span class="line">–proxy-passwd=PASS 设定代理的密码为 PASS</span><br><span class="line">–referer=URL 在HTTP请求中包含 `Referer: URL’头</span><br><span class="line">-s, –save-headers 保存HTTP头到文件</span><br><span class="line">-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION</span><br><span class="line">–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)</span><br><span class="line">–cookies=off 不使用 cookies</span><br><span class="line">–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie</span><br><span class="line">–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中</span><br><span class="line"></span><br><span class="line">FTP 选项参数：</span><br><span class="line">-nr, –dont-remove-listing 不移走 `.listing’文件</span><br><span class="line">-g, –glob=on/off 打开或关闭文件名的 globbing机制</span><br><span class="line">–passive-ftp 使用被动传输模式 (缺省值).</span><br><span class="line">–active-ftp 使用主动传输模式</span><br><span class="line">–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)</span><br><span class="line"></span><br><span class="line">递归下载参数：</span><br><span class="line">-r, –recursive 递归下载－－慎用!</span><br><span class="line">-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)</span><br><span class="line">–delete-after 在现在完毕后局部删除文件</span><br><span class="line">-k, –convert-links 转换非相对链接为相对链接</span><br><span class="line">-K, –backup-converted 在转换文件X之前，将之备份为 X.orig</span><br><span class="line">-m, –mirror 等价于 -r -N -l inf -nr</span><br><span class="line">-p, –page-requisites 下载显示HTML文件的所有图片</span><br><span class="line"></span><br><span class="line">递归下载中的包含和不包含(accept/reject)：</span><br><span class="line">-A, –accept=LIST 分号分隔的被接受扩展名的列表</span><br><span class="line">-R, –reject=LIST 分号分隔的不被接受的扩展名的列表</span><br><span class="line">-D, –domains=LIST 分号分隔的被接受域的列表</span><br><span class="line">–exclude-domains=LIST 分号分隔的不被接受的域的列表</span><br><span class="line">–follow-ftp 跟踪HTML文档中的FTP链接</span><br><span class="line">–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表</span><br><span class="line">-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表</span><br><span class="line">-H, –span-hosts 当递归时转到外部主机</span><br><span class="line">-L, –relative 仅仅跟踪相对链接</span><br><span class="line">-I, –include-directories=LIST 允许目录的列表</span><br><span class="line">-X, –exclude-directories=LIST 不被包含目录的列表</span><br><span class="line">-np, –no-parent 不要追溯到父目录</span><br><span class="line">wget -S –spider url 不下载只显示过程</span><br></pre></td></tr></table></figure>

<p><strong>查看和配置网络设备 ifconfig命令</strong></p>
<blockquote>
<p>当网络环境发生变化可通过此命令对网络进行相应的配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网络设备] [参数]</span><br><span class="line"></span><br><span class="line">up 启动指定网络设备/网卡。</span><br><span class="line">down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。</span><br><span class="line">arp 设置指定网卡是否支持ARP协议。</span><br><span class="line">-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包</span><br><span class="line">-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包</span><br><span class="line">-a 显示全部接口信息</span><br><span class="line">-s 显示摘要信息（类似于 netstat -i）</span><br><span class="line">add 给指定网卡配置IPv6地址</span><br><span class="line">del 删除指定网卡的IPv6地址</span><br><span class="line">&lt;硬件地址&gt; 配置网卡最大的传输单元</span><br><span class="line">mtu&lt;字节数&gt; 设置网卡的最大传输单元 (bytes)</span><br><span class="line">netmask&lt;子网掩码&gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。</span><br><span class="line">tunel 建立隧道</span><br><span class="line">dstaddr 设定一个远端地址，建立点对点通信</span><br><span class="line">-broadcast&lt;地址&gt; 为指定网卡设置广播协议</span><br><span class="line">-pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议</span><br><span class="line">multicast 为网卡设置组播标志</span><br><span class="line">address 为网卡设置IPv4地址</span><br><span class="line">txqueuelen&lt;长度&gt; 为网卡设置传输列队的长度</span><br></pre></td></tr></table></figure>

<h2 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h2><p><strong>chmod</strong></p>
<p><strong>使用vi编辑器的命令 vi/vim命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /var/log/aa.log # 打开 /var/log/aa.log文件并编辑</span><br></pre></td></tr></table></figure>

<p><strong>连接文件或标准输入并打印 cat命令</strong></p>
<blockquote>
<p>这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] [文件]...</span><br><span class="line">-A, --show-all           等价于 -vET</span><br><span class="line">-b, --number-nonblank    对非空输出行编号</span><br><span class="line">-e                       等价于 -vE</span><br><span class="line">-E, --show-ends          在每行结束处显示 $</span><br><span class="line">-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号</span><br><span class="line">-s, --squeeze-blank  有连续两行以上的空白行，就代换</span><br></pre></td></tr></table></figure>

<p><strong>查看文件内容 more命令</strong></p>
<blockquote>
<p>more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页查看文件的内容，还支持直接条转行等功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] </span><br><span class="line">命令参数：</span><br><span class="line">+n 从笫n行开始显示</span><br><span class="line">-n 定义屏幕大小为n行</span><br><span class="line">+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 </span><br><span class="line">-c 从顶部清屏，然后显示</span><br><span class="line">-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class="line">-l 忽略Ctrl+l（换页）字符</span><br><span class="line">-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class="line">-s 把连续的多个空行显示为一行</span><br><span class="line">-u 把文件内容中的下画线去掉</span><br><span class="line">常用操作命令：</span><br><span class="line">Enter 向下n行，需要定义。默认为1行</span><br><span class="line">Ctrl+F 向下滚动一屏</span><br><span class="line">空格键 向下滚动一屏</span><br><span class="line">Ctrl+B 返回上一屏</span><br><span class="line">= 输出当前行的行号</span><br><span class="line">：f 输出文件名和当前行的行号</span><br><span class="line">V 调用vi编辑器</span><br><span class="line">!命令 调用Shell，并执行命令 </span><br><span class="line">q 退出more</span><br></pre></td></tr></table></figure>

<p><strong>查看文件内容 less命令</strong></p>
<blockquote>
<p>命令用法比起more更加的有弹性，在more的时候，我们并没有办法向前面翻，只能往后看，但是使用less时，就可以使用【pageup】【pagedown】等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容，除此之外less还有更多的搜索功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">less [参数]  文件 </span><br><span class="line">-b &lt;缓冲区大小&gt; 设置缓冲区的大小</span><br><span class="line">-e 当文件显示结束后，自动离开</span><br><span class="line">-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</span><br><span class="line">-g 只标志最后搜索的关键词</span><br><span class="line">-i 忽略搜索时的大小写</span><br><span class="line">-m 显示类似more命令的百分比</span><br><span class="line">-N 显示每行的行号</span><br><span class="line">-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">-Q 不使用警告音</span><br><span class="line">-s 显示连续空行为一行</span><br><span class="line">-S 行过长时间将超出部分舍弃</span><br><span class="line">-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">/字符串：向下搜索“字符串”的功能</span><br><span class="line">?字符串：向上搜索“字符串”的功能</span><br><span class="line">n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">b 向后翻一页</span><br><span class="line">d 向后翻半页</span><br><span class="line">h 显示帮助界面</span><br><span class="line">Q 退出less 命令</span><br><span class="line">u 向前滚动半页</span><br><span class="line">y 向前滚动一行</span><br><span class="line">空格键 滚动一行</span><br><span class="line">回车键 滚动一页</span><br><span class="line">[pagedown]： 向下翻动一页</span><br><span class="line">[pageup]： 向上翻动一页</span><br></pre></td></tr></table></figure>

<p><strong>从指定点开始将文件写到标准输出 tail命令</strong></p>
<blockquote>
<p>从指定点开始将文件写到标准输出，使用tail命令的-f选项可以方便的查阅正在改变的日志文件，tail -f filename会把filename里最尾部的内容显示在屏幕上，并且不断刷新最新的文件内容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tail[必要参数][选择参数][文件] </span><br><span class="line"></span><br><span class="line">-f 循环读取</span><br><span class="line">-q 不显示处理信息</span><br><span class="line">-v 显示详细的处理信息</span><br><span class="line">-c&lt;数目&gt; 显示的字节数</span><br><span class="line">-n&lt;行数&gt; 显示行数</span><br><span class="line">--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. </span><br><span class="line">-q, --quiet, --silent 从不输出给出文件名的首部 </span><br><span class="line">-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</span><br></pre></td></tr></table></figure>

<p><strong>用于比较两个文件或目录的不同 diff</strong></p>
<blockquote>
<p>diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效，以逐行的方式，比较文本文件的异同处，如果指定比较的是目录的时候，diff命令会比较两个目录下名字相同的文本文件，列出不同的二进制文件、公共子目录和只在一个目录出现的文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">diff[参数][文件1或目录1][文件2或目录2]</span><br><span class="line"></span><br><span class="line"># diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的</span><br><span class="line"># 文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</span><br><span class="line"></span><br><span class="line">-a or --text 　#diff预设只会逐行比较文本文件。</span><br><span class="line">-b or --ignore-space-change 　#不检查空格字符的不同。</span><br><span class="line">-B or --ignore-blank-lines 　#不检查空白行。</span><br><span class="line">-c 　#显示全部内文，并标出不同之处。</span><br><span class="line">-C or --context 　#与执行&quot;-c-&quot;指令相同。</span><br><span class="line">-d or --minimal 　#使用不同的演算法，以较小的单位来做比较。</span><br><span class="line">-D or ifdef 　#此参数的输出格式可用于前置处理器巨集。</span><br><span class="line">-e or --ed 　#此参数的输出格式可用于ed的script文件。</span><br><span class="line">-f or -forward-ed 　#输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span><br><span class="line">-H or --speed-large-files 　#比较大文件时，可加快速度。</span><br><span class="line">-l or --ignore-matching-lines 　#若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符 or 字符串，则不显示这两个文件的差异。</span><br><span class="line">-i or --ignore-case 　#不检查大小写的不同。</span><br><span class="line">-l or --paginate 　#将结果交由pr程序来分页。</span><br><span class="line">-n or --rcs 　#将比较结果以RCS的格式来显示。</span><br><span class="line">-N or --new-file 　#在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span><br><span class="line">-p 　#若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span><br><span class="line">-P or --unidirectional-new-file 　#与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span><br><span class="line">-q or --brief 　#仅显示有无差异，不显示详细的信息。</span><br><span class="line">-r or --recursive 　#比较子目录中的文件。</span><br><span class="line">-s or --report-identical-files 　#若没有发现任何差异，仍然显示信息。</span><br><span class="line">-S or --starting-file 　#在比较目录时，从指定的文件开始比较。</span><br><span class="line">-t or --expand-tabs 　#在输出时，将tab字符展开。</span><br><span class="line">-T or --initial-tab 　#在每行前面加上tab字符以便对齐。</span><br><span class="line">-u,-U or --unified= 　#以合并的方式来显示文件内容的不同。</span><br><span class="line">-v or --version 　#显示版本信息。</span><br><span class="line">-w or --ignore-all-space 　#忽略全部的空格字符。</span><br><span class="line">-W or --width 　#在使用-y参数时，指定栏宽。</span><br><span class="line">-x or --exclude 　#不比较选项中所指定的文件 or 目录。</span><br><span class="line">-X or --exclude-from 　#您可以将文件 or 目录类型存成文本文件，然后在=中指定此文本文件。</span><br><span class="line">-y or --side-by-side 　#以并列的方式显示文件的异同之处。</span><br></pre></td></tr></table></figure>

<p><strong>确定主机与外部链接状态 ping命令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ping [参数] [主机名或IP地址]</span><br><span class="line">-d 使用Socket的SO_DEBUG功能。</span><br><span class="line">-f  极限检测。大量且快速地送网络封包给一台机器，看它的回应。</span><br><span class="line">-n 只输出数值。</span><br><span class="line">-q 不显示任何传送封包的信息，只显示最后的结果。</span><br><span class="line">-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。</span><br><span class="line">-R 记录路由过程。</span><br><span class="line">-v 详细显示指令的执行过程。</span><br><span class="line">&lt;p&gt;-c 数目：在发送指定数目的包后停止。</span><br><span class="line">-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。</span><br><span class="line">-I 网络界面：使用指定的网络界面送出数据包。</span><br><span class="line">-l 前置载入：设置在送出要求信息之前，先行发出的数据包。</span><br><span class="line">-p 范本样式：设置填满数据包的范本样式。</span><br><span class="line">-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。</span><br><span class="line">-t 存活数值：设置存活数值TTL的大小。</span><br></pre></td></tr></table></figure>

<p><strong>为某一个文件在另一个位置建立一个同步的链接</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</span><br><span class="line"></span><br><span class="line">软链接：</span><br><span class="line">1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</span><br><span class="line">2.软链接可以 跨文件系统 ，硬链接不可以</span><br><span class="line">3.软链接可以对一个不存在的文件名进行链接</span><br><span class="line">4.软链接可以对目录进行链接</span><br><span class="line"></span><br><span class="line">硬链接:</span><br><span class="line">1.硬链接，以文件副本的形式存在。但不占用实际空间。</span><br><span class="line">2.不允许给目录创建硬链接</span><br><span class="line">3.硬链接只有在同一个文件系统中才能创建</span><br><span class="line"></span><br><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br><span class="line"></span><br><span class="line">必要参数:</span><br><span class="line">-b 删除，覆盖以前建立的链接</span><br><span class="line">-d 允许超级用户制作目录的硬链接</span><br><span class="line">-f 强制执行</span><br><span class="line">-i 交互模式，文件存在则提示用户是否覆盖</span><br><span class="line">-n 把符号链接视为一般目录</span><br><span class="line">-s 软链接(符号链接)</span><br><span class="line">-v 显示详细的处理过程</span><br><span class="line"></span><br><span class="line">选择参数:</span><br><span class="line">-S “-S&lt;字尾备份字符串&gt; ”或 “--suffix=&lt;字尾备份字符串&gt;”</span><br><span class="line">-V “-V&lt;备份方式&gt;”或“--version-control=&lt;备份方式&gt;”</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/pm2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/pm2/" itemprop="url">pm2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T17:00:25+08:00">
                2019-08-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-15T14:12:50+08:00">
                2019-08-15
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/12/pm2/" class="leancloud_visitors" data-flag-title="pm2">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  440
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>pm2 安装为root用户安装，现切换为普通user用户使用pm2报错，正在解决：<br>解决方案一：SUDO，赋予普通用户临时root权限，并限制监控user操作，实现服务的可控。<br>SUDO（substitude user do）使得系统管理员可以授权特定用户或用户组作为临时root执行命令，同时还能对命令及其参数提供审核跟踪。可以针对单个命令、仅在需要时授予临时权限，减少因为执行错误命令损坏系统，sudo也能以其他用户身份执行命令并且记录用户执行的命令，以及失败的权限申请。<br>手册参考：[ps:全英文]<br><a href="https://gratisoft.us/sudo/man.html" target="_blank" rel="noopener">https://gratisoft.us/sudo/man.html</a><br><a href="https://gratisoft.us/sudo/man/1.8.6/sudoers.man.html" target="_blank" rel="noopener">https://gratisoft.us/sudo/man/1.8.6/sudoers.man.html</a></p>
</blockquote>
<p><a href="https://wiki.archlinux.org/index.php/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Sudo_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p>
<p>pm2 非root用户权限设置</p>
<h3 id="检查状态-日志-指标"><a href="#检查状态-日志-指标" class="headerlink" title="检查状态 日志 指标"></a>检查状态 日志 指标</h3><p><strong>列出托管应用程序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 [list|ls|status]</span><br></pre></td></tr></table></figure>

<p><strong>显示日志</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">显示实时日志：</span><br><span class="line">pm2 logs</span><br><span class="line">显示就日志：</span><br><span class="line">pm2 logs --lines 200</span><br><span class="line">基于终端仪表盘：</span><br><span class="line">pm2 monit</span><br></pre></td></tr></table></figure>

<p><strong>管理应用程序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pm2 restart app</span><br><span class="line">pm2 reload app</span><br><span class="line">pm2 stop app</span><br><span class="line">pm2 delete app</span><br></pre></td></tr></table></figure>

<p><strong>集群模式</strong></p>
<blockquote>
<p>对于node.js应用程序，PM2包括一个自动负载均衡器，它将共享每个进程这件的所有http[s]/websocket/tcp/udp连接</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">要以集群模式启动应用程序:</span><br><span class="line">pm2 start app.js -i max</span><br></pre></td></tr></table></figure>

<p><strong>用户不在sudoers文件中的解决方法</strong><br>1、查看/etc/sudoers文件权限，如果为只读权限，修改为可写权限<br>ls -l /etc/sudoers</p>
<p>2、修改sudoers文件的权限不只是只读<br>chmod 777 /etc/sudoers</p>
<p>3、编辑sudoers文件，添加user用户为所有可执行权限</p>
<p>4、修改回sudoers权限为440<br>chmod 440 sudoers</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/docker/" itemprop="url">docker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T16:24:30+08:00">
                2019-08-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-12T16:24:30+08:00">
                2019-08-12
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/12/docker/" class="leancloud_visitors" data-flag-title="docker">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/redis_memcached/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/redis_memcached/" itemprop="url">redis memcached</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T11:21:11+08:00">
                2019-08-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-12T14:46:31+08:00">
                2019-08-12
              </time>
            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/12/redis_memcached/" class="leancloud_visitors" data-flag-title="redis memcached">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  603
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>项目里有用到memcached ，想对比Redis看一下，这里的区别，以及这两个服务的应用场景是什么。</p>
</blockquote>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote>
<p>Redis是一个开源使用ANSIC语言编写，遵循BSD协议，支持网络，可基于内存亦可持久化的日志型，Key-Value数据库，并提供多种语言的API<br>它通常被称为数据结构服务器，因为值（value）可以是字符串（String），哈希（Map），列表（list），集合（sets）和有序集合（stored sets）等类型。</p>
</blockquote>
<p>Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p>Redis与其他key-value缓存产品有一下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，<strong>重启的时候可以再次加载进行使用</strong>。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供了list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<p>Redis 优势：<br>性能极高- Redis能读的速度是110000次/s，写的速度是81000次/s.<br>丰富的数据类型 - Redis支持二进制案例的，Strings，lists，Hashes，Sets及Ordered Sets数据类型操作。<br>原子 - Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。<br>丰富的特性 - Redis还支持publish/subscribe，通知，key过期等等特性。</p>
<p>Redis与其他Key-value存储有什么不同</p>
<pre><code>Redis有这更为复杂的数据结构，并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径，Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。

Redis运行在内存中，但是可以持久化到磁盘，所以对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存，在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</code></pre><h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/06/Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KOKI HOO">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/bekjae.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KOKI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/06/Tree/" itemprop="url">Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-06T15:36:01+08:00">
                2019-08-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-15T17:50:46+08:00">
                2019-08-15
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DATA-STRUCTURE/" itemprop="url" rel="index">
                    <span itemprop="name">DATA STRUCTURE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/06/Tree/" class="leancloud_visitors" data-flag-title="Tree">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote>
<p>内容：<br>    - 1.树的基本概念和术语<br>    - 2.树的前序、中序、后序、层次序遍历<br>    - 3.二叉树及其性质<br>    - 4.普通树与二叉树的转换<br>    - 5.树的存储结构，标准形式<br>    - 6.完全树(complete tree)的数组形式存储<br>    - 7.树的应用<br>    - 8.Huffman树的定义与应用</p>
</blockquote>
<hr>
<h3 id="1-树的基本概念和术语"><a href="#1-树的基本概念和术语" class="headerlink" title="1.树的基本概念和术语"></a>1.树的基本概念和术语</h3><pre><code>树是n(n&gt;0)个结点的有限集合T。在一颗树中满足如下两个条件：
(1) 有且仅有一个称做根的结点
(2) 其余的结点可分为m(m&gt;=0)棵互不相交的有限集合T1,T2,……, Tm,其中每个集合又都是一个树，并称其为根的子树

因此，树的定义是递归的，树是一种递归数据结构。树的这种定义为树的递归处理带来了很大的方便。</code></pre><p><strong>结点的度</strong>：树中每个结点具有的子树数或者后续结点数称为该结点的度。<br><strong>树的度</strong>：树中所有结点的度的最大值称之为树的度。度为m的树称为m次树。<br><strong>分支结点</strong>：度大于0的结点称为分支结点或非终端结点。<br><strong>叶子结点</strong>：度为0的结点称为叶子结点或终端结点。<br><strong>孩子结点</strong>：一个结点的后续称之为该结点的孩子结点。<br><strong>双亲结点</strong>：一个结点称为其后继结点的双亲结点。<br><strong>子孙结点</strong>：一个结点的所有子树中的结点称之为该结点的子孙结点。<br><strong>祖先结点</strong>：从树根结点到达一个结点的路径上所通过的所有结点称为该结点的祖先结点。<br><strong>兄弟结点</strong>：具有同一父亲的结点互相称之为兄弟结点。<br><strong>结点的层数</strong>：树具有一种层次结构，根结点为第一层，其孩子结点为第二层，如此类推到每个结点的层数。<br><strong>树的深度</strong>：树中结点的最大层数称为树的深度或高度。<br><strong>森林</strong>：0个或多个不相交的树的集合称为森林。</p>
<h3 id="2-树的前序、中序、后序、层次序遍历"><a href="#2-树的前序、中序、后序、层次序遍历" class="headerlink" title="2.树的前序、中序、后序、层次序遍历"></a>2.树的前序、中序、后序、层次序遍历</h3><blockquote>
<p>一般讨论二叉树对的遍历，这里的运算均假设二叉树是采用链式存储方式存储的。</p>
</blockquote>
<h4 id="2-1-先序遍历"><a href="#2-1-先序遍历" class="headerlink" title="2.1 先序遍历"></a>2.1 先序遍历</h4><blockquote>
<p>按照先访问跟结点，在访问左子树，最后访问右子树的次序访问二叉树中所有结点，且每个结点仅访问一次，其递归算法如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void preorder(BTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    if（p!==NULL）</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;, p-&gt;data); // 访问根结点数据</span><br><span class="line">        preorder（p-&gt;lchild); // 访问左子树</span><br><span class="line">        preorder（p-&gt;rchild; // 访问右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：<br><img src="/images/xcbliEX.png" alt="先序遍历示例"></p>
<h4 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2 中序遍历"></a>2.2 中序遍历</h4><blockquote>
<p>按照先访问左子树，再访问跟根节点，最后访问右子树的次序访问二叉树中所有结点，且每个结点仅访问一次，其递归算法如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void inorder（BTree *p）</span><br><span class="line">&#123;</span><br><span class="line">    if(p!==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder(p-&gt;lchild);//访问左子树</span><br><span class="line">        printf(&quot;%c&quot;, p-&gt;data);// 访问根结点</span><br><span class="line">        inorder(p-&gt;rchild); // 访问右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：中序遍历只有对二叉树才有意义<br><img src="/images/xcbliEX.png" alt="中序遍历示例"></p>
<h4 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3 后序遍历"></a>2.3 后序遍历</h4><p>按照先访问左子树，再访问右子树，最后访问根结点的次序访问二叉树中所有的结点，且每个结点只访问一次，其递归算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void postorder(BTree *p)</span><br><span class="line">&#123;</span><br><span class="line">    if(p!==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        postorder(p-&gt;lchild); // 访问左子树</span><br><span class="line">        postorder(p-&gt;rchild); // 访问右子树</span><br><span class="line">        printf(&quot;%c&quot;, p-&gt;data); // 访问跟结点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：<br><img src="/images/hxblEX.png" alt="后序遍历示例"></p>
<h4 id="2-4-层次序遍历"><a href="#2-4-层次序遍历" class="headerlink" title="2.4 层次序遍历"></a>2.4 层次序遍历</h4><p>层次遍历需要建立一个循环队列，先将二叉树头结点入队，然后出队列，访问该结点，如果有左子树，则将左子树的根结点入队，如果有右子树，则将右子树的根结点入队，然后出队列，对出队列结点访问，如此反复，一直到队列为空为止。<br>算法如下：容我研究好好看一下先，哈哈哈哈哈</p>
<p><img src="/images/ccblEX.png" alt="层次序遍历示例"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-二叉树及其性质"><a href="#3-二叉树及其性质" class="headerlink" title="3.二叉树及其性质"></a>3.二叉树及其性质</h3><pre><code>3.1 二叉树的几个基本术语
二叉树：二叉树由结点的有限集合构成，这个有限集合或者为空集，或者是由一个根结点及两颗不相交的分别称之为左子树和右子树的二叉树组成。二叉树是一种特殊的树。
满二叉树：在一颗二叉树中，若第i层的结点数为2&lt;sub&gt;i&lt;/sub&gt;-1时，则称此层的结点树是满的，则此二叉树称之为满二叉树。
完全二叉树：在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干个结点，则此二叉树称之为完全二叉树。

3.2 二叉树的性质
    1. 非空二叉树上叶子结点等于双分支结点数加1
    2. 非空二叉树上第i层上至多有2&lt;sup&gt;i&lt;/sup&gt;-1个结点（i&gt;=1）
    3. 高度为h的二叉树至多有2&lt;sup&gt;h&lt;/sup&gt;-1个结点（h&gt;=1）
    4. 对完全二叉树中编号为i的结点（i&lt;=i&lt;=n, n&gt;=1,n为结点数）有：这个结论有点复杂
        （1）若i&lt;=【n/2】，即2i&lt;=n，则编号为i的结点为分支结点，否则为叶子结点。
        （2）若n为奇数，则每个分支结点都既有左孩子，也有右孩子；若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有
        （3）若编号为i的结点有左孩子，则左孩子结点的编号为2i；若编号为i的结点有右孩子，则右孩子结点的编号为（2i+1）
        （4）除树根结点外，若一个结点的编号为i，则它的双亲结点的编号为i/2，也就是说，当i为偶数时，其双亲结点的编号为i/2它是双亲结点的左孩子，当i为奇数时，其双亲结点的编号为（i-1）/2，它是双亲结点的右结点。
    5. 具有n个（n&gt;0）结点的完全二叉树的高度为【log&lt;sub&gt;2&lt;/sub&gt;(n+1)】或 【log&lt;sub&gt;2&lt;/sub&gt;n】+ 1;</code></pre><h3 id="4-普通树与二叉树的转换"><a href="#4-普通树与二叉树的转换" class="headerlink" title="4.普通树与二叉树的转换"></a>4.普通树与二叉树的转换</h3><h4 id="树转换成二叉树"><a href="#树转换成二叉树" class="headerlink" title="树转换成二叉树"></a>树转换成二叉树</h4><p>树转换成二叉树的过程如下：<br>    1) 将同一结点的各孩子结点用线串起来<br>    2) 将每个结点的分支从左到右除了第一个外，其余都剪掉：<br><img src="/images/treeToBtree.png" alt="树转换成二叉树"></p>
<h4 id="二叉树转换成树"><a href="#二叉树转换成树" class="headerlink" title="二叉树转换成树"></a>二叉树转换成树</h4><p>二叉树转换为树是树转换为二叉树的逆过程,其步骤为：<br>    1) 若某结点的左孩子结点存在，将左孩子结点的右孩子结点，右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；<br>    2) 删除原二叉树中所有结点与其右孩子结点的连线<br>    3) 整理（1）和（2）两步得到的树，使之结构层次分明<br><img src="/images/BNTreeToTree.png" alt="二叉树转换成树"></p>
<h4 id="森林转换成二叉树"><a href="#森林转换成二叉树" class="headerlink" title="森林转换成二叉树"></a>森林转换成二叉树</h4><p>森林是由若干棵树组成，可以将森林中的每棵树的根结点看做是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换成二叉树。</p>
<p>将森林转换为二叉树的步骤是：<br>    1）先把每颗树转换为二叉树<br>    2）第一棵二叉树的不动，从第二棵二叉树开始，依次把后一颗二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来，当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树</p>
<h4 id="二叉树转换成森林"><a href="#二叉树转换成森林" class="headerlink" title="二叉树转换成森林"></a>二叉树转换成森林</h4><h3 id="5-树的存储结构，标准形式"><a href="#5-树的存储结构，标准形式" class="headerlink" title="5.树的存储结构，标准形式"></a>5.树的存储结构，标准形式</h3><blockquote>
<p>树有顺序存储和链式存储等存储方法：<br>（1）顺序存储<br>    用数组存放所有树中结点，每个元素除包含结点值外，还有一个指向双亲结点下标的为指针<br>（2）链式存储<br>    在链式存储中，每个结点除存储结点值外，还包含若干哥指针域，在孩子链存储结构中，每个孩子结点都对应一个指针域；在孩子兄弟链存储结构中，每个结点含两个指针域，一个指向其最左边的孩子结点，一个指向其兄弟结点。</p>
</blockquote>
<blockquote>
<p>主要为二叉树的存储结构，二叉树有顺序存储、链式存储和线索树存储等几种存储方法。</p>
</blockquote>
<pre><code>（1）顺序存储
    顺序存储一颗二叉树，首先对该树中每个结点进行编号，然后以各结点的编号为下标，把各结点的值对应存储到一维数组中。树中各结点的编号与等深度的完全二叉树中对应位置上结点的的编号相同。

 编号过程为：首先把树根结点的编号定为1，然后按照层次从上到下，每层从左到右的顺序，对每一个结点进行编号，当它的双亲结点的编号为i时，若它为左孩子，则编号为2i；若为右孩子，则编号为2i+1.</code></pre><p><img src="/images/btree_sxcc.jpg" alt="二叉树顺序存储"><br>    （2）链式存储<br>        在二叉树的链式存储中，通常采用的方法是：每个结点中设置三个域，即值域、左指针域、右指针域。结点的结构如下：<br>        lchild | data |  rchild<br>        其中data为值域，用于存放入结点的数据元素，lchild和rchild分别表示左指针和右指针，用以分别存储左孩子和右孩子结点（即左右子树的跟结点）的存储位置（即指针）</p>
<p>链式存储的指针类型与结点的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bnodes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    syruct bnode *lchild,*rchild</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的ElemType可以是任何相应的数据类型如int、float或char等，在算法中，我们规定ElemType默认是int类型。链式存储方法存在大量的空指针，浪费存储空间，但二叉树的运算算法实现比较简单直观。</p>
<p><img src="/images/btree_lscc.jpg" alt="二叉树链式存储"></p>
<pre><code>（3）线索树存储
链式存储中无左子树或右子树的结点的lchild域或rchild域为空，这样浪费了存储空间（当一颗二叉树有n个结点，便有n+1个指针域为NULL，因为n个结点一共有2n个指针域，除根结点外，每个结点有且仅有一个指向它的指针，于是共有n-1个指针，即只有n-1个指针域被有效利用），因此，可以把每个空着的lchild或rchild域用于分别指向某种遍历次序的前驱结点和后继结点，这样在遍历这种二叉树时，可由此信息直接找到遍历次序下的前驱结点或后继结点的指针叫做线索，其中空的左指针域中存放的指向其前驱结点的指针叫做左线索，在空的右指针域中存放的指向其后续结点的指针叫做右线索。对一颗二叉树中的所有结点的空指针域按照某种遍历次序加线索的过程叫做线索化，被线索化了的二叉树称作线索二叉树。</code></pre><p><img src="/images/btree_sscc.jpg" alt="中序线索二叉树"><br>在一个线索二叉树中，为了区别每个结点的左、右指针域存放的是孩子指针，还是线索，必须在结点结构中增加两个线索标志域，即左线索标志域，用Itag表示，另一个是右线索标志域，用rtag表示，ltag和rtag只需取两种值，以区别其对应的指针域保存的是孩子指针还是线索。假定取0和1两种值，并定义如下：<br>ltag：<br>    =0 left域指向结点的左孩子<br>    =1 left域指向结点的某种遍历次序下的前驱（左线索）<br>rtag：<br>    =0 right域指向结点的右孩子<br>    =1 right域指向结点的某种遍历次序下的后序（右线索）</p>
<p>增加下线索标志域后的结点结构为：<br>    lchild|ltag|data|rtag|rchild<br>这种结点类型和相应结点的指针类型定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef  struct tnode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    int ltag,rtag;</span><br><span class="line">    struct tnode *lchild, *rchild;  // 这里的ltag和rtag只能取值0或1</span><br><span class="line">&#125;TBTree;</span><br></pre></td></tr></table></figure>

<p>对一种二叉树进行中序线索化的算法思想是：一边中序遍历一边建立线索。若访问的结点的左孩子为空，则建立前驱线索，若右孩子为空，则建立后续线索，其函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void inthread(p, pre)</span><br><span class="line">TBtree *p, *pre;</span><br><span class="line">// p为当前结点，pre为p的前驱结点，开始调用时p为根结点指针，pre为NULL</span><br><span class="line">&#123;</span><br><span class="line">    if(p!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        inthread(p-&gt;lchild, pre); // 左子树线索化</span><br><span class="line">        // 若当前结点的左子树为空，则建立指向其前驱结点的前驱线索</span><br><span class="line">        if（p-&gt;lchild==NULL）</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;ltag=1;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            p-&gt;ltag = 0;</span><br><span class="line">        pre = p; //中序向前遍历一个结点</span><br><span class="line">        inthread(th-&gt;rchild, pre); // 递归调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-完全树-complete-tree-的数组形式存储"><a href="#6-完全树-complete-tree-的数组形式存储" class="headerlink" title="6.完全树(complete tree)的数组形式存储"></a>6.完全树(complete tree)的数组形式存储</h3><h3 id="7-树的应用"><a href="#7-树的应用" class="headerlink" title="7.树的应用"></a>7.树的应用</h3><h3 id="8-Huffman树的定义与应用"><a href="#8-Huffman树的定义与应用" class="headerlink" title="8 .Huffman树的定义与应用"></a>8 .Huffman树的定义与应用</h3><h4 id="8-1-Huffman树的相关概念"><a href="#8-1-Huffman树的相关概念" class="headerlink" title="8.1 Huffman树的相关概念"></a>8.1 Huffman树的相关概念</h4><p><strong>哈弗曼树 Huffman Tree</strong> 哈弗曼树又称最优二叉树，它是n个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树</p>
<blockquote>
<p>给定n权值作为n个叶子结点，构造一颗二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称Huffman树。<br><img src="/images/Huffman_explain.png" alt="哈夫曼树实例图解"><br><strong>路径</strong> 在一棵树中，从一个节点到另一个节点之间的分支构成的通路，如从结点8到节点1的路径如上图所示[若在一棵树中存在着一个结点序列k1，k2，……，kj，使得ki是ki+1的父亲(1&lt;=i&lt;j),则称该结点序列是从k1到kj的路径]<br><strong>路径长度</strong> 是指路径上的分支数目，在上图中，路径长度为2。[从k1到kj所经过的分支数称为这两个之间的路径长度]<br><strong>树的路径长度</strong> 是指从根到每个结点的路径长度之和<br><strong>结点的权</strong> 树中的结点上赋予一定意义的实数称之为该结点的权<br><strong>带权路径长度WPL</strong> 结点具有权值，从树根结点到该结点之间的路径长度与该结点上权的乘积之和称为该结点的带权路径长度。<br><strong>树的带权路径长度</strong> 树的带权路径长度定义为树中所有叶子结点的带权路径长度之和，记为：<br>WPL = （n-k=1）∑wklk；<br>其中n表示叶子结点个数，wi和li分别表示叶子结点ki的权值和根到ki之间的路径长度</p>
</blockquote>
<p>【例】将百分制的考试成绩转换成五分制的成绩<br>if(score &lt; 60) grade = 1;<br>else if(score &lt; 70) grade = 2;<br>else if(score &lt; 80) grade = 3;<br>else if(score &lt; 90) grade = 4;<br>else grade = 5;</p>
<p>判定树：<br><img src="/images/huffman_ep1.png" alt="哈夫曼树实例判定树"></p>
<p>如果考虑学生成绩的分布的概率：<br>分数段|0-59|60-69|70-79|80-89|90-100<br>比例|0.05|0.15|0.40|0.30|0.10</p>
<p> 平均查找效率: 0.05<em>1+0.15</em>2+0.4<em>3+0.3</em>4+0.1*4 = 3.15 【1,2,3,4 为使用该判断树进行判断的判定次数】</p>
<p> 换一种判别方法：<br> 修改判定树：<br> <img src="/images/huffman_ex2.png" alt="哈夫曼树实例判定树update"><br>if(score&lt;80)<br>{<br>    if(score&lt;70)<br>        if(score&lt;60) grade =1;<br>        else grade = 2;<br>} else if(score &lt; 90) grade = 4;<br>else grade = 5;<br>修改后的平均查找效率：0.05<em>3+0.15</em>3+0.4<em>2+0.3</em>2+0.1*2 = 2.2</p>
<p>我们可以根据不同的方法构造不同的搜索树，而不同的搜索树的搜索效率是不一样的。<br><strong>如何根据结点不同的查找效率构造更有效的搜索树？</strong></p>
<blockquote>
<p>这就是hufman树要解决的问题<br>最优二叉树或哈夫曼树：WPL最小的二叉树<br>【例】有五个叶子结点，它们的权值为{1,2,3,4,5},用此权值序列可以构造出形状不同的多个二叉树<br> <img src="/images/huffman_ex3_1.png" alt="哈夫曼树实例判定树01"><br> <img src="/images/huffman_ex3-2.png" alt="哈夫曼树实例判定树01"><br> <img src="/images/huffman_ex3_3.png" alt="哈夫曼树实例判定树01"></p>
</blockquote>
<h4 id="8-2-Huffman树的构建"><a href="#8-2-Huffman树的构建" class="headerlink" title="8.2 Huffman树的构建"></a>8.2 Huffman树的构建</h4><blockquote>
<p>每次把权值最小的两颗二叉树合并</p>
</blockquote>
<p>给定n个权值，用这n个权值来构建Huffman的算法描述如下：<br>(1) 将这n个权值分别看成只有根结点的n棵二叉树，将这些二叉树的集合即为F<br>(2) 从F中选出两颗根结点的权值最小的树，作为左右子树，构建一颗新的二叉树，新的二叉树的根结点的权值为左右子结点的权值之和。<br>(3) 从F中删去a，b，加入新构建的树C<br>(4) 重复2,3步，直到F中只剩下一棵树为止，这棵树就是Huffman树。</p>
<hr>
<p>1，7,3,4,9,8<br>=&gt; 从小到大排序: 1,3,4,7,8,9<br>=&gt; 选择最小的两个数字： 1,3<br>=&gt; 用类似树杈的树枝连接两个最小数，在顶点处计算出这两个数字的和，，然后在比较剩下的数字和这个和的大小，再取出最小的数字进行排列</p>
<h2 id="gt-如果两个数的和正好是下一步的两个最小数的其中一个，那么这个树直接往上生长就可以了。如果这两个数的和比较大不是下一步的两个最小数的其中一个，那么就并列生长"><a href="#gt-如果两个数的和正好是下一步的两个最小数的其中一个，那么这个树直接往上生长就可以了。如果这两个数的和比较大不是下一步的两个最小数的其中一个，那么就并列生长" class="headerlink" title="=&gt; 如果两个数的和正好是下一步的两个最小数的其中一个，那么这个树直接往上生长就可以了。如果这两个数的和比较大不是下一步的两个最小数的其中一个，那么就并列生长"></a>=&gt; 如果两个数的和正好是下一步的两个最小数的其中一个，那么这个树直接往上生长就可以了。如果这两个数的和比较大不是下一步的两个最小数的其中一个，那么就并列生长</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int Weight;</span><br><span class="line">    HuffmanTree Left, Right;</span><br><span class="line">&#125;</span><br><span class="line">HuffmanTree Huffman(MinHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    // 假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight里</span><br><span class="line">    int i; HuffmanTree T;</span><br><span class="line">    BuildMinHeap(H);//将H-&gt;Elements[]按权值调整为最小堆，根据频率建立一个堆</span><br><span class="line">    for (i=1;i&lt;H-&gt;size;i++)&#123; // 做H-&gt;size-1次合并</span><br><span class="line">        T = malloc(sizeof(struct TreeNode)); // 建立新结点</span><br><span class="line">        T-&gt;left = DeleteMin(H); // 从最小堆中删除一个结点作为新的T的左子结点</span><br><span class="line">        T-&gt;right = DeleteMin(H); // 从最小堆中删除一个结点作为新的T的右子结点</span><br><span class="line">        T-&gt;weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight // 计算新权值</span><br><span class="line">        Insert(H,T); // 将新T插入最小堆</span><br><span class="line">    &#125;</span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">整体复杂度为O（NlogN）</span><br><span class="line"></span><br><span class="line">如何选取两个最小的？ 利用堆，排序方法效率不如堆</span><br></pre></td></tr></table></figure>

<p>哈夫曼树的特点：<br>没有度为1的结点；</p>
<blockquote>
<p>n个叶子结点的哈夫曼树共有2n-1个结点：<br>    n0：叶结点总数<br>    n1：只有一个儿子的结点总数<br>    n2：有2个儿子的结点总数<br>    n2 = n0 -1；</p>
</blockquote>
<p>哈夫曼树的任意非叶子节点的左右子树交换后仍是哈夫曼树<br>对同一组权值{w1，w2，……，wn}，是否存在不同构的两颗哈夫曼树呢？<br><img src="/images/huffman_ex4_1.png" alt="哈夫曼树实例判定树01"></p>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>给定一段字符串，如何对字符进行编码，使得该字符串的编码存储空间最少？<br>[例]假设有一段文本，包含58个字符，并由以下7个字符构成：a，e，i，s，t，空格（sp），换行（nl）；这7个字符出现的次数不同，如何对这7个字符进行编码，使得总编码空间最少？</p>
<p>【分析】</p>
<ul>
<li>用等长ASCII编码：58*8 = 464位</li>
<li>用等长3位编码：58*3 = 174位</li>
<li>不等长编码：出现频率高的字符用编码短些的，出现频率低的字符可以用编码长些的。</li>
</ul>
<p>怎么进行不等长编码？</p>
<blockquote>
<p>a：1，e：0，s:10，t：11<br>    1011是什么字符串的编码：aeaa,aet,st<br>    这样的编码是有问题的,存在二义性，<br>如何避免二义性？<br>前缀码prefix code：任何字符的编码都不是另一字符编码的前缀<br>  可以无二义的解码，如何保证编码不会出现二义性？</p>
</blockquote>
<p>二叉树用于编码：</p>
<blockquote>
<p>用二叉树进行编码：<br>    1）左右分支：0,1<br>    2）字符只在叶结点上。<br>四个字符的频率：a：4，u：1，x：2，z：1<br>等长码编码：<br><img src="/images/dengchangma.png" alt="等长码"><br>当所有结点在二叉树叶结点上时就不可能出现前缀码<br>Cost（aaaxuaxz-&gt; 00 00 00 10 01 00 10 11） = 2<em>4+2</em>1+2<em>2+2</em>1 = 16</p>
</blockquote>
<p><img src="/images/feidengchangma.png" alt="非等长码"> 有二义性<br>这种就会出现前缀码</p>
<p><img src="/images/feidengchangNo.png" alt="非等长码"> 无二义性</p>
<p>可以用二叉树构造编码，只要对象在叶结点上，编码就不会有二义性</p>
<p>怎么构造一颗编码代码最小的二叉树？（用哈夫曼树）</p>
<p>[例]哈夫曼编码：由7个字符构成的58个字符的字符串，怎么进行编码？<br>Cj |a |e |i |s |t |sp |nl<br>fi |10 |15 |12 |3 |4 |13 |1 (出现的频率)</p>
<p>根据频率构造huffman树：</p>
<p><img src="/images/huffman_ex5.png" alt="例题答案"> </p>
<p>Cost = 3<em>10 + 2</em>15 + 2<em>12 + 5</em>3 + 4<em>4 + 2</em>13 + 5*1 = 146</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/bekjae.jpg" alt="KOKI HOO">
            
              <p class="site-author-name" itemprop="name">KOKI HOO</p>
              <p class="site-description motion-element" itemprop="description">PEACE&LOVE</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KOKI HOO</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">19.4k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("jD3hLxRDgCSdorrir1RFkW3R-gzGzoHsz", "9AOQX6uUKthSSONK5UO95RGd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
