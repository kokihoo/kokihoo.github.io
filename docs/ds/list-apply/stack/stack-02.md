### :page_with_curl:02：设单链表的表头指针为L，结点结构由data和next两个域构成，其中data域为字符型。试设计算法判断该链表的全部n个字符是否中心对称。例如xyx、xyyx都是中心对称。

---

#### :writing_hand: 算法思想：
> - 使用栈来判断链表中的数据是否中心对称。让链表的前一半元素依次进栈。在处理链表的后一半元素时，当访问到链表的一个元素后，就从栈中弹出一个元素，两个元素比较，若相等，则将链表中的下一个元素与栈中再弹出的元素比较，直至链表到尾。这时若栈时空栈，则得出链表中心对称的结论；否则，当链表中的一个元素与栈中弹出元素不等时，结论为链表非中心对称，结束算法的执行。
> - 算法先将"链表的前一半"元素(字符)进栈.当n为偶数时,前一半和后一半的个数相同;当n为奇数时,链表中心结点字符不必比较,移动链表指针到下一字符开始比较.比较过程中遇到不相等时,立即退出while循环,不再进行比较.


<!-- ::: details 查看代码  -->
::: info  查看代码 :cup_with_straw:
```C
int dc(LinkList L, int n){
    int i;
    char s[n/2]; // s字符栈
    LNode *p = L->next; // 工作指针p,指向待处理的当前元素
    for(i=0; i<n/2; i++){
        s[i]=p->data;
        p=p->next;
    }
    i--; // 恢复最后的i的值

    if(n%2==1) // n是奇数,后移过中心结点
        p=p->next;
    while(p!=NULL && s[i]==p->data){ // 检测是否中心对称
        i--; // i充当栈顶指针
        p=p->next;
    }
    if(i==-1) // 栈为空栈
        return 1; // 链表中心对称
    else
        return 0; // 链表不中心对称
}

```
:::

