### :page_with_curl:01：已知一颗二叉树按顺序存储结构进行存储，设计一个算法，求编号分别为i和j的两个结点的最近的公共祖先结点的值。

---

#### :writing_hand: 算法思想：
> 首先，必须明确二叉树中任意两个结点必然存在最近的公共祖先结点，最坏的情况下是根结点(两个结点分别在根结点的左右分支中)，而且从最近的祖先结点到根结点的全部祖先结点都是公共的。由二叉树顺序存储的性质可知，任意一个结点i的双亲结点的编号为i/2.求解i和j最近公共祖先结点的算法步骤如下(设从数组下标1开始存储)：
 
 - ① 若i>j，则结点i所在层次大于或等于结点j所在层次。结点i的双亲结点为结点i/2,若i/2=j,则结点i/2是原结点i和结点j的最近公共祖先结点，若i/2≠j，则令i=i/2，即以该结点i的双亲结点为起点，采用递归的方法继续查找。
 - ② 若j>i，则结点j所在层次大于或等于结点i所在层次。结点j的双亲结点为结点j/2，若j/2=i，则结点j/2是原结点i和结点j的最近公共祖先结点，若j/2≠i，则令j=j/2。
 > 重复上述过程，直到找到它们最近的公共祖先结点为止。


<!-- ::: details 查看代码  -->
::: info  查看代码 :cup_with_straw:
```C
ElemType Comm_Ancestor(SqTree T, int i, int j) {
    // 本算法在二叉树中查找结点i和结点j的最近公共祖先结点
    if(T[i]!='#' && T[j]!='#') { // 结点存在
    // 两个编号不同时;继续循环 直接找到公共祖先结点 跳出循环即为找到公共祖先结点
        while(i!=j){ 
            if(i>j)
              i=i/2; // 向上找i的祖先
            else
              j=j/2; // 向上找j的祖先
        }
        return T[i];
    }
}

```
:::

