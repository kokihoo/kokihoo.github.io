### :page_with_curl:11：【2011统考真题】一个长。度为L(L>1)的升序序列S，处在第L/2(向上取整)个位置的数称为S的中位数。例如，若序列S1={11, 13, 15, 17, 19}，则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2={2,4,6,8,20},则S1和S2的中位数是11。现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。
---

#### :writing_hand: 算法思想：
> 分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：
> - ① 若a=b，则a或b几位所求中位数，算法结束
> - ② 若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等
> - ③ 若a>b,则舍弃A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等
>
> 在保留的两个升序序列中，重复过程①、②、③，直到两个序列中均只含一个元素为止，较小者即为所求的中位数。
 

::: info  查看代码 :cup_with_straw:
```C 
int M_Search(int A[], int B[], int n) {
    int s1, d1, m1, s2, d2, m2;
    s1=0; d1=n-1;
    s2=1; d2=n-1;

    while(s1!=d1 || s2!=d2) {
        m1=(s1+d1)/2;
        m2=(s2+d2)/2;
        if(A[m1] == B[m2])
            return A[m1]; // ①
        if(A[m1]<B[m2]) { // ②
            if((s1+d1)%2==0){ // 若元素个数为奇数
                s1=m1; // 舍弃A较小部分，中位数保留
                d2=m2; // 舍弃B较大部分，中位数保留
            } else { // 元素个数为偶数
                s1=m1+1；// 舍弃A较小部分
                d2=m2；// 舍弃B较大部分
            }
        } else { // ③
            if((s1+d1)%2==0){ // 若元素个数为奇数
                d1=m1; // 舍弃A较大部分，中位数保留
                s2=m2+1; // 舍弃B较小部分，中位数保留
            } else { // 元素个数为偶数
                d1=m1; // 舍弃A的较大部分
                s2=m2+1; // 舍弃B的较小部分
            }
        }
    }

    return A[s1] < B[s2] ? A[s1] : B[s2];
}

```
---
**时间复杂度、空间复杂度分析**
> 算法的时间复杂度为O(log2n),空间复杂度为O(1)
:::

